{"language": "Vyper", "sources": {"lib/github/pcaversaccio/snekmate/src/snekmate/auth/ownable.vy": {"content": "# pragma version ~=0.4.0\n\"\"\"\n@title Owner-Based Access Control Functions\n@custom:contract-name ownable\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to implement a basic access\n        control mechanism, where there is an account (an owner)\n        that can be granted exclusive access to specific functions.\n        By default, the owner account will be the one that deploys\n        the contract. This can later be changed with `transfer_ownership`.\n        An exemplary integration can be found in the ERC-20 implementation here:\n        https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/tokens/erc20.vy.\n        The implementation is inspired by OpenZeppelin's implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol.\n\"\"\"\n\n\n# @dev Returns the address of the current owner.\n# @notice If you declare a variable as `public`,\n# Vyper automatically generates an `external`\n# getter function for the variable.\nowner: public(address)\n\n\n# @dev Emitted when the ownership is transferred\n# from `previous_owner` to `new_owner`.\nevent OwnershipTransferred:\n    previous_owner: indexed(address)\n    new_owner: indexed(address)\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice The `owner` role will be assigned to\n            the `msg.sender`.\n    \"\"\"\n    self._transfer_ownership(msg.sender)\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice Note that this function can only be\n            called by the current `owner`. Also,\n            the `new_owner` cannot be the zero address.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    self._check_owner()\n    assert new_owner != empty(address), \"ownable: new owner is the zero address\"\n    self._transfer_ownership(new_owner)\n\n\n@external\ndef renounce_ownership():\n    \"\"\"\n    @dev Leaves the contract without an owner.\n    @notice Renouncing ownership will leave the\n            contract without an owner, thereby\n            removing any functionality that is\n            only available to the owner.\n    \"\"\"\n    self._check_owner()\n    self._transfer_ownership(empty(address))\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"ownable: caller is not the owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice This is an `internal` function without\n            access restriction.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner, new_owner)\n", "sha256sum": "88ae32cf8b3e4a332d6518256019193419150e7ff716dd006a8d471550c329fc"}, "lib/github/pcaversaccio/snekmate/src/snekmate/utils/create2_address.vy": {"content": "# pragma version ~=0.4.0\n\"\"\"\n@title `CREATE2` EVM Opcode Utility Functions for Address Calculations\n@custom:contract-name create2_address\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to compute in advance the address\n        where a smart contract will be deployed if deployed via the\n        `CREATE2` opcode. The implementation is inspired by OpenZeppelin's\n        implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Create2.sol.\n\"\"\"\n\n\n# @dev The 1-byte `CREATE2` offset constant used to prevent\n# collisions with addresses created using the traditional\n# `keccak256(rlp([sender, nonce]))` formula.\n_COLLISION_OFFSET: constant(bytes1) = 0xFF\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    \"\"\"\n    pass\n\n\n@internal\n@view\ndef _compute_address_self(salt: bytes32, bytecode_hash: bytes32) -> address:\n    \"\"\"\n    @dev Returns the address where a contract will be stored if\n         deployed via this contract using the `CREATE2` opcode.\n         Any change in the `bytecode_hash` or `salt` values will\n         result in a new destination address.\n    @param salt The 32-byte random value used to create the contract\n           address.\n    @param bytecode_hash The 32-byte bytecode digest of the contract\n           creation bytecode.\n    @return address The 20-byte address where a contract will be stored.\n    \"\"\"\n    return self._compute_address(salt, bytecode_hash, self)\n\n\n@internal\n@pure\ndef _compute_address(salt: bytes32, bytecode_hash: bytes32, deployer: address) -> address:\n    \"\"\"\n    @dev Returns the address where a contract will be stored if\n         deployed via `deployer` using the `CREATE2` opcode.\n         Any change in the `bytecode_hash` or `salt` values will\n         result in a new destination address.\n    @param salt The 32-byte random value used to create the contract\n           address.\n    @param bytecode_hash The 32-byte bytecode digest of the contract\n           creation bytecode.\n    @param deployer The 20-byte deployer address.\n    @return address The 20-byte address where a contract will be stored.\n    \"\"\"\n    data: bytes32 = keccak256(concat(_COLLISION_OFFSET, convert(deployer, bytes20), salt, bytecode_hash))\n    return self._convert_keccak256_2_address(data)\n\n\n@internal\n@pure\ndef _convert_keccak256_2_address(digest: bytes32) -> address:\n    \"\"\"\n    @dev Converts a 32-byte keccak256 digest to an address.\n    @param digest The 32-byte keccak256 digest.\n    @return address The converted 20-byte address.\n    \"\"\"\n    return convert(convert(digest, uint256) & convert(max_value(uint160), uint256), address)\n", "sha256sum": "565b1822e48ddd153e5552a8c80d5ed2cd9d0d3d779d2f2295611028b239b140"}, "src/interfaces/UntronReceiver.vyi": {"content": "# Functions\n\n@external\ndef initialize():\n    ...\n\n@external\ndef withdraw(_token: address) -> uint256:\n    ...\n\n@view\n@external\ndef deployer() -> address:\n    ...", "sha256sum": "01cc88120daa3651f873965796cd138c3b210946acccfc3efe9783fbbe0b8546"}, "src/interfaces/UntronTransfers.vyi": {"content": "# Structs\nstruct Order:\n    # Address of the refund beneficiary.\n    # This is the address that will receive the funds\n    # if the order is not filled before the deadline.\n    refundBeneficiary: address\n\n    # Address of the token to swap from.\n    # Must be a deployed ERC20 token on the deployed chain.\n    token: address\n\n    # Amount of the token to swap from.\n    inputAmount: uint256\n\n    # Tron address to receive Tron USDT.\n    to: bytes20\n\n    # Amount of the Tron USDT to receive.\n    outputAmount: uint256\n\n    # Deadline for the order.\n    # If the order is not filled before the deadline,\n    # the funds can be refunded to the refundBeneficiary.\n    deadline: uint256\n\n    # Address that will receive a portion of the input tokens\n    referrer: address\n\n    # How much of the input tokens will be sent to the referrer.\n    # The referrer will receive a portion of the input tokens\n    # as compensation for bringing the user (refundBeneficiary) to the platform.\n    # The referrer fee is deducted from the input amount.\n    referrerFee: uint256\n\n# Events\n\nevent OrderCreated:\n    orderId: bytes32\n    refundBeneficiary: address\n    token: address\n    inputAmount: uint256\n    to: bytes20\n    outputAmount: uint256\n    deadline: uint256\n    referrer: address\n    referrerFee: uint256\nevent OrderCleared:\n    orderId: bytes32\nevent OwnershipTransferred:\n    previous_owner: address\n    new_owner: address\n\n# Functions\n\n@external\ndef transfer_ownership(new_owner: address):\n    ...\n\n@view\n@external\ndef owner() -> address:\n    ...\n\n@external\ndef setReferrer(user: address, referrer: address):\n    ...\n\n@external\ndef configure(newRelayer: address, fixedFee: uint256, percentFee: uint256, referrerFee: uint256):\n    ...\n\n@view\n@external\ndef recommendedOutputAmount(inputAmount: uint256) -> uint256:\n    ...\n\n@external\ndef cancel(orderId: bytes32):\n    ...\n\n@external\ndef claim(orderId: bytes32):\n    ...\n\n@external\ndef compactSwap(token: address, swapData: bytes32) -> bytes32:\n    ...\n\n@external\ndef compactUsdt(swapData: bytes32) -> bytes32:\n    ...\n\n@external\ndef compactUsdc(swapData: bytes32) -> bytes32:\n    ...\n\n@view\n@external\ndef orders(arg0: bytes32) -> Order:\n    ...\n\n@view\n@external\ndef nonces(arg0: address) -> uint256:\n    ...\n\n@view\n@external\ndef referrers(arg0: address) -> address:\n    ...\n\n@view\n@external\ndef referrerFee() -> uint256:\n    ...\n\n@view\n@external\ndef trustedRelayer() -> address:\n    ...", "sha256sum": "ed6d722b6cc6609a3541505b1ca6fddffdf56d5198407a519b6bf5dd6c35e6fd"}, "src/ReceiverFactory.vy": {"content": "# pragma version 0.4.0\n# @license MIT\n\n\"\"\"\n@title Untron Intents Receiver Factory\n@notice A factory for deploying UntronReceiver contracts for Tron addresses.\n@dev This contract is used to deploy UntronReceiver contracts for Tron addresses.\n     These contracts then automatically bridge the tokens to the designated Tron addresses.\n\"\"\"\n\nfrom ethereum.ercs import IERC20\nfrom lib.github.pcaversaccio.snekmate.src.snekmate.auth import ownable\nfrom lib.github.pcaversaccio.snekmate.src.snekmate.utils import create2_address\n# from src.interfaces import ReceiverFactory\nfrom src.interfaces import UntronReceiver\nfrom src.interfaces import UntronTransfers\n\ninitializes: ownable\n# implements: ReceiverFactory\nexports: ownable.transfer_ownership\nexports: ownable.owner\n\n# Address of the blueprint implementation for UntronReceiver contracts.\n_receiverImplementation: immutable(address)\n# Address of the UntronTransfers contract, which handles the bridging orders.\nuntronTransfers: public(address)\n# Address of the trusted swapper.\n# This can be an EOA or a smart contract (e.g., a TWAP-based swap contract or other AMM logic).\n# This address is authorized to call swapForReceiver.\ntrustedSwapper: public(address)\n\n# Address of the USDT token contract on the EVM chain.\nusdt: public(address)\n# Address of the USDC token contract on the EVM chain.\nusdc: public(address)\n\n# Event emitted when a new UntronReceiver contract is deployed.\nevent ReceiverDeployed:\n    # The Tron address for which the receiver was deployed.\n    destinationTronAddress: bytes20\n    # The EVM address of the deployed UntronReceiver contract.\n    receiver: address\n\n@deploy\ndef __init__(__receiverImplementation: address):\n    \"\"\"\n    @notice Contract constructor, called once at deployment.\n    \"\"\"\n    # Initialize the Ownable component, setting the deployer as the initial owner.\n    ownable.__init__()\n    # Set the address of the UntronReceiver implementation contract.\n    _receiverImplementation = __receiverImplementation\n\n\n@external\n@view\ndef receiverImplementation() -> address:\n    \"\"\"\n    @notice External view function to return the address of the UntronReceiver implementation contract.\n    @return address The address of the UntronReceiver implementation contract.\n    \"\"\"\n    return _receiverImplementation\n\n\n@external\ndef configure(untronTransfers: address, trustedSwapper: address, usdt: address, usdc: address):\n    \"\"\"\n    @notice External function to configure critical addresses, callable only by the owner.\n    @param untronTransfers Address of the UntronTransfers contract\n    @param trustedSwapper Address of the trusted swapper\n    @param usdt Address of the USDT token\n    @param usdc Address of the USDC token\n    \"\"\"\n    # Ensure only the owner can call this function.\n    ownable._check_owner()\n    # Set the address of the UntronTransfers contract.\n    self.untronTransfers = untronTransfers\n    # Set the address of the trusted swapper.\n    self.trustedSwapper = trustedSwapper\n    # Set the address of the USDT token.\n    self.usdt = usdt\n    # Set the address of the USDC token.\n    self.usdc = usdc\n\n\n@internal\n@view\ndef _constructSwapData(amount: uint256, destinationTronAddress: bytes20) -> bytes32:\n    \"\"\"\n    @notice Internal view function to construct the compact swap data for UntronTransfers.\n    @param amount The amount of tokens to swap\n    @param destinationTronAddress The Tron address to receive the swapped tokens\n    @return bytes32 The constructed swap data\n    \"\"\"\n    # Constructs a bytes32 payload for UntronTransfers compact swap functions.\n    # Format: amount (first 6 bytes for input) | 0 (next 6 bytes for output, so UntronTransfers uses recommended) | destinationTronAddress (last 20 bytes).\n    # Left-shift amount by 208 bits (26 bytes) to place it in the most significant part of the bytes32.\n    # Convert destinationTronAddress to uint160, then to uint256, to align it for bitwise OR.\n    # The output amount (middle 6 bytes) is intentionally set to 0.\n    # This signals the UntronTransfers contract to use its recommended output amount.\n    return convert((amount << 208) | convert(convert(destinationTronAddress, uint160), uint256), bytes32)\n\n\n@internal\ndef _intron(destinationTronAddress: bytes20, receiverAddress: address):\n    \"\"\"\n    @notice Internal function to process funds held by a receiver and initiate bridging via UntronTransfers.\n    @param destinationTronAddress The Tron address to receive the bridged tokens\n    @param receiverAddress The address of the UntronReceiver contract\n    \"\"\"\n    # Create an UntronReceiver instance for the given receiverAddress.\n    receiver: UntronReceiver = UntronReceiver(receiverAddress)\n    # Call the receiver's withdraw function to get its entire USDT balance, transferring it to this factory contract.\n    usdtAmount: uint256 = extcall receiver.withdraw(self.usdt)\n    # Call the receiver's withdraw function to get its entire USDC balance, transferring it to this factory contract.\n    usdcAmount: uint256 = extcall receiver.withdraw(self.usdc)\n\n    # If there's a USDT balance withdrawn from the receiver:\n    if usdtAmount > 0:\n        # Call compactUsdt on the UntronTransfers contract to create a bridging order for the USDT.\n        extcall IERC20(self.usdt).approve(self.untronTransfers, usdtAmount)\n        extcall UntronTransfers(self.untronTransfers).compactUsdt(self._constructSwapData(usdtAmount, destinationTronAddress))\n    # If there's a USDC balance withdrawn from the receiver:\n    if usdcAmount > 0:\n        # Call compactUsdc on the UntronTransfers contract to create a bridging order for the USDC.\n        extcall IERC20(self.usdc).approve(self.untronTransfers, usdcAmount)\n        extcall UntronTransfers(self.untronTransfers).compactUsdc(self._constructSwapData(usdcAmount, destinationTronAddress))\n\n\n@external\ndef withdraw(destinationTronAddress: bytes20, tokens: DynArray[address, 8]):\n    \"\"\"\n    @notice External function allowing a trustedSwapper to withdraw tokens from a receiver contract.\n    @dev A trustedSwapper is supposed to be a smart contract at some point, and it will use this function to\n         swap all tokens received into USDT or USDC which can then be used to initiate swaps to Tron\n    @param destinationTronAddress The Tron address associated with the receiver contract\n    @param tokens An array of token addresses to withdraw\n    \"\"\"\n    # Asserts that the caller is the trustedSwapper.\n    # The trustedSwapper can be an EOA or a smart contract that handles swaps in a trust-minimized way.\n    assert msg.sender == self.trustedSwapper, \"unauthorized\"\n    \n    # Calculate the deterministic address for the receiver contract.\n    contract: address = self._generateReceiverAddress(destinationTronAddress)\n    # If the receiver contract hasn't been deployed yet (no code at the address):\n    if contract.codesize == 0:\n        # Deploy the receiver contract.\n        self.deploy(destinationTronAddress)\n\n    # Create an UntronReceiver instance for the (now deployed) receiver contract.\n    receiver: UntronReceiver = UntronReceiver(contract)\n    # Call the receiver's withdraw function to pull any `tokens` it might already hold (normally from a user's direct deposit).\n    # We will then send the tokens to the relayer.\n    for token: address in tokens:\n        inputAmount: uint256 = extcall receiver.withdraw(token)\n        if inputAmount > 0:\n            extcall IERC20(token).transfer(msg.sender, inputAmount)\n\n@external\ndef intron(destinationTronAddress: bytes20):\n    \"\"\"\n    @notice External function to initiate the bridging process for funds already in a receiver, or deploy and then bridge.\n    @param destinationTronAddress The Tron address to receive the bridged tokens\n    \"\"\"\n    # Calculate the deterministic address for the receiver contract.\n    contract: address = self._generateReceiverAddress(destinationTronAddress)\n    # If the receiver contract hasn't been deployed yet:\n    if contract.codesize == 0:\n        # Deploy the receiver contract.\n        self.deploy(destinationTronAddress)\n\n    # Call the internal _intron function to process funds in the receiver and bridge them.\n    self._intron(destinationTronAddress, contract)\n\n@internal\ndef deploy(destinationTronAddress: bytes20) -> address:\n    \"\"\"\n    @notice Internal function to deploy a new UntronReceiver minimal proxy contract.\n    @param destinationTronAddress The Tron address associated with the new receiver\n    @return address The address of the newly deployed receiver contract\n    \"\"\"\n    # Deploy an EIP-1167 minimal proxy pointing to self.receiverImplementation.\n    # The salt is derived from the destinationTronAddress to ensure deterministic deployment unique to that Tron address.\n    contract: address = create_minimal_proxy_to(_receiverImplementation, salt=convert(destinationTronAddress, bytes32))\n    # Create an UntronReceiver instance for the newly deployed contract.\n    receiver: UntronReceiver = UntronReceiver(contract)\n    # Call the initialize function on the new receiver contract (likely to set its deployer/owner).\n    extcall receiver.initialize()\n    # Log an event indicating the deployment of the new receiver.\n    log ReceiverDeployed(destinationTronAddress, contract)\n\n    # Return the address of the newly deployed receiver contract.\n    return contract\n\n@internal\n@view\ndef _generateReceiverAddress(destinationTronAddress: bytes20) -> address:\n    \"\"\"\n    @notice Internal view function to calculate the deterministic address of an UntronReceiver contract using CREATE2.\n    @param destinationTronAddress The Tron address associated with the receiver\n    @return address The calculated address where the UntronReceiver will be deployed\n    \"\"\"\n    # This function computes the address where a new UntronReceiver will be deployed\n    # using CREATE2, based on the destinationTronAddress and the receiverImplementation.\n    # This allows anyone to predict the receiver's address before deployment.\n\n    # Construct the exact ERC-1167 minimal proxy bytecode that `create_minimal_proxy_to` would use.\n    # This bytecode includes the address of `self.receiverImplementation`.\n    # The ERC-1167 standard specifies a lean proxy contract that delegates all calls to a fixed implementation.\n    # Bytecode structure:\n    # Prefix (opcodes for setup and returning code)\n    # + self.receiverImplementation (the address of the logic contract)\n    # + Suffix (opcodes for delegation and revert)\n    # Source: https://ercs.ethereum.org/ERCS/erc-1167\n    init_code: Bytes[54] = concat(\n        # 9-byte initialization opcode set + first 10 bytes of ERC-1167 standard proxy bytecode.\n        b\"\\x60\\x2d\\x3d\\x81\\x60\\x09\\x3d\\x39\\xf3\\x36\\x3d\\x3d\\x37\\x3d\\x3d\\x3d\\x36\\x3d\\x73\",\n        # The 20-byte address of the receiverImplementation contract is embedded here.\n        convert(_receiverImplementation, bytes20),\n        # Last 15 bytes of the ERC-1167 standard proxy bytecode.\n        b\"\\x5a\\xf4\\x3d\\x82\\x80\\x3e\\x90\\x3d\\x91\\x60\\x2b\\x57\\xfd\\x5b\\xf3\"\n    )\n\n    # Calculate the Keccak256 hash of this initialization code.\n    # This hash is used in the CREATE2 address calculation formula.\n    init_code_hash: bytes32 = keccak256(init_code)\n\n    # Compute the CREATE2 address using:\n    # keccak256(0xff + sender_address + salt + keccak256(init_code))[12:]\n    # Here, `_compute_address_self` uses `self` (this contract's address) as the sender_address.\n    # The salt is derived from the destinationTronAddress.\n    return create2_address._compute_address_self(convert(destinationTronAddress, bytes32), init_code_hash)\n\n@external\n@view\ndef generateReceiverAddress(destinationTronAddress: bytes20) -> address:\n    \"\"\"\n    @notice External view function to publicly expose the receiver address generation logic.\n    @param destinationTronAddress The Tron address for which to generate the receiver address\n    @return address The deterministically\n    \"\"\"\n    # Returns the deterministically calculated EVM address for an UntronReceiver\n    # corresponding to the given destinationTronAddress.\n    return self._generateReceiverAddress(destinationTronAddress)", "sha256sum": "51d61f8d4f03ea2c51b146ccac84650786ebfb3d1d60eedf9ae33bcf5c118d0d"}}, "settings": {"outputSelection": {"src/ReceiverFactory.vy": ["*"]}, "search_paths": ["."]}, "compiler_version": "v0.4.0+commit.e9db8d9", "integrity": "246a879efd95d3cfc93691417a709aff6aac36c4e5f65533ffb1e2e62df330f4"}
