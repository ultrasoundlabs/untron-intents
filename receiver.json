{"language": "Vyper", "sources": {"src/interfaces/UntronTransfers.vyi": {"content": "# Structs\nstruct Order:\n    # Address of the refund beneficiary.\n    # This is the address that will receive the funds\n    # if the order is not filled before the deadline.\n    refundBeneficiary: address\n\n    # Address of the token to swap from.\n    # Must be a deployed ERC20 token on the deployed chain.\n    token: address\n\n    # Amount of the token to swap from.\n    inputAmount: uint256\n\n    # Tron address to receive Tron USDT.\n    to: bytes20\n\n    # Amount of the Tron USDT to receive.\n    outputAmount: uint256\n\n    # Deadline for the order.\n    # If the order is not filled before the deadline,\n    # the funds can be refunded to the refundBeneficiary.\n    deadline: uint256\n\n    # Address that will receive a portion of the input tokens\n    referrer: address\n\n    # How much of the input tokens will be sent to the referrer.\n    # The referrer will receive a portion of the input tokens\n    # as compensation for bringing the user (refundBeneficiary) to the platform.\n    # The referrer fee is deducted from the input amount.\n    referrerFee: uint256\n\n# Events\n\nevent OrderCreated:\n    orderId: bytes32\n    refundBeneficiary: address\n    token: address\n    inputAmount: uint256\n    to: bytes20\n    outputAmount: uint256\n    deadline: uint256\n    referrer: address\n    referrerFee: uint256\nevent OrderCleared:\n    orderId: bytes32\nevent OwnershipTransferred:\n    previous_owner: address\n    new_owner: address\n\n# Functions\n\n@external\ndef transfer_ownership(new_owner: address):\n    ...\n\n@view\n@external\ndef owner() -> address:\n    ...\n\n@external\ndef setReferrer(user: address, referrer: address):\n    ...\n\n@external\ndef configure(newRelayer: address, fixedFee: uint256, percentFee: uint256, referrerFee: uint256):\n    ...\n\n@view\n@external\ndef recommendedOutputAmount(inputAmount: uint256) -> uint256:\n    ...\n\n@external\ndef cancel(orderId: bytes32):\n    ...\n\n@external\ndef claim(orderId: bytes32):\n    ...\n\n@external\ndef compactSwap(token: address, swapData: bytes32) -> bytes32:\n    ...\n\n@external\ndef compactUsdt(swapData: bytes32) -> bytes32:\n    ...\n\n@external\ndef compactUsdc(swapData: bytes32) -> bytes32:\n    ...\n\n@view\n@external\ndef orders(arg0: bytes32) -> Order:\n    ...\n\n@view\n@external\ndef nonces(arg0: address) -> uint256:\n    ...\n\n@view\n@external\ndef referrers(arg0: address) -> address:\n    ...\n\n@view\n@external\ndef referrerFee() -> uint256:\n    ...\n\n@view\n@external\ndef trustedRelayer() -> address:\n    ...", "sha256sum": "ed6d722b6cc6609a3541505b1ca6fddffdf56d5198407a519b6bf5dd6c35e6fd"}, "src/UntronReceiver.vy": {"content": "# pragma version 0.4.0\n# @license MIT\n\n\"\"\"\n@title Untron Intents Receiver\n@notice A receiver contract for Untron Intents.\n@dev This contract is used to receive tokens from Untron Intents and bridge them to the designated Tron addresses.\n\"\"\"\n\nfrom ethereum.ercs import IERC20\n# from src.interfaces import UntronReceiver\nfrom src.interfaces import UntronTransfers\n\n# implements: UntronReceiver\n\n# Address of the deployer contract (ReceiverFactory).\n# Not using Ownable for a cleaner implementation.\ndeployer: public(address)\n\n@external\ndef initialize():\n    \"\"\"\n    @notice Initializes the contract, setting the deployer.\n    \"\"\"\n    self.deployer = msg.sender\n\n@external\ndef withdraw(_token: address) -> uint256:\n    \"\"\"\n    @notice Withdraws a specific token (or ETH) to the deployer contract.\n    @dev The deployer contract can then swap it for USDT or USDC and send to UntronTransfers contract.\n    @param _token The address of the token to withdraw (or empty address for ETH).\n    @return The amount of tokens or ETH withdrawn.\n    \"\"\"\n    # Verify that only the deployer contract can call this function\n    assert msg.sender == self.deployer, \"unauthorized\"\n    \n    # Initialize balance variable to track amount being withdrawn\n    _balance: uint256 = 0\n    \n    # If we withdraw ETH, _token is all zeros\n    if _token != empty(address):\n        # Create interface to interact with the token contract\n        token: IERC20 = IERC20(_token)\n        # Get the current token balance of this contract\n        _balance = staticcall token.balanceOf(self)\n        # If there are tokens to withdraw, transfer them to deployer\n        if _balance > 0:\n            extcall token.transfer(self.deployer, _balance)\n    else:\n        # For ETH withdrawal, get the contract's ETH balance\n        _balance = self.balance\n        # If there is ETH to withdraw, send it to deployer\n        if _balance > 0:\n            send(self.deployer, _balance)\n    \n    # Return the amount that was withdrawn\n    return _balance\n\n@external\n@payable\ndef __default__():\n    \"\"\"\n    @notice Fallback function to receive ETH.\n    \"\"\"\n    pass", "sha256sum": "9fc69249cf74b1b71572c604a89da3401229551b0590f120035f84e998b82384"}}, "settings": {"outputSelection": {"src/UntronReceiver.vy": ["*"]}, "search_paths": ["."]}, "compiler_version": "v0.4.0+commit.e9db8d9", "integrity": "6d5f001ca74f2a132378ab78f1a379eb65b0a2175c64e2a270aacc9104a63715"}
