{"language": "Vyper", "sources": {"lib/github/pcaversaccio/snekmate/src/snekmate/auth/ownable.vy": {"content": "# pragma version ~=0.4.0\n\"\"\"\n@title Owner-Based Access Control Functions\n@custom:contract-name ownable\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to implement a basic access\n        control mechanism, where there is an account (an owner)\n        that can be granted exclusive access to specific functions.\n        By default, the owner account will be the one that deploys\n        the contract. This can later be changed with `transfer_ownership`.\n        An exemplary integration can be found in the ERC-20 implementation here:\n        https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/tokens/erc20.vy.\n        The implementation is inspired by OpenZeppelin's implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol.\n\"\"\"\n\n\n# @dev Returns the address of the current owner.\n# @notice If you declare a variable as `public`,\n# Vyper automatically generates an `external`\n# getter function for the variable.\nowner: public(address)\n\n\n# @dev Emitted when the ownership is transferred\n# from `previous_owner` to `new_owner`.\nevent OwnershipTransferred:\n    previous_owner: indexed(address)\n    new_owner: indexed(address)\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice The `owner` role will be assigned to\n            the `msg.sender`.\n    \"\"\"\n    self._transfer_ownership(msg.sender)\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice Note that this function can only be\n            called by the current `owner`. Also,\n            the `new_owner` cannot be the zero address.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    self._check_owner()\n    assert new_owner != empty(address), \"ownable: new owner is the zero address\"\n    self._transfer_ownership(new_owner)\n\n\n@external\ndef renounce_ownership():\n    \"\"\"\n    @dev Leaves the contract without an owner.\n    @notice Renouncing ownership will leave the\n            contract without an owner, thereby\n            removing any functionality that is\n            only available to the owner.\n    \"\"\"\n    self._check_owner()\n    self._transfer_ownership(empty(address))\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"ownable: caller is not the owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice This is an `internal` function without\n            access restriction.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner, new_owner)\n", "sha256sum": "88ae32cf8b3e4a332d6518256019193419150e7ff716dd006a8d471550c329fc"}, "src/UntronTransfers.vy": {"content": "# pragma version 0.4.0\n# @license MIT\n\n\"\"\"\n@title Untron Transfers\n@notice An intent-based bridge for sending ERC20 tokens as USDT on Tron\n@dev This version of the contract uses a trusted relayer to handle the swaps.\n     In the future versions, Untron's ZK engine will be used for permissionless solving.\n\"\"\"\n\nfrom ethereum.ercs import IERC20\nfrom lib.github.pcaversaccio.snekmate.src.snekmate.auth import ownable\n\ninitializes: ownable\nexports: ownable.transfer_ownership\nexports: ownable.owner\n\n# Order struct for tracking yet unfilled swap orders\nstruct Order:\n    # Address of the refund beneficiary.\n    # This is the address that will receive the funds\n    # if the order is not filled before the deadline.\n    refundBeneficiary: address\n\n    # Address of the token to swap from.\n    # Must be a deployed ERC20 token on the deployed chain.\n    token: address\n\n    # Amount of the token to swap from.\n    inputAmount: uint256\n\n    # Tron address to receive Tron USDT.\n    to: bytes20\n\n    # Amount of the Tron USDT to receive.\n    outputAmount: uint256\n\n    # Deadline for the order.\n    # If the order is not filled before the deadline,\n    # the funds can be refunded to the refundBeneficiary.\n    deadline: uint256\n\n    # Address that will receive a portion of the input tokens\n    referrer: address\n\n    # How much of the input tokens will be sent to the referrer.\n    # The referrer will receive a portion of the input tokens\n    # as compensation for bringing the user (refundBeneficiary) to the platform.\n    # The referrer fee is deducted from the input amount.\n    referrerFee: uint256\n\n# Event for when an order is created\n# Listened to by the relayers to track new orders\nevent OrderCreated:\n    # ID of the created order\n    orderId: bytes32\n    # Address of the refund beneficiary.\n    # This is the address that will receive the funds\n    # if the order is not filled before the deadline.\n    refundBeneficiary: address\n\n    # Address of the token to swap from.\n    # Must be a deployed ERC20 token on the deployed chain.\n    token: address\n\n    # Amount of the token to swap from.\n    inputAmount: uint256\n\n    # Tron address to receive Tron USDT.\n    to: bytes20\n\n    # Amount of the Tron USDT to receive.\n    outputAmount: uint256\n\n    # Deadline for the order.\n    # If the order is not filled before the deadline,\n    # the funds can be refunded to the refundBeneficiary.\n    deadline: uint256\n\n    # Address that will receive a portion of the input tokens\n    referrer: address\n\n    # How much of the input tokens will be sent to the referrer.\n    # The referrer will receive a portion of the input tokens\n    # as compensation for bringing the user (refundBeneficiary) to the platform.\n    # The referrer fee is deducted from the input amount.\n    referrerFee: uint256\n\n# Event for when an order is filled or cancelled\n# Listened to by the relayers to track orders that are no longer active\nevent OrderCleared:\n    # ID of the order that is no longer active\n    orderId: bytes32\n\n# Addresses of USDT and USDC tokens on the deployed chain.\n# They're used in compactUsdt/compactUsdc functions\n# to provide a data-saving interface for efficient swaps on the L2s.\nusdt: immutable(address)\nusdc: immutable(address)\n\n# Mapping of order IDs to orders.\n# Only contains orders that have not been filled yet.\norders: public(HashMap[bytes32, Order])\n\n# Mapping of addresses to their nonce.\n# Used to generate unique order IDs.\nnonces: public(HashMap[address, uint256])\n\n# Mapping of addresses to their referrer.\n# Used to track the referrer of the initiator.\nreferrers: public(HashMap[address, address])\n\n# System-wide referrer fee.\nreferrerFee: public(uint256)\n\n# Address of the trusted relayer.\n# Only this address can call claim() to fill orders.\n# This can be an EOA or a smart contract (e.g., a ZK proof verifier for trust-minimized relaying).\ntrustedRelayer: public(address)\n\nrecommendedFixedFee: uint256\nrecommendedPercentFee: uint256\n\n@external\ndef setReferrer(user: address, referrer: address):\n    \"\"\"\n    @notice Sets a new referrer for a user.\n    @param user The address of the user to set a referrer for.\n    @param referrer The new referrer address.\n    @dev If not specified, the owner will be used as the referrer.\n    \"\"\"\n    assert msg.sender == ownable.owner\n    self.referrers[user] = referrer\n\n@external\ndef configure(newRelayer: address, fixedFee: uint256, percentFee: uint256, referrerFee: uint256):\n    \"\"\"\n    @notice Configures contract parameters.\n    @param newRelayer The new relayer address.\n    @param fixedFee The fixed fee amount.\n    @param percentFee The percentage fee (in basis points).\n    @param referrerFee The referrer fee amount.\n    @dev This function is used to configure the contract parameters.\n         Only the current owner can call this function.\n         The newRelayer can be an EOA or a smart contract designed for trust-minimized relaying.\n    \"\"\"\n    # Verify the caller is the current owner\n    assert msg.sender == ownable.owner\n    \n    # Update the trusted relayer address\n    self.trustedRelayer = newRelayer\n    \n    # Update the recommended fees\n    self.recommendedFixedFee = fixedFee\n    self.recommendedPercentFee = percentFee\n\n    # Update the referrer fee\n    self.referrerFee = referrerFee\n\n@internal\n@view\ndef _recommendedOutputAmount(inputAmount: uint256) -> uint256:\n    \"\"\"\n    @notice Calculates the recommended output amount for a given input amount.\n    @param inputAmount The input amount.\n    @return The recommended output amount.\n    \"\"\"\n    return inputAmount * (10000 - self.recommendedPercentFee) // 10000 - self.recommendedFixedFee\n\n@external\n@view\ndef recommendedOutputAmount(inputAmount: uint256) -> uint256:\n    \"\"\"\n    @notice Calculates the recommended output amount for a given input amount.\n    @param inputAmount The input amount.\n    @return The recommended output amount.\n    \"\"\"\n    return self._recommendedOutputAmount(inputAmount)\n\n@deploy\ndef __init__(_usdt: address, _usdc: address):\n    \"\"\"\n    @notice Initializes the contract with USDT and USDC addresses and the trusted relayer.\n    @param _usdt Address of the USDT token.\n    @param _usdc Address of the USDC token.\n    \"\"\"\n    # Store the USDT token address as an immutable\n    # USDT address needs to be stored immutably to enable data-efficient compact swaps from USDT\n    usdt = _usdt\n    # Store the USDC token address as an immutable\n    # USDC address needs to be stored immutably to enable data-efficient compact swaps from USDC\n    usdc = _usdc\n    # Initialize the ownable contract\n    # This sets the initial owner to the deployer\n    ownable.__init__()\n    # Set the initial trusted relayer address\n    # A trusted relayer is the resolver of orders\n    self.trustedRelayer = ownable.owner\n@internal\ndef _orderId(creator: address, nonce: uint256) -> bytes32:\n    \"\"\"\n    @notice Generates a unique order ID for a given creator and nonce.\n    @param creator The address of the order creator.\n    @param nonce The nonce (creator's order counter) for uniqueness.\n    @return The unique order ID as a bytes32 hash.\n    \"\"\"\n    # Combine chain ID, contract address, creator address and nonce into a unique hash\n    # This prevents order ID collisions across different chains and spoke pools\n    return sha256(abi_encode(chain.id, self, creator, nonce))\n\n@external\ndef cancel(orderId: bytes32):\n    \"\"\"\n    @notice Cancels an expired order.\n    @param orderId The ID of the order to cancel.\n    @dev This function is used by the initiator of the order\n         to cancel it if it expires.\n    \"\"\"\n    # Retrieve the order from storage\n    # Need to access order details to verify cancellation conditions\n    order: Order = self.orders[orderId]\n    # Verify the order has expired\n    # Orders can only be cancelled after their deadline to prevent premature cancellations\n    assert order.deadline < block.timestamp\n    # Return the tokens to the refund beneficiary\n    # Tokens must be returned to the beneficiary when order is cancelled\n    extcall IERC20(order.token).transfer(order.refundBeneficiary, order.inputAmount)\n    # Clear the order from storage\n    # Cancelled orders must be removed to prevent double-spending\n    # and to save storage space\n    self.orders[orderId] = empty(Order)\n\n    # Log the order as cleared\n    # This is used by the relayers to track orders that are no longer active\n    log OrderCleared(orderId)\n\n@external\ndef claim(orderId: bytes32):\n    \"\"\"\n    @notice Claims funds for a filled order.\n    @param orderId The ID of the order to claim.\n    @dev This function is used by the trusted relayer.\n         The trusted relayer can be an EOA or a smart contract (e.g., a ZK proof verifier).\n    \"\"\"\n    # Verify the caller is the trusted relayer\n    # Only the trusted relayer (or a contract it controls) can claim funds for cross-chain swaps\n    assert msg.sender == self.trustedRelayer\n\n    # Retrieve the order from storage\n    # Need to access order details to process the claim\n    order: Order = self.orders[orderId]\n    # Verify the order has expired\n    # Orders can only be claimed before their deadline,\n    # otherwise they can only be refunded to the initiator\n    assert order.deadline >= block.timestamp\n    \n    # We prioritize the relayer getting the fees over the referrer\n    # If the referrer fee is greater than the input amount,\n    # we set the referrer fee to 0\n    referrerFee: uint256 = order.referrerFee\n    if referrerFee > order.inputAmount:\n        referrerFee = 0\n\n    # Transfer the tokens to the relayer\n    # Relayer receives the tokens as compensation for executing the cross-chain swap\n    extcall IERC20(order.token).transfer(msg.sender, order.inputAmount - referrerFee)\n\n    # Transfer the referrer fee to the referrer\n    extcall IERC20(order.token).transfer(order.referrer, referrerFee)\n\n    # Clear the order from storage\n    # Claimed orders must be removed to prevent double-spending\n    self.orders[orderId] = empty(Order)\n\n    # Log the order as cleared\n    # This is used by the relayers to track orders that are no longer active\n    log OrderCleared(orderId)\n\n@internal\ndef _compactSwap(token: address, swapData: bytes32) -> bytes32:\n    \"\"\"\n    @notice An internal entry-point function for \"compact\" swaps.\n    @param token The address of the token to swap.\n    @param swapData The compressed 32-byte data for the swap.\n                    It contains the input amount (6 bytes), \n                    output amount in Tron USDT (6 bytes),\n                    and the recipient Tron address (20 bytes compressed).\n                    Deadline is hardcoded to 1 day.\n                    While 6 bytes are reasonable for 6-decimal USDT,\n                    some tokens, especially 18-decimal ones,\n                    might require more bytes for the input amount.\n                    In this case, consider using intron() instead.\n    @dev This function is used by compactSwap() function.\n    \"\"\"\n    # Extract the input amount from the first 6 bytes\n    # This would only work good for token amounts which would fit into 6 bytes.\n    # This is not a problem for 6-decimal USDT, but might be for 18-decimal tokens.\n    # In this case, consider using intron() instead.\n    inputAmount: uint256 = convert(swapData, uint256) >> 208\n\n    # Extract the output amount from the next 6 bytes\n    # Output amount is in Tron USDT, so it's limited to ~281m USDT, which is reasonable\n    outputAmount: uint256 = convert(swapData, uint256) >> 160\n\n    # Extract the output amount from the other data\n    outputAmount &= convert(max_value(uint48), uint256)\n\n    # if output amount is 0, use recommended output amount\n    if outputAmount == 0:\n        outputAmount = self._recommendedOutputAmount(inputAmount)\n\n    # Extract the Tron address from the remaining 20 bytes\n    # Recipient address must be decoded from the compact format to create the order\n    to: bytes20 = convert(convert(convert(swapData, uint256) << 96, bytes32), bytes20)\n\n    # Get the referrer for the user\n    # If the user has no referrer, use the owner as the referrer\n    referrer: address = self.referrers[msg.sender]\n    if referrer == empty(address):\n        referrer = ownable.owner\n\n    # Create an order struct with a 1-day deadline\n    # It is created from the decoded compact data for data-efficient processing\n    order: Order = Order(\n        refundBeneficiary=msg.sender,\n        token=token,\n        inputAmount=inputAmount,\n        to=to,\n        outputAmount=outputAmount,\n        deadline=block.timestamp + 86400,\n        referrer=referrer,\n        referrerFee=self.referrerFee\n    )\n\n    # Transfer tokens from the sender to this contract\n    # The contract needs to hold the tokens until the cross-chain swap is completed\n    extcall IERC20(order.token).transferFrom(msg.sender, self, order.inputAmount)\n\n    # Generate a unique order ID using the order data and sender's nonce\n    # Each order needs a unique identifier for efficient tracking and claiming in the storage\n    orderId: bytes32 = self._orderId(msg.sender, self.nonces[msg.sender])\n\n    # Store the order in the orders mapping\n    # Order details must be stored to allow efficient claiming or refunding\n    self.orders[orderId] = order\n\n    # Increment the sender's nonce to prevent order ID collisions\n    # Nonce must increase to ensure each order has a unique ID\n    self.nonces[msg.sender] += 1\n\n    log OrderCreated(\n        orderId,\n        order.refundBeneficiary,\n        order.token,\n        order.inputAmount,\n        order.to,\n        order.outputAmount,\n        order.deadline,\n        order.referrer,\n        order.referrerFee)\n    \n    return orderId\n\n@external\ndef compactSwap(token: address, swapData: bytes32) -> bytes32:\n    \"\"\"\n    @notice An entry-point function for \"compact\" swaps.\n    @param token The address of the token to swap.\n    @param swapData The compressed 32-byte data for the swap.\n    @dev This function uses _compactSwap() internally.\n    \"\"\"\n    # Call the internal compact swap function with the provided token and data\n    # Provides a public interface for creating data-efficient swap orders with custom tokens\n    return self._compactSwap(token, swapData)\n\n@external\ndef compactUsdt(swapData: bytes32) -> bytes32:\n    \"\"\"\n    @notice An entry-point function for \"compact\" swaps from USDT.\n    @param swapData The compressed 32-byte data for the swap.\n    @dev This function uses _compactSwap() internally.\n    \"\"\"\n    # Call the internal compact swap function with the USDT token address\n    # Provides a data-efficient public interface specifically for USDT swaps\n    return self._compactSwap(usdt, swapData)\n\n@external\ndef compactUsdc(swapData: bytes32) -> bytes32:\n    \"\"\"\n    @notice An entry-point function for \"compact\" swaps from USDC.\n    @param swapData The compressed 32-byte data for the swap.\n    @dev This function uses _compactSwap() internally.\n    \"\"\"\n    # Call the internal compact swap function with the USDC token address\n    # Provides a data-efficient public interface specifically for USDC swaps\n    return self._compactSwap(usdc, swapData)", "sha256sum": "42fac11c2a72d4700abec8a63daf60435930898a636c9363b4d35987a1abc89a"}}, "settings": {"outputSelection": {"src/UntronTransfers.vy": ["*"]}, "search_paths": ["."]}, "compiler_version": "v0.4.0+commit.e9db8d9", "integrity": "bf07c7528c05d8705cb8603d8511d747a2dd8b9f59122acf9e9c3140dcd28fed"}
