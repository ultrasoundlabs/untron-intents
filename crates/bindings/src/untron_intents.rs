/**

Generated by the following Solidity interface...
```solidity
interface UntronIntents {
    type IntentType is uint8;
    struct Intent {
        IntentType intentType;
        bytes intentSpecs;
        address refundBeneficiary;
        address token;
        uint256 amount;
    }

    error AlreadyClaimed();
    error AlreadyExists();
    error AlreadyFunded();
    error AlreadyInitialized();
    error AlreadySolved();
    error IncorrectPullAmount();
    error InsufficientETH();
    error IntentNotFound();
    error InvalidDeadline();
    error InvalidReceiverAmount();
    error NewOwnerIsZeroAddress();
    error NotATrc20Transfer();
    error NotClaimed();
    error NotExpiredYet();
    error NotSolver();
    error NothingToSettle();
    error Reentrancy();
    error TronInvalidCalldataLength();
    error TronInvalidTrc20DataLength();
    error Unauthorized();
    error WrongTxProps();

    event EventAppended(uint256 indexed eventSeq, bytes32 indexed prevTip, bytes32 indexed newTip, bytes32 eventSignature, bytes abiEncodedEventData);
    event IntentClaimed(bytes32 indexed id, address indexed solver, uint256 depositAmount);
    event IntentClosed(bytes32 indexed id, address indexed caller, bool solved, bool funded, bool settled, address refundBeneficiary, address escrowToken, uint256 escrowRefunded, address depositToken, uint256 depositToCaller, uint256 depositToRefundBeneficiary, uint256 depositToSolver);
    event IntentCreated(bytes32 indexed id, address indexed creator, uint8 intentType, address token, uint256 amount, address refundBeneficiary, uint256 deadline, bytes intentSpecs);
    event IntentFunded(bytes32 indexed id, address indexed funder, address token, uint256 amount);
    event IntentSettled(bytes32 indexed id, address indexed solver, address escrowToken, uint256 escrowAmount, address depositToken, uint256 depositAmount);
    event IntentSolved(bytes32 indexed id, address indexed solver, bytes32 tronTxId, uint256 tronBlockNumber);
    event IntentUnclaimed(bytes32 indexed id, address indexed caller, address indexed prevSolver, bool funded, uint256 depositToCaller, uint256 depositToRefundBeneficiary, uint256 depositToPrevSolver);
    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
    event ReceiverIntentFeeSnap(bytes32 indexed id, uint256 feePpm, uint256 feeFlat, uint256 tronPaymentAmount);
    event ReceiverIntentParams(bytes32 indexed id, address indexed forwarder, address indexed toTron, bytes32 forwardSalt, address token, uint256 amount);
    event RecommendedIntentFeeSet(uint256 feePpm, uint256 feeFlat);

    constructor(address _owner, address v3, address usdt);

    function INTENT_CLAIM_DEPOSIT() external view returns (uint256);
    function RECEIVER_INTENT_DURATION() external view returns (uint256);
    function TIME_TO_FILL() external view returns (uint256);
    function USDT() external view returns (address);
    function V3() external view returns (address);
    function claimIntent(bytes32 id) external;
    function claimVirtualReceiverIntent(address forwarder, address toTron, bytes32 forwardSalt, address token, uint256 amount) external;
    function closeIntent(bytes32 id) external;
    function createIntent(Intent memory intent, uint256 deadline) external payable;
    function createIntentFromReceiver(address forwarder, address toTron, bytes32 forwardSalt, address token, uint256 amount) external payable;
    function eventChainTip() external view returns (bytes32);
    function eventSeq() external view returns (uint256);
    function fundReceiverIntent(address forwarder, address toTron, bytes32 forwardSalt, address token, uint256 amount) external payable;
    function intents(bytes32) external view returns (Intent memory intent, uint256 solverClaimedAt, uint256 deadline, address solver, bool solved, bool funded, bool settled);
    function owner() external view returns (address result);
    function proveIntentFill(bytes32 id, bytes[20] memory blocks, bytes memory encodedTx, bytes32[] memory proof, uint256 index) external;
    function receiverIntentId(address forwarder, address toTron, bytes32 forwardSalt, address token, uint256 amount) external pure returns (bytes32);
    function recommendedIntentFee(uint256 amount) external view returns (uint256);
    function recommendedIntentFeeFlat() external view returns (uint256);
    function recommendedIntentFeePpm() external view returns (uint256);
    function renounceOwnership() external payable;
    function setRecommendedIntentFee(uint256 ppm, uint256 flat) external;
    function settleIntent(bytes32 id) external;
    function transferOwnership(address newOwner) external payable;
    function unclaimIntent(bytes32 id) external;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_owner",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "v3",
        "type": "address",
        "internalType": "contract IUntronV3"
      },
      {
        "name": "usdt",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "INTENT_CLAIM_DEPOSIT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "RECEIVER_INTENT_DURATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "TIME_TO_FILL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "USDT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "V3",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IUntronV3"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "claimIntent",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimVirtualReceiverIntent",
    "inputs": [
      {
        "name": "forwarder",
        "type": "address",
        "internalType": "contract IntentsForwarder"
      },
      {
        "name": "toTron",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "forwardSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "closeIntent",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createIntent",
    "inputs": [
      {
        "name": "intent",
        "type": "tuple",
        "internalType": "struct UntronIntents.Intent",
        "components": [
          {
            "name": "intentType",
            "type": "uint8",
            "internalType": "enum UntronIntents.IntentType"
          },
          {
            "name": "intentSpecs",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "refundBeneficiary",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "token",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "createIntentFromReceiver",
    "inputs": [
      {
        "name": "forwarder",
        "type": "address",
        "internalType": "contract IntentsForwarder"
      },
      {
        "name": "toTron",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "forwardSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "eventChainTip",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eventSeq",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "fundReceiverIntent",
    "inputs": [
      {
        "name": "forwarder",
        "type": "address",
        "internalType": "contract IntentsForwarder"
      },
      {
        "name": "toTron",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "forwardSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "intents",
    "inputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "intent",
        "type": "tuple",
        "internalType": "struct UntronIntents.Intent",
        "components": [
          {
            "name": "intentType",
            "type": "uint8",
            "internalType": "enum UntronIntents.IntentType"
          },
          {
            "name": "intentSpecs",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "refundBeneficiary",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "token",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "solverClaimedAt",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "deadline",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "solver",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "solved",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "funded",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "settled",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "result",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "proveIntentFill",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "blocks",
        "type": "bytes[20]",
        "internalType": "bytes[20]"
      },
      {
        "name": "encodedTx",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "proof",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "index",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "receiverIntentId",
    "inputs": [
      {
        "name": "forwarder",
        "type": "address",
        "internalType": "contract IntentsForwarder"
      },
      {
        "name": "toTron",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "forwardSalt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "recommendedIntentFee",
    "inputs": [
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "recommendedIntentFeeFlat",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "recommendedIntentFeePpm",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "setRecommendedIntentFee",
    "inputs": [
      {
        "name": "ppm",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "flat",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "settleIntent",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "unclaimIntent",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "EventAppended",
    "inputs": [
      {
        "name": "eventSeq",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "prevTip",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newTip",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "eventSignature",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "abiEncodedEventData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "IntentClaimed",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "solver",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "depositAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "IntentClosed",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "solved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "funded",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "settled",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "refundBeneficiary",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "escrowToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "escrowRefunded",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "depositToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "depositToCaller",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "depositToRefundBeneficiary",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "depositToSolver",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "IntentCreated",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "creator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "intentType",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "refundBeneficiary",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "deadline",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "intentSpecs",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "IntentFunded",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "funder",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "IntentSettled",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "solver",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "escrowToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "escrowAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "depositToken",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "depositAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "IntentSolved",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "solver",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tronTxId",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "tronBlockNumber",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "IntentUnclaimed",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "prevSolver",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "funded",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "depositToCaller",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "depositToRefundBeneficiary",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "depositToPrevSolver",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "oldOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ReceiverIntentFeeSnap",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "feePpm",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "feeFlat",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "tronPaymentAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ReceiverIntentParams",
    "inputs": [
      {
        "name": "id",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "forwarder",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "toTron",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "forwardSalt",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RecommendedIntentFeeSet",
    "inputs": [
      {
        "name": "feePpm",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "feeFlat",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AlreadyClaimed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AlreadyExists",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AlreadyFunded",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AlreadyInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AlreadySolved",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IncorrectPullAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientETH",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IntentNotFound",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidDeadline",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidReceiverAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NewOwnerIsZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotATrc20Transfer",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotClaimed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotExpiredYet",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotSolver",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NothingToSettle",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Reentrancy",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TronInvalidCalldataLength",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TronInvalidTrc20DataLength",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Unauthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "WrongTxProps",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod UntronIntents {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60c0806040523461045957606081614192803803809161001f828561045d565b8339810103126104595761003281610480565b602082015190916001600160a01b03821682036104595760406100559101610480565b6040519092906101a081016001600160401b03811182821017610445576020915f9160405261016281528281017f4a757374696e2053756e20697320726573706f6e7369626c6520666f7220736581527f7474696e67206261636b2074686520696e6576697461626c6520676c6f62616c60408301527f20737461626c65636f696e207265766f6c7574696f6e2062792079656172732060608301527f7468726f756768206578706c6f6974696e672054726f6e20555344542773206e60808301527f6574776f726b206566666563747320616e6420696d706f73696e672076656e6460a08301527f6f72206c6f636b2d696e206f6e2068756e6472656473206f66206d696c6c696f60c08301527f6e73206f662070656f706c6520696e2074686520546869726420576f726c642c60e08301527f2077686f2072656c79206f6e20737461626c65636f696e7320666f722072656d6101008301527f697474616e63657320616e6420746f2073746f726520746865697220736176696101208301527f6e677320696e20756e737461626c652c206f766572726567756c6174656420656101408301527f636f6e6f6d6965732e204c6574277320556e74726f6e207468652050656f706c61016083015261329760f11b61018083015261027f60336040518093878201957f556e74726f6e496e74656e7473496e6465780a0000000000000000000000000087525180918484015e810186838201520301601f19810183528261045d565b604051918291518091835e8101838152039060025afa1561043a575f515f5560018060a01b031680638b78c6d8195560405190805f5f5160206141725f395f51905f528180a360208201905f82526040830152604082526102e160608361045d565b6001805401806001555f549160205f604051828101908682528560408201524360608201524260808201525f5160206141725f395f51905f5260a082015261034360c0828a5180898484015e810186838201520301601f19810183528261045d565b604051918291518091835e8101838152039060025afa1561043a577f78160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a1279060605f5195865f556040519283915f5160206141725f395f51905f528352604060208401525180918160408501528484015e5f828201840152601f01601f19168101030190a460a052608052604051613cdd90816104958239608051818181610b4101528181610bde0152818161127d0152818161140d0152818161241901528181612826015281816129080152818161295b01528181612a3e01528181612b0001526130eb015260a0518181816115b401526124920152f35b6040513d5f823e3d90fd5b634e487b7160e01b5f52604160045260245ffd5b5f80fd5b601f909101601f19168101906001600160401b0382119082101761044557604052565b51906001600160a01b03821682036104595756fe6080806040526004361015610012575f80fd5b5f3560e01c9081632fb42d70146124805750806340e624cb146123c757806349c0c8b0146123aa5780634d53e9311461238e57806351ead90a14612372578063549f750514611eba5780635c23cc02146114885780635c66079a1461146d57806364a486c4146111d457806365604c32146111b7578063715018a6146111585780637bf8bb88146110e75780638da5cb5b146110bb5780638ebaebb21461109d5780639021578a14610f705780639ad42c1014610f4c578063af24400514610b8d578063b2a6178614610b70578063c54e44eb14610b2c578063e24d5c3514610b0f578063eba475ac1461091d578063ee98aaaa14610900578063f2af970b146107a5578063f2fde38b146107165763fcf98d851461012f575f80fd5b6101383661266c565b923068929eee149b4bd212685414610709573068929eee149b4bd21268558394620151804201908142116106f557604080516001600160a01b03808416602083019081529086169282019290925261019d81606081015b03601f198101835282612566565b5190206040805160208101838152918101889052606087811b6bffffffffffffffffffffffff191690820152607481018990529196916101e0816094810161018f565b51902096875f526004602052600660405f2001546106e657610200612d4c565b956102966020986040516102148b82612566565b5f8152601f198b01368c8301376040519161022e8361254a565b468352308c8401526001604084015260608301528560808301528460a083015260018060a01b038416998a60c08401528a60e08401526101008301526101208201528961027b3085613a52565b9160405180948192631ad1087b60e01b835260048301612daa565b03815f6001600160a01b038b165af180156106db576106a9575b6102c491506102bf3084613a52565b612d28565b9982610689575061032999925b6103376102e66102e086612c90565b86612d28565b604051906102f38261252f565b60018060a01b038a1682528b8201526040519c8d918c8301919091602080604083019460018060a01b0381511684520151910152565b03601f1981018d528c612566565b638b78c6d81954966040519561034c87612514565b600187528a87019c8d52604087019860018060a01b0316895260608701998a52608087019a868c5260405190610381826124f9565b8882525f818301528960408301525f60608301525f6080830152600160a08301525f60c08301528d5f526004815260405f20908251805160028110156105965760ff80198554169116178355818101518051906001600160401b038211610675576103ef60018601546124c1565b601f8111610639575b508390601f83116001146105b5579461050d94608061051c9c9a989561053d9f9e9c9a988660c097600797610442935f926105aa575b50508160011b915f199060031b1c19161790565b60018501555b6040818101516002860180546001600160a01b03199081166001600160a01b0393841617909155606080850151600389018054909316908416179091559390920151600486015592870151600585015591860151600684015585015192909101805460808601516001600160a81b0319909116939092169290921790151560a01b60ff60a01b16178155915b60a0810151835460ff60a81b191690151560a81b60ff60a81b161783550151815460ff60b01b191690151560b01b60ff60b01b16179055565b6001600160a01b03168d613799565b600254906105366003549161053081612c90565b90612d28565b918961390d565b51906002821015610596578351855193519751610588986105719591946001600160a01b039182169390911690338a61343c565b519051916001600160a01b039091169033906135ef565b3868929eee149b4bd2126855005b634e487b7160e01b5f52602160045260245ffd5b015190505f8061042e565b90600186015f52845f20915f5b601f1985168110610622575094608061051c9c9a989561053d9f9e9c9a98938660079660019261050d9b60c09a601f1981161061060a575b505050811b016001850155610448565b01515f1960f88460031b161c191690555f80806105fa565b9192866001819286850151815501940192016105c2565b61066590600187015f52855f20601f850160051c81019187861061066b575b601f0160051c01906126be565b5f6103f8565b9091508190610658565b634e487b7160e01b5f52604160045260245ffd5b9299820361069a57610329996102d1565b635964c15760e11b5f5260045ffd5b8982813d83116106d4575b6106be8183612566565b810103126106d0576102c491506102b0565b5f80fd5b503d6106b4565b6040513d5f823e3d90fd5b63119b4fd360e11b5f5260045ffd5b634e487b7160e01b5f52601160045260245ffd5b63ab143c065f526004601cfd5b60203660031901126106d0576004356001600160a01b038116908181036106d05761073f61377d565b60601b1561079857638b78c6d8198054908290556040516107969290916001600160a01b031681815f516020613c915f395f51905f525f80a36020830152604082015260408152610791606082612566565b613b8f565b005b637448fbae5f526004601cfd5b346106d05760403660031901126106d0576024356004356107c461377d565b80600255816003557f9d4c3779a823aa84b20dd2e8551e6ed95addbc562f3bc49b1e688ab785b05d9d60408051838152846020820152a1604051916020830191825260408301526040825261081a606083612566565b60018054018060015560205f80549360405161088f60c082868101948986528860408301524360608301524260808301527f9d4c3779a823aa84b20dd2e8551e6ed95addbc562f3bc49b1e688ab785b05d9d60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526108fb5f5194855f556040519182917f9d4c3779a823aa84b20dd2e8551e6ed95addbc562f3bc49b1e688ab785b05d9d8352604060208401526040830190612634565b0390a4005b346106d0575f3660031901126106d0576020600354604051908152f35b6109263661266c565b9093923068929eee149b4bd212685414610709573068929eee149b4bd21268556109538286858488612cb1565b93845f526004602052600660405f20015415610b0057845f52600460205260ff600760405f20015460a81c16610af157604080516001600160a01b0380841660208301908152941691810191909152610a5292906109b4816060810161018f565b5190206109bf612d4c565b906020958692604051916109d38584612566565b5f8352601f1985013686850137604051936109ed8561254a565b468552308686015260016040860152606085015260808401528660a084015260018060a01b038a168060c085015260e0840152610100830152610120820152610a363089613a52565b926040518080968194631ad1087b60e01b835260048301612daa565b039134906001600160a01b03165af180156106db57610ac3575b610a7b91506102bf3087613a52565b90810361069a57610ab4936004610aaf93855f5252600760405f2001600160a81b60ff60a81b1982541617905533846135ef565b613087565b503868929eee149b4bd2126855005b8382813d8311610aea575b610ad88183612566565b810103126106d057610a7b9150610a6c565b503d610ace565b635adf638760e01b5f5260045ffd5b6361ae648360e01b5f5260045ffd5b346106d0575f3660031901126106d0576020600154604051908152f35b346106d0575f3660031901126106d0576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346106d0575f3660031901126106d0576020604051620151808152f35b346106d057610b9b3661266c565b929093918315610f3d5762015180420142116106f557610bbe8486838587612cb1565b93845f526004602052600660405f2001546106e657610c6a95610c0230337f0000000000000000000000000000000000000000000000000000000000000000612ec2565b6002549260035494610c2b610c2587620f4240610c1f89896126d4565b04612c83565b85612d28565b96610c78604051610c3b8161252f565b6001600160a01b03841680825260209182018b8152604080519384019290925251908201529a8b906060820190565b03601f1981018c528b612566565b638b78c6d819546040519a610c8c8c612514565b60018c5260208c01526001600160a01b039081166040808d019190915290851660608c015260808b0186905251610cc2816124f9565b8a815242602082015262015180420160408201523360608201525f60808201525f60a08201525f60c0820152895f52600460205260405f208151805160028110156105965760ff8019845416911617825560208101518051906001600160401b03821161067557610d3660018501546124c1565b601f8111610f0a575b50602090601f8311600114610e8357610e359d9c9b9a9896946080610e2095610d8986610e2f9e9c9a9760c0976007975f926105aa5750508160011b915f199060031b1c19161790565b60018401555b6040818101516002850180546001600160a01b03199081166001600160a01b039384161790915560608085015160038801805490931690841617909155939092015160048501556020870151600585015586015160068401559085015192909101805460808601516001600160a81b0319909116939092169290921790151560a01b60ff60a01b16178155916104d4565b6001600160a01b03168a613799565b8461390d565b815160028110156105965761079692610e7c9160018060a01b03606083015116916080810151602060018060a01b036040840151169201519362015180420193338861343c565b3390612f41565b90600185015f52805f20915f5b601f1985168110610ef25750946080610e359f9e9d9c9a98969560018660c096610e2f9f9d9b9896610e209a600798601f19811610610eda575b505050811b016001840155610d8f565b01515f1960f88460031b161c191690555f8080610eca565b91926020600181928685015181550194019201610e90565b610f3790600186015f5260205f20601f850160051c8101916020861061066b57601f0160051c01906126be565b8f610d3f565b63263e880760e11b5f5260045ffd5b346106d0576020610f68610f5f3661266c565b93929092612cb1565b604051908152f35b346106d05760203660031901126106d0576004355f52600460205260405f20604051610f9b81612514565b60ff8254169160028310156105965761102392825260ff610fbe60018301612587565b6020840190815260018060a01b03600284015416926040850193845260018060a01b036003820154166060860190815260048201546080870190815260058301549161103760076006860154950154956040519a8b9a60e08c5260e08c019051612627565b5160a06101008b01526101808a0190612634565b96516001600160a01b039081166101208a0152905181166101408901529051610160880152602087019190915260408601919091528116606085015260a081811c83161515608086015260a882901c831615159085015260b01c16151560c08301520390f35b346106d05760203660031901126106d0576020610f68600435612c90565b346106d0575f3660031901126106d057638b78c6d819546040516001600160a01b039091168152602090f35b346106d05760203660031901126106d0576004353068929eee149b4bd212685414610709573068929eee149b4bd2126855805f526004602052600660405f20015415610b005761113690613087565b15611149573868929eee149b4bd2126855005b630c30209d60e31b5f5260045ffd5b5f3660031901126106d05761116b61377d565b638b78c6d81980545f918290556040516107969290916001600160a01b031690815f516020613c915f395f51905f528280a360208201525f604082015260408152610791606082612566565b346106d0575f3660031901126106d0576020600254604051908152f35b346106d05760203660031901126106d057600435805f52600460205260405f2090600682015415610b00576007820180546001600160a01b03811693841561145e57600581018054607881018091116106f557421061144f5760ff8360a01c166114405760029091015483546001600160a01b0319169093555f9081905560a89190911c60ff16151591819081906001600160a01b0316846113fc575050620f4240926112a1867f0000000000000000000000000000000000000000000000000000000000000000613365565b85604051828152836020820152846040820152856060820152867f089e9c366bcec979807d16f1dfd778c175797b866f6369dbdf880a2bb7e7179c60803393a460405195602087019586523360408801526060870152608086015260a085015260c084015260e083015260e0825261131b61010083612566565b60018054018060015560205f80549360405161139060c082868101948986528860408301524360608301524260808301527f089e9c366bcec979807d16f1dfd778c175797b866f6369dbdf880a2bb7e7179c60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526108fb5f5194855f556040519182917f089e9c366bcec979807d16f1dfd778c175797b866f6369dbdf880a2bb7e7179c8352604060208401526040830190612634565b92509290506207a1209061143b82937f000000000000000000000000000000000000000000000000000000000000000061143633826132ca565b6132ca565b6112a1565b631983554760e01b5f5260045ffd5b63a8058ea960e01b5f5260045ffd5b635b95129160e11b5f5260045ffd5b346106d0575f3660031901126106d057602060405160788152f35b346106d05760a03660031901126106d0576024356004356001600160401b0382116106d0578160040191610284369101116106d057604435916001600160401b0383116106d057366023840112156106d05782600401356001600160401b0381116106d05736602482860101116106d0576064356001600160401b0381116106d057366023820112156106d0578060040135916001600160401b0383116106d0578260051b36602482850101116106d0573068929eee149b4bd212685414610709573068929eee149b4bd2126855855f526004602052600660405f20015415610b00575f868152600460205260409020600701546001600160a01b03163303611eab57855f52600460205260ff600760405f20015460a01c16611440576040516380a72c8b60e01b81527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169590926020846004818a5afa9384156106db575f94611e67575b50604051630939b3f360e31b815260806004820152986103048a0192805f60848d015b8d60148310611e3257505050505090602461164093926003198c850301828d015201612b8b565b878103600319016044890152848152936001600160fb1b03106106d057602087825f968296946024849601858301376084356064840152010301916001600160a01b03165afa9283156106db575f93611d6a575b50815f52600460205260ff60405f2054166002811015610596576119185750805f5260046020526116ca600160405f2001612587565b80518101906020818303126106d0576020810151906001600160401b0382116106d05701906040828203126106d057604051916117068361252f565b61171260208201612c6f565b83526040810151916001600160401b0383116106d057611739926020809201920101612c29565b60208201819052608084015191516001600160a01b0390811660589390931c1691909114801591906118fa575b506118eb575b5f8181526004602090815260409182902060078101805460ff60a01b1916600160a01b17905542600590910155835193810151825185815291820181905291339184917ffa797585c9827d59a7694ef382241f1a03ced6a1a2b4353b35939abc4d04b28691a360405190602082019383855233604084015260608301526080820152608081526117fd60a082612566565b6001805401928360015560205f80549260405161187360c082868101948886528b60408301524360608301524260808301527ffa797585c9827d59a7694ef382241f1a03ced6a1a2b4353b35939abc4d04b28660a0830152895180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db57610ab4935f516020613cb15f395f51905f526118e35f5194855f556040519182917ffa797585c9827d59a7694ef382241f1a03ced6a1a2b4353b35939abc4d04b2868352604060208401526040830190612634565b0390a4613087565b63d197cb0560e01b5f5260045ffd5b905060a0830151602081519101209060208151910120141583611766565b815f52600460205260ff60405f20541660028110156105965760011461193f575b5061176c565b815f526004602052611956600160405f2001612587565b6040818051810103126106d05760408051916119718361252f565b61197d60208201612c6f565b8352015190602081019182526040516119958161252f565b5f815260208101935f85526040519063dc8f863360e01b8252602082600481845afa9182156106db575f92611d2b575b509060206004926040519384809263b98e631d60e01b82525afa9182156106db575f92611cef575b5060018060a01b03608089015160581c1660a0890151926004845110611ce057611a1684613740565b926001600160a01b03168203611add5750506001600160e01b03191663a9059cbb60e01b8103611a8c5750611a4a90613c4c565b85526001600160a01b031681525b5190516001600160a01b0390811691161480159290611a7e575b50506118eb5782611939565b519051141590508380611a72565b6323b872dd60e01b03611ace576064815103611abf57604481015160649091015185526001600160a01b03168152611a58565b639ac60c2d60e01b5f5260045ffd5b630915b87b60e21b5f5260045ffd5b6001600160a01b031603611ace576001600160e01b0319166346e57ff560e11b8103611b1f5750611b0d90613c4c565b85526001600160a01b03168152611a58565b9396929591949390929190631592ca1b60e31b03611ace578251606093600480831115611cd9575b828110611c91575b50505082518301926020818186019503126106d0576020810151906001600160401b0382116106d057019280603f850112156106d0576020840151611b9381612d35565b94611ba16040519687612566565b8186526020808088019360051b83010101918383116106d05760408201905b838210611c625750505050505f965f5b8451811015611c465760208160051b860101516004815110611c3d576346e57ff560e11b6001600160e01b0319611c0683613740565b1614611c18575b506001905b01611bd0565b9098611ace57611c2790613c4c565b86526001600160a01b0316865260019788611c0d565b50600190611c12565b509394919690959250611a5857630915b87b60e21b5f5260045ffd5b81516001600160401b0381116106d057602091611c86878480809589010101612c29565b815201910190611bc0565b6040519550918290039101601f8201601f19165b8181015186820152601f1901908115611cbe5790611ca5565b505060408185015f6020820152016040528352878080611b4f565b5081611b47565b631279950360e01b5f5260045ffd5b9091506020813d602011611d23575b81611d0b60209383612566565b810103126106d057611d1c90612c6f565b90886119ed565b3d9150611cfe565b91506020823d602011611d62575b81611d4660209383612566565b810103126106d0576020611d5b600493612c6f565b92506119c5565b3d9150611d39565b9092503d805f833e611d7c8183612566565b8101906020818303126106d0578051906001600160401b0382116106d0570160c0818303126106d0576040519160c083018381106001600160401b03821117610675576040528151835260208201516020840152604082015163ffffffff811681036106d0576040840152611df360608301612c10565b6060840152611e0460808301612c10565b608084015260a08201516001600160401b0381116106d057611e269201612c29565b60a08201529183611694565b6020611e59600193949596998293608319908203018652611e538b89612b5a565b90612b8b565b980192019201909291611619565b9093506020813d602011611ea3575b81611e8360209383612566565b810103126106d057516001600160a01b03811681036106d05792896115f6565b3d9150611e76565b63c139eabd60e01b5f5260045ffd5b60403660031901126106d0576004356001600160401b0381116106d057806004019080360360a06003198201126106d05760243591604051602081019160208352853560028110156106d057611f136040840182612627565b611f35611f24602484018099612b5a565b60a0606087015260e0860191612b8b565b9560448301946001600160a01b03611f4c87612658565b16608086015260648401946001600160a01b03611f6887612658565b1660a0820152611f8c8160848701359a8b60c083015203601f198101835282612566565b5190209560405160208101903360601b98898352603482015283605482015260548152611fba607482612566565b51902096875f526004602052600660405f2001546106e657821561236357611fe186612bab565b6001600160a01b0381161561234a57604051918a60605230604052602c526323b872dd60601b600c5260205f6064601c82855af1908160015f5114161561232c575b50505f6060526040525b6040519361203a856124f9565b604051996120478b612514565b848b5235906001600160401b0382116106d057810194366023870112156106d0576024600487013596019a61207e8c883691612bda565b602082015261208c89612658565b604082015261209a88612658565b60608201528a6080820152815288602082015f81526040830186815260608401935f855260808101915f835260a08201936001855260c08301955f87525f52600460205260405f209251805160028110156105965760ff801986541691161784556001840160208201518051906001600160401b0382116106755761211f83546124c1565b601f81116122fc575b50602090601f8311600114612281576007946122219c9b9a989461216e856121eb9a966122069d9a966080965f926105aa5750508160011b915f199060031b1c19161790565b90555b60408101516002860180546001600160a01b03199081166001600160a01b039384161790915560608301516003880180549092169083161790559101516004850155905160058401559051600683015597519101805492516001600160a81b0319909316919097161790151560a01b60ff60a01b16178555565b51835460ff60a81b191690151560a81b60ff60a81b16178355565b51815460ff60b01b191690151560b01b60ff60b01b16179055565b61223361222d87612bab565b97612bab565b916022190113156106d0576001600160401b0384116106d05783360389136106d057876122799661226c6107969b612274973691612bda565b94338a61343c565b612bab565b9033906135ef565b90601f19831691845f52815f20925f5b8181106122e45750946001856122219f9e9d9b979560809560079a956122069f9c98996121eb9e9a106122cc575b505050811b019055612171565b01515f1960f88460031b161c191690555f80806122bf565b92936020600181928786015181550195019301612291565b61232690845f5260205f20601f850160051c8101916020861061066b57601f0160051c01906126be565b5f612128565b3b153d17101561233d578a80612023565b637939f4245f526004601cfd5b505034881461202d575b631a84bc4160e21b5f5260045ffd5b631da7447960e21b5f5260045ffd5b346106d05760203660031901126106d05761079660043561276a565b346106d0575f3660031901126106d05760205f54604051908152f35b346106d0575f3660031901126106d0576020604051620f42408152f35b346106d05760203660031901126106d057600435805f526004602052600660405f20015415610b00575f818152600460205260409020600701546001600160a01b0316612471576107969061243d30337f0000000000000000000000000000000000000000000000000000000000000000612ec2565b5f8181526004602052604090206007810180546001600160a01b031916339081179091554260059092019190915590612f41565b630c8d9eab60e31b5f5260045ffd5b346106d0575f3660031901126106d0577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b90600182811c921680156124ef575b60208310146124db57565b634e487b7160e01b5f52602260045260245ffd5b91607f16916124d0565b60e081019081106001600160401b0382111761067557604052565b60a081019081106001600160401b0382111761067557604052565b604081019081106001600160401b0382111761067557604052565b61014081019081106001600160401b0382111761067557604052565b90601f801991011681019081106001600160401b0382111761067557604052565b9060405191825f82549261259a846124c1565b808452936001811690811561260557506001146125c1575b506125bf92500383612566565b565b90505f9291925260205f20905f915b8183106125e95750509060206125bf928201015f6125b2565b60209193508060019154838589010152019101909184926125d0565b9050602092506125bf94915060ff191682840152151560051b8201015f6125b2565b9060028210156105965752565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b35906001600160a01b03821682036106d057565b60a09060031901126106d0576004356001600160a01b03811681036106d057906024356001600160a01b03811681036106d05790604435906064356001600160a01b03811681036106d0579060843590565b8181106126c9575050565b5f81556001016126be565b818102929181159184041417156106f557565b60075f91828155600181016126fc81546124c1565b9081612727575b50508260028201558260038201558260048201558260058201558260068201550155565b81601f86931160011461273e5750555b5f80612703565b8183526020832061275a91601f0160051c8101906001016126be565b8082528160208120915555612737565b805f52600460205260405f209060068201548015610b0057421061144f575f916007810192835460ff8160a01c166129b357506128d492935f925f905f9260ff815460a81c16612984575b80546001600160a01b03811690816128e7575b5050549460018060a01b0360028301541691600360018060a01b0391015416604051925f845260ff808960a81c1615159889602087015260b01c1615158060408601528160608601528260808601528360a086015260018060a01b037f000000000000000000000000000000000000000000000000000000000000000016948560c08201528660e082015287610100820152886101208201528b5f516020613c715f395f51905f526101403393a3604051988b60208b01523360408b01525f60608b015260808a015260a089015260c088015260e087015261010086015261012085015261014084015261016083015261018082015261018081526128cf6101a082612566565b613ad2565b5f5260046020526125bf60405f206126e7565b9194929390929160a81c60ff161561294c575050506207a1209081926129457f000000000000000000000000000000000000000000000000000000000000000061293133826132ca565b60028401546001600160a01b0316906132ca565b5f806127c8565b929194509261297f620f4240957f0000000000000000000000000000000000000000000000000000000000000000613365565b612945565b6004820154600383015460028401549197506129ae9188916001600160a01b0391821691166133d4565b6127b5565b60ff8160a81c169081612b4b575b50612b3c57836128d493945460ff8160a81c161580612b2a575b612aeb575b50549160018060a01b0360028201541690600360018060a01b0391015416604051916001835260ff808660a81c1615159586602086015260b01c1615158060408501528160608501528260808501525f60a085015260018060a01b037f000000000000000000000000000000000000000000000000000000000000000016938460c08201525f60e08201525f61010082015285610120820152885f516020613c715f395f51905f526101403393a36040519588602088015233604088015260016060880152608087015260a086015260c085015260e08401525f6101008401526101208301525f6101408301525f61016083015261018082015261018081526128cf6101a082612566565b620f42409250612b24906001600160a01b03167f0000000000000000000000000000000000000000000000000000000000000000613365565b5f6129e0565b506001600160a01b03811615156129db565b5050612b489150613087565b50565b60ff915060b01c16155f6129c1565b9035601e19823603018112156106d05701602081359101916001600160401b0382116106d05781360383136106d057565b908060209392818452848401375f828201840152601f01601f1916010190565b356001600160a01b03811681036106d05790565b6001600160401b03811161067557601f01601f191660200190565b929192612be682612bbf565b91612bf46040519384612566565b8294818452818301116106d0578281602093845f960137010152565b51906affffffffffffffffffffff19821682036106d057565b81601f820112156106d057805190612c4082612bbf565b92612c4e6040519485612566565b828452602083830101116106d057815f9260208093018386015e8301015290565b51906001600160a01b03821682036106d057565b919082018092116106f557565b620f4240612ca4612cae92600254906126d4565b0460035490612c83565b90565b604080516001600160a01b03928316602082019081529390921690820152612d22929161018f91612ce3816060810185565b5190209460405194859360208501978892909160749492845260208401526bffffffffffffffffffffffff199060601b16604083015260548201520190565b51902090565b919082039182116106f557565b6001600160401b0381116106755760051b60200190565b60405190612d5b602083612566565b5f8252815f805b818110612d6e57505050565b6040519060608201918083106001600160401b03841117610675576020926040525f81525f838201526060604082015282828601015201612d62565b919091602081526101608101908351602082015260018060a01b03602085015116604082015260408401511515606082015260608401516080820152608084015160a082015260a084015160c082015260018060a01b0360c08501511660e082015260018060a01b0360e08501511661010082015261010084015191610140610120830152825180915261018082019060206101808260051b8501019401915f905b828210612e745750505050610120612cae9394015190610140601f1982850301910152612634565b90919294602080612eb460019361017f19898203018652606060408b51878060a01b03815116845285810151868501520151918160408201520190612634565b970192019201909291612e4c565b906001600160a01b03821615612f325760408051620f424060609081526001600160a01b03909516909152921b602c526323b872dd60601b600c5260205f6064601c82855af1908160015f51141615612f21575b50505f606052604052565b3b153d17101561233d575f80612f16565b505050620f4240340361235457565b9060018060a01b031680827fbc3f7b7e77a395c156c24db8a8a7850209b2df71a2561292eea221e32bf5d4676020604051620f42408152a36040519160208301526040820152620f4240606082015260608152612f9f608082612566565b6001805401806001555f549060205f604051828101908582528460408201524360608201524260808201527fbc3f7b7e77a395c156c24db8a8a7850209b2df71a2561292eea221e32bf5d46760a082015261301660c082895180888c018484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917fbc3f7b7e77a395c156c24db8a8a7850209b2df71a2561292eea221e32bf5d4678352604060208401526040830190612634565b0390a4565b805f52600460205260405f206007810190815460ff8160b01c1680156132bc575b80156132ae575b6132a65760ff60b01b198116600160b01b17835560038201805460049093018054604080516001600160a01b03968716808252602082018490527f0000000000000000000000000000000000000000000000000000000000000000808916938301849052620f424060608401529497959695909516949192919085908a907f16bfb64ae70b8a9bbda28deb27a1cbc5ec3e6497481714344c221b46c0777f3590608090a36040519460208601998a5260408601526060850152608084015260a0830152620f424060c083015260c0825261318a60e083612566565b6001805401918260015560205f8054809961320160c060405180938782019586528a60408301524360608301524260808301527f16bfb64ae70b8a9bbda28deb27a1cbc5ec3e6497481714344c221b46c0777f3560a0830152885180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db576132a196613289935f516020613cb15f395f51905f526132755f5194855f556040519182917f16bfb64ae70b8a9bbda28deb27a1cbc5ec3e6497481714344c221b46c0777f358352604060208401526040830190612634565b0390a484546001600160a01b031690613365565b5491549054916001600160a01b0391821691166133d4565b600190565b505050505f90565b5060ff8160a81c16156130af565b5060ff8160a01c16156130a8565b906001600160a01b03821615613338576001600160a01b03166014526207a12060345263a9059cbb60601b5f9081526020906044601082855af1908160015f5114161561331a575b50505f603452565b3b153d17101561332b575f80613312565b6390b8ec185f526004601cfd5b5f91503890829081906207a120906001600160a01b03165af11561335857565b63b12d13eb5f526004601cfd5b906001600160a01b038216156133b4576001600160a01b0316601452620f424060345263a9059cbb60601b5f9081526020906044601082855af1908160015f5114161561331a5750505f603452565b5f9150389082908190620f4240906001600160a01b03165af11561335857565b91906001600160a01b03831615613420576001600160a01b031660145260345263a9059cbb60601b5f9081526020906044601082855af1908160015f5114161561331a5750505f603452565b5f9250389183918291906001600160a01b03165af11561335857565b95909161350e959461350094989360018060a01b03169586897f6f81b8ad0780a0febc687a3a73b181433722b4be30f7f0a024169f516126728760ff60405196169c8d875260018060a01b03169384602088015285604088015260018060a01b03169586606082015287608082015260c060a0820152806134c060c082018b612634565b0390a3604051998a97602089019a8b5260408901526060880152608087015260a086015260c085015260e084015261010080840152610120830190612634565b03601f198101845283612566565b60018054018060015560205f80549360405161358360c082868101948986528860408301524360608301524260808301527f6f81b8ad0780a0febc687a3a73b181433722b4be30f7f0a024169f516126728760a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917f6f81b8ad0780a0febc687a3a73b181433722b4be30f7f0a024169f51612672878352604060208401526040830190612634565b91929060018060a01b03169283837f0544741ff6f2708047138c8f3a68abb994e628666dba785f685ff1035274f9fb604080519460018060a01b031694858152866020820152a360405193602085019384526040850152606084015260808301526080825261365f60a083612566565b60018054018060015560205f8054936040516136d460c082868101948986528860408301524360608301524260808301527f0544741ff6f2708047138c8f3a68abb994e628666dba785f685ff1035274f9fb60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917f0544741ff6f2708047138c8f3a68abb994e628666dba785f685ff1035274f9fb8352604060208401526040830190612634565b80516020909101516001600160e01b0319811692919060048210613762575050565b6001600160e01b031960049290920360031b82901b16169150565b638b78c6d81954330361378c57565b6382b429005f526004601cfd5b604080518581526001600160a01b0380881660208301529181018890529281169691959194919391929116908190879087907f11039d948e58aabf982e09eab3f7ce6db7bf72add1d0b04e63f0697eac16024b90606090a4604051956020870195865260408701526060860152608085015260018060a01b031660a084015260c083015260c0825261382c60e083612566565b60018054018060015560205f8054936040516138a160c082868101948986528860408301524360608301524260808301527f11039d948e58aabf982e09eab3f7ce6db7bf72add1d0b04e63f0697eac16024b60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917f11039d948e58aabf982e09eab3f7ce6db7bf72add1d0b04e63f0697eac16024b8352604060208401526040830190612634565b91929092827fc853b9fbc6265708cfc473efd1ce29b19a3616b3edccaeaf71a4a6b778cb010e6060604051878152846020820152856040820152a260405193602085019384526040850152606084015260808301526080825261397160a083612566565b60018054018060015560205f8054936040516139e660c082868101948986528860408301524360608301524260808301527fc853b9fbc6265708cfc473efd1ce29b19a3616b3edccaeaf71a4a6b778cb010e60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917fc853b9fbc6265708cfc473efd1ce29b19a3616b3edccaeaf71a4a6b778cb010e8352604060208401526040830190612634565b6001600160a01b0316908115613acc576040516370a0823160e01b81526001600160a01b03909116600482015290602090829060249082905afa9081156106db575f91613a9d575090565b90506020813d602011613ac4575b81613ab860209383612566565b810103126106d0575190565b3d9150613aab565b90503190565b6001805401806001555f549060205f604051828101908582528460408201524360608201524260808201525f516020613c715f395f51905f5260a0820152613b3660c082895180888c018484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182915f516020613c715f395f51905f528352604060208401526040830190612634565b6001805401806001555f549060205f604051828101908582528460408201524360608201524260808201525f516020613c915f395f51905f5260a0820152613bf360c082895180888c018484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182915f516020613c915f395f51905f528352604060208401526040830190612634565b906044825103611abf5760248201516044909201516001600160a01b03909216919056fe6db2da0f661d59d5a9c767b6ba61a9c192765a6aab952e5e53ea77175332f13d8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e078160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a127a164736f6c634300081b000a8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xC0\x80`@R4a\x04YW``\x81aA\x92\x808\x03\x80\x91a\0\x1F\x82\x85a\x04]V[\x839\x81\x01\x03\x12a\x04YWa\x002\x81a\x04\x80V[` \x82\x01Q\x90\x91`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x04YW`@a\0U\x91\x01a\x04\x80V[`@Q\x90\x92\x90a\x01\xA0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17a\x04EW` \x91_\x91`@Ra\x01b\x81R\x82\x81\x01\x7FJustin Sun is responsible for se\x81R\x7Ftting back the inevitable global`@\x83\x01R\x7F stablecoin revolution by years ``\x83\x01R\x7Fthrough exploiting Tron USDT's n`\x80\x83\x01R\x7Fetwork effects and imposing vend`\xA0\x83\x01R\x7For lock-in on hundreds of millio`\xC0\x83\x01R\x7Fns of people in the Third World,`\xE0\x83\x01R\x7F who rely on stablecoins for rema\x01\0\x83\x01R\x7Fittances and to store their savia\x01 \x83\x01R\x7Fngs in unstable, overregulated ea\x01@\x83\x01R\x7Fconomies. Let's Untron the Peopla\x01`\x83\x01Ra2\x97`\xF1\x1Ba\x01\x80\x83\x01Ra\x02\x7F`3`@Q\x80\x93\x87\x82\x01\x95\x7FUntronIntentsIndex\n\0\0\0\0\0\0\0\0\0\0\0\0\0\x87RQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x04]V[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x04:W_Q_U`\x01\x80`\xA0\x1B\x03\x16\x80c\x8Bx\xC6\xD8\x19U`@Q\x90\x80__Q` aAr_9_Q\x90_R\x81\x80\xA3` \x82\x01\x90_\x82R`@\x83\x01R`@\x82Ra\x02\xE1``\x83a\x04]V[`\x01\x80T\x01\x80`\x01U_T\x91` _`@Q\x82\x81\x01\x90\x86\x82R\x85`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R_Q` aAr_9_Q\x90_R`\xA0\x82\x01Ra\x03C`\xC0\x82\x8AQ\x80\x89\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x04]V[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x04:W\x7Fx\x16\x0F\x0B\x1B+2\xB5*\0v\xD8\xF0\xF7\x08\x88h{\xA7\x02\xA4\xD9\x93\xD5Z\xC8\xD92}W\xA1'\x90``_Q\x95\x86_U`@Q\x92\x83\x91_Q` aAr_9_Q\x90_R\x83R`@` \x84\x01RQ\x80\x91\x81`@\x85\x01R\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x81\x01\x03\x01\x90\xA4`\xA0R`\x80R`@Qa<\xDD\x90\x81a\x04\x95\x829`\x80Q\x81\x81\x81a\x0BA\x01R\x81\x81a\x0B\xDE\x01R\x81\x81a\x12}\x01R\x81\x81a\x14\r\x01R\x81\x81a$\x19\x01R\x81\x81a(&\x01R\x81\x81a)\x08\x01R\x81\x81a)[\x01R\x81\x81a*>\x01R\x81\x81a+\0\x01Ra0\xEB\x01R`\xA0Q\x81\x81\x81a\x15\xB4\x01Ra$\x92\x01R\xF3[`@Q=_\x82>=\x90\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x80\xFD[`\x1F\x90\x91\x01`\x1F\x19\x16\x81\x01\x90`\x01`\x01`@\x1B\x03\x82\x11\x90\x82\x10\x17a\x04EW`@RV[Q\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x04YWV\xFE`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_5`\xE0\x1C\x90\x81c/\xB4-p\x14a$\x80WP\x80c@\xE6$\xCB\x14a#\xC7W\x80cI\xC0\xC8\xB0\x14a#\xAAW\x80cMS\xE91\x14a#\x8EW\x80cQ\xEA\xD9\n\x14a#rW\x80cT\x9Fu\x05\x14a\x1E\xBAW\x80c\\#\xCC\x02\x14a\x14\x88W\x80c\\f\x07\x9A\x14a\x14mW\x80cd\xA4\x86\xC4\x14a\x11\xD4W\x80ce`L2\x14a\x11\xB7W\x80cqP\x18\xA6\x14a\x11XW\x80c{\xF8\xBB\x88\x14a\x10\xE7W\x80c\x8D\xA5\xCB[\x14a\x10\xBBW\x80c\x8E\xBA\xEB\xB2\x14a\x10\x9DW\x80c\x90!W\x8A\x14a\x0FpW\x80c\x9A\xD4,\x10\x14a\x0FLW\x80c\xAF$@\x05\x14a\x0B\x8DW\x80c\xB2\xA6\x17\x86\x14a\x0BpW\x80c\xC5ND\xEB\x14a\x0B,W\x80c\xE2M\\5\x14a\x0B\x0FW\x80c\xEB\xA4u\xAC\x14a\t\x1DW\x80c\xEE\x98\xAA\xAA\x14a\t\0W\x80c\xF2\xAF\x97\x0B\x14a\x07\xA5W\x80c\xF2\xFD\xE3\x8B\x14a\x07\x16Wc\xFC\xF9\x8D\x85\x14a\x01/W_\x80\xFD[a\x0186a&lV[\x920h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x14a\x07\tW0h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\x83\x94b\x01Q\x80B\x01\x90\x81B\x11a\x06\xF5W`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x84\x16` \x83\x01\x90\x81R\x90\x86\x16\x92\x82\x01\x92\x90\x92Ra\x01\x9D\x81``\x81\x01[\x03`\x1F\x19\x81\x01\x83R\x82a%fV[Q\x90 `@\x80Q` \x81\x01\x83\x81R\x91\x81\x01\x88\x90R``\x87\x81\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x82\x01R`t\x81\x01\x89\x90R\x91\x96\x91a\x01\xE0\x81`\x94\x81\x01a\x01\x8FV[Q\x90 \x96\x87_R`\x04` R`\x06`@_ \x01Ta\x06\xE6Wa\x02\0a-LV[\x95a\x02\x96` \x98`@Qa\x02\x14\x8B\x82a%fV[_\x81R`\x1F\x19\x8B\x016\x8C\x83\x017`@Q\x91a\x02.\x83a%JV[F\x83R0\x8C\x84\x01R`\x01`@\x84\x01R``\x83\x01R\x85`\x80\x83\x01R\x84`\xA0\x83\x01R`\x01\x80`\xA0\x1B\x03\x84\x16\x99\x8A`\xC0\x84\x01R\x8A`\xE0\x84\x01Ra\x01\0\x83\x01Ra\x01 \x82\x01R\x89a\x02{0\x85a:RV[\x91`@Q\x80\x94\x81\x92c\x1A\xD1\x08{`\xE0\x1B\x83R`\x04\x83\x01a-\xAAV[\x03\x81_`\x01`\x01`\xA0\x1B\x03\x8B\x16Z\xF1\x80\x15a\x06\xDBWa\x06\xA9W[a\x02\xC4\x91Pa\x02\xBF0\x84a:RV[a-(V[\x99\x82a\x06\x89WPa\x03)\x99\x92[a\x037a\x02\xE6a\x02\xE0\x86a,\x90V[\x86a-(V[`@Q\x90a\x02\xF3\x82a%/V[`\x01\x80`\xA0\x1B\x03\x8A\x16\x82R\x8B\x82\x01R`@Q\x9C\x8D\x91\x8C\x83\x01\x91\x90\x91` \x80`@\x83\x01\x94`\x01\x80`\xA0\x1B\x03\x81Q\x16\x84R\x01Q\x91\x01RV[\x03`\x1F\x19\x81\x01\x8DR\x8Ca%fV[c\x8Bx\xC6\xD8\x19T\x96`@Q\x95a\x03L\x87a%\x14V[`\x01\x87R\x8A\x87\x01\x9C\x8DR`@\x87\x01\x98`\x01\x80`\xA0\x1B\x03\x16\x89R``\x87\x01\x99\x8AR`\x80\x87\x01\x9A\x86\x8CR`@Q\x90a\x03\x81\x82a$\xF9V[\x88\x82R_\x81\x83\x01R\x89`@\x83\x01R_``\x83\x01R_`\x80\x83\x01R`\x01`\xA0\x83\x01R_`\xC0\x83\x01R\x8D_R`\x04\x81R`@_ \x90\x82Q\x80Q`\x02\x81\x10\x15a\x05\x96W`\xFF\x80\x19\x85T\x16\x91\x16\x17\x83U\x81\x81\x01Q\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06uWa\x03\xEF`\x01\x86\x01Ta$\xC1V[`\x1F\x81\x11a\x069W[P\x83\x90`\x1F\x83\x11`\x01\x14a\x05\xB5W\x94a\x05\r\x94`\x80a\x05\x1C\x9C\x9A\x98\x95a\x05=\x9F\x9E\x9C\x9A\x98\x86`\xC0\x97`\x07\x97a\x04B\x93_\x92a\x05\xAAW[PP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[`\x01\x85\x01U[`@\x81\x81\x01Q`\x02\x86\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x17\x90\x91U``\x80\x85\x01Q`\x03\x89\x01\x80T\x90\x93\x16\x90\x84\x16\x17\x90\x91U\x93\x90\x92\x01Q`\x04\x86\x01U\x92\x87\x01Q`\x05\x85\x01U\x91\x86\x01Q`\x06\x84\x01U\x85\x01Q\x92\x90\x91\x01\x80T`\x80\x86\x01Q`\x01`\x01`\xA8\x1B\x03\x19\x90\x91\x16\x93\x90\x92\x16\x92\x90\x92\x17\x90\x15\x15`\xA0\x1B`\xFF`\xA0\x1B\x16\x17\x81U\x91[`\xA0\x81\x01Q\x83T`\xFF`\xA8\x1B\x19\x16\x90\x15\x15`\xA8\x1B`\xFF`\xA8\x1B\x16\x17\x83U\x01Q\x81T`\xFF`\xB0\x1B\x19\x16\x90\x15\x15`\xB0\x1B`\xFF`\xB0\x1B\x16\x17\x90UV[`\x01`\x01`\xA0\x1B\x03\x16\x8Da7\x99V[`\x02T\x90a\x056`\x03T\x91a\x050\x81a,\x90V[\x90a-(V[\x91\x89a9\rV[Q\x90`\x02\x82\x10\x15a\x05\x96W\x83Q\x85Q\x93Q\x97Qa\x05\x88\x98a\x05q\x95\x91\x94`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x93\x90\x91\x16\x903\x8Aa4<V[Q\x90Q\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x903\x90a5\xEFV[8h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\0[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x01Q\x90P_\x80a\x04.V[\x90`\x01\x86\x01_R\x84_ \x91_[`\x1F\x19\x85\x16\x81\x10a\x06\"WP\x94`\x80a\x05\x1C\x9C\x9A\x98\x95a\x05=\x9F\x9E\x9C\x9A\x98\x93\x86`\x07\x96`\x01\x92a\x05\r\x9B`\xC0\x9A`\x1F\x19\x81\x16\x10a\x06\nW[PPP\x81\x1B\x01`\x01\x85\x01Ua\x04HV[\x01Q_\x19`\xF8\x84`\x03\x1B\x16\x1C\x19\x16\x90U_\x80\x80a\x05\xFAV[\x91\x92\x86`\x01\x81\x92\x86\x85\x01Q\x81U\x01\x94\x01\x92\x01a\x05\xC2V[a\x06e\x90`\x01\x87\x01_R\x85_ `\x1F\x85\x01`\x05\x1C\x81\x01\x91\x87\x86\x10a\x06kW[`\x1F\x01`\x05\x1C\x01\x90a&\xBEV[_a\x03\xF8V[\x90\x91P\x81\x90a\x06XV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x92\x99\x82\x03a\x06\x9AWa\x03)\x99a\x02\xD1V[cYd\xC1W`\xE1\x1B_R`\x04_\xFD[\x89\x82\x81=\x83\x11a\x06\xD4W[a\x06\xBE\x81\x83a%fV[\x81\x01\x03\x12a\x06\xD0Wa\x02\xC4\x91Pa\x02\xB0V[_\x80\xFD[P=a\x06\xB4V[`@Q=_\x82>=\x90\xFD[c\x11\x9BO\xD3`\xE1\x1B_R`\x04_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[c\xAB\x14<\x06_R`\x04`\x1C\xFD[` 6`\x03\x19\x01\x12a\x06\xD0W`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x90\x81\x81\x03a\x06\xD0Wa\x07?a7}V[``\x1B\x15a\x07\x98Wc\x8Bx\xC6\xD8\x19\x80T\x90\x82\x90U`@Qa\x07\x96\x92\x90\x91`\x01`\x01`\xA0\x1B\x03\x16\x81\x81_Q` a<\x91_9_Q\x90_R_\x80\xA3` \x83\x01R`@\x82\x01R`@\x81Ra\x07\x91``\x82a%fV[a;\x8FV[\0[ctH\xFB\xAE_R`\x04`\x1C\xFD[4a\x06\xD0W`@6`\x03\x19\x01\x12a\x06\xD0W`$5`\x045a\x07\xC4a7}V[\x80`\x02U\x81`\x03U\x7F\x9DL7y\xA8#\xAA\x84\xB2\r\xD2\xE8U\x1En\xD9Z\xDD\xBCV/;\xC4\x9B\x1Eh\x8A\xB7\x85\xB0]\x9D`@\x80Q\x83\x81R\x84` \x82\x01R\xA1`@Q\x91` \x83\x01\x91\x82R`@\x83\x01R`@\x82Ra\x08\x1A``\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa\x08\x8F`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x9DL7y\xA8#\xAA\x84\xB2\r\xD2\xE8U\x1En\xD9Z\xDD\xBCV/;\xC4\x9B\x1Eh\x8A\xB7\x85\xB0]\x9D`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra\x08\xFB_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x9DL7y\xA8#\xAA\x84\xB2\r\xD2\xE8U\x1En\xD9Z\xDD\xBCV/;\xC4\x9B\x1Eh\x8A\xB7\x85\xB0]\x9D\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x03\x90\xA4\0[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `\x03T`@Q\x90\x81R\xF3[a\t&6a&lV[\x90\x93\x920h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x14a\x07\tW0h\x92\x9E\xEE\x14\x9BK\xD2\x12hUa\tS\x82\x86\x85\x84\x88a,\xB1V[\x93\x84_R`\x04` R`\x06`@_ \x01T\x15a\x0B\0W\x84_R`\x04` R`\xFF`\x07`@_ \x01T`\xA8\x1C\x16a\n\xF1W`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x84\x16` \x83\x01\x90\x81R\x94\x16\x91\x81\x01\x91\x90\x91Ra\nR\x92\x90a\t\xB4\x81``\x81\x01a\x01\x8FV[Q\x90 a\t\xBFa-LV[\x90` \x95\x86\x92`@Q\x91a\t\xD3\x85\x84a%fV[_\x83R`\x1F\x19\x85\x016\x86\x85\x017`@Q\x93a\t\xED\x85a%JV[F\x85R0\x86\x86\x01R`\x01`@\x86\x01R``\x85\x01R`\x80\x84\x01R\x86`\xA0\x84\x01R`\x01\x80`\xA0\x1B\x03\x8A\x16\x80`\xC0\x85\x01R`\xE0\x84\x01Ra\x01\0\x83\x01Ra\x01 \x82\x01Ra\n60\x89a:RV[\x92`@Q\x80\x80\x96\x81\x94c\x1A\xD1\x08{`\xE0\x1B\x83R`\x04\x83\x01a-\xAAV[\x03\x914\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x80\x15a\x06\xDBWa\n\xC3W[a\n{\x91Pa\x02\xBF0\x87a:RV[\x90\x81\x03a\x06\x9AWa\n\xB4\x93`\x04a\n\xAF\x93\x85_RR`\x07`@_ \x01`\x01`\xA8\x1B`\xFF`\xA8\x1B\x19\x82T\x16\x17\x90U3\x84a5\xEFV[a0\x87V[P8h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\0[\x83\x82\x81=\x83\x11a\n\xEAW[a\n\xD8\x81\x83a%fV[\x81\x01\x03\x12a\x06\xD0Wa\n{\x91Pa\nlV[P=a\n\xCEV[cZ\xDFc\x87`\xE0\x1B_R`\x04_\xFD[ca\xAEd\x83`\xE0\x1B_R`\x04_\xFD[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `\x01T`@Q\x90\x81R\xF3[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `@Qb\x01Q\x80\x81R\xF3[4a\x06\xD0Wa\x0B\x9B6a&lV[\x92\x90\x93\x91\x83\x15a\x0F=Wb\x01Q\x80B\x01B\x11a\x06\xF5Wa\x0B\xBE\x84\x86\x83\x85\x87a,\xB1V[\x93\x84_R`\x04` R`\x06`@_ \x01Ta\x06\xE6Wa\x0Cj\x95a\x0C\x0203\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a.\xC2V[`\x02T\x92`\x03T\x94a\x0C+a\x0C%\x87b\x0FB@a\x0C\x1F\x89\x89a&\xD4V[\x04a,\x83V[\x85a-(V[\x96a\x0Cx`@Qa\x0C;\x81a%/V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x80\x82R` \x91\x82\x01\x8B\x81R`@\x80Q\x93\x84\x01\x92\x90\x92RQ\x90\x82\x01R\x9A\x8B\x90``\x82\x01\x90V[\x03`\x1F\x19\x81\x01\x8CR\x8Ba%fV[c\x8Bx\xC6\xD8\x19T`@Q\x9Aa\x0C\x8C\x8Ca%\x14V[`\x01\x8CR` \x8C\x01R`\x01`\x01`\xA0\x1B\x03\x90\x81\x16`@\x80\x8D\x01\x91\x90\x91R\x90\x85\x16``\x8C\x01R`\x80\x8B\x01\x86\x90RQa\x0C\xC2\x81a$\xF9V[\x8A\x81RB` \x82\x01Rb\x01Q\x80B\x01`@\x82\x01R3``\x82\x01R_`\x80\x82\x01R_`\xA0\x82\x01R_`\xC0\x82\x01R\x89_R`\x04` R`@_ \x81Q\x80Q`\x02\x81\x10\x15a\x05\x96W`\xFF\x80\x19\x84T\x16\x91\x16\x17\x82U` \x81\x01Q\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06uWa\r6`\x01\x85\x01Ta$\xC1V[`\x1F\x81\x11a\x0F\nW[P` \x90`\x1F\x83\x11`\x01\x14a\x0E\x83Wa\x0E5\x9D\x9C\x9B\x9A\x98\x96\x94`\x80a\x0E \x95a\r\x89\x86a\x0E/\x9E\x9C\x9A\x97`\xC0\x97`\x07\x97_\x92a\x05\xAAWPP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[`\x01\x84\x01U[`@\x81\x81\x01Q`\x02\x85\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x17\x90\x91U``\x80\x85\x01Q`\x03\x88\x01\x80T\x90\x93\x16\x90\x84\x16\x17\x90\x91U\x93\x90\x92\x01Q`\x04\x85\x01U` \x87\x01Q`\x05\x85\x01U\x86\x01Q`\x06\x84\x01U\x90\x85\x01Q\x92\x90\x91\x01\x80T`\x80\x86\x01Q`\x01`\x01`\xA8\x1B\x03\x19\x90\x91\x16\x93\x90\x92\x16\x92\x90\x92\x17\x90\x15\x15`\xA0\x1B`\xFF`\xA0\x1B\x16\x17\x81U\x91a\x04\xD4V[`\x01`\x01`\xA0\x1B\x03\x16\x8Aa7\x99V[\x84a9\rV[\x81Q`\x02\x81\x10\x15a\x05\x96Wa\x07\x96\x92a\x0E|\x91`\x01\x80`\xA0\x1B\x03``\x83\x01Q\x16\x91`\x80\x81\x01Q` `\x01\x80`\xA0\x1B\x03`@\x84\x01Q\x16\x92\x01Q\x93b\x01Q\x80B\x01\x933\x88a4<V[3\x90a/AV[\x90`\x01\x85\x01_R\x80_ \x91_[`\x1F\x19\x85\x16\x81\x10a\x0E\xF2WP\x94`\x80a\x0E5\x9F\x9E\x9D\x9C\x9A\x98\x96\x95`\x01\x86`\xC0\x96a\x0E/\x9F\x9D\x9B\x98\x96a\x0E \x9A`\x07\x98`\x1F\x19\x81\x16\x10a\x0E\xDAW[PPP\x81\x1B\x01`\x01\x84\x01Ua\r\x8FV[\x01Q_\x19`\xF8\x84`\x03\x1B\x16\x1C\x19\x16\x90U_\x80\x80a\x0E\xCAV[\x91\x92` `\x01\x81\x92\x86\x85\x01Q\x81U\x01\x94\x01\x92\x01a\x0E\x90V[a\x0F7\x90`\x01\x86\x01_R` _ `\x1F\x85\x01`\x05\x1C\x81\x01\x91` \x86\x10a\x06kW`\x1F\x01`\x05\x1C\x01\x90a&\xBEV[\x8Fa\r?V[c&>\x88\x07`\xE1\x1B_R`\x04_\xFD[4a\x06\xD0W` a\x0Fha\x0F_6a&lV[\x93\x92\x90\x92a,\xB1V[`@Q\x90\x81R\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W`\x045_R`\x04` R`@_ `@Qa\x0F\x9B\x81a%\x14V[`\xFF\x82T\x16\x91`\x02\x83\x10\x15a\x05\x96Wa\x10#\x92\x82R`\xFFa\x0F\xBE`\x01\x83\x01a%\x87V[` \x84\x01\x90\x81R`\x01\x80`\xA0\x1B\x03`\x02\x84\x01T\x16\x92`@\x85\x01\x93\x84R`\x01\x80`\xA0\x1B\x03`\x03\x82\x01T\x16``\x86\x01\x90\x81R`\x04\x82\x01T`\x80\x87\x01\x90\x81R`\x05\x83\x01T\x91a\x107`\x07`\x06\x86\x01T\x95\x01T\x95`@Q\x9A\x8B\x9A`\xE0\x8CR`\xE0\x8C\x01\x90Qa&'V[Q`\xA0a\x01\0\x8B\x01Ra\x01\x80\x8A\x01\x90a&4V[\x96Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x01 \x8A\x01R\x90Q\x81\x16a\x01@\x89\x01R\x90Qa\x01`\x88\x01R` \x87\x01\x91\x90\x91R`@\x86\x01\x91\x90\x91R\x81\x16``\x85\x01R`\xA0\x81\x81\x1C\x83\x16\x15\x15`\x80\x86\x01R`\xA8\x82\x90\x1C\x83\x16\x15\x15\x90\x85\x01R`\xB0\x1C\x16\x15\x15`\xC0\x83\x01R\x03\x90\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W` a\x0Fh`\x045a,\x90V[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0Wc\x8Bx\xC6\xD8\x19T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W`\x0450h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x14a\x07\tW0h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\x80_R`\x04` R`\x06`@_ \x01T\x15a\x0B\0Wa\x116\x90a0\x87V[\x15a\x11IW8h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\0[c\x0C0 \x9D`\xE3\x1B_R`\x04_\xFD[_6`\x03\x19\x01\x12a\x06\xD0Wa\x11ka7}V[c\x8Bx\xC6\xD8\x19\x80T_\x91\x82\x90U`@Qa\x07\x96\x92\x90\x91`\x01`\x01`\xA0\x1B\x03\x16\x90\x81_Q` a<\x91_9_Q\x90_R\x82\x80\xA3` \x82\x01R_`@\x82\x01R`@\x81Ra\x07\x91``\x82a%fV[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `\x02T`@Q\x90\x81R\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W`\x045\x80_R`\x04` R`@_ \x90`\x06\x82\x01T\x15a\x0B\0W`\x07\x82\x01\x80T`\x01`\x01`\xA0\x1B\x03\x81\x16\x93\x84\x15a\x14^W`\x05\x81\x01\x80T`x\x81\x01\x80\x91\x11a\x06\xF5WB\x10a\x14OW`\xFF\x83`\xA0\x1C\x16a\x14@W`\x02\x90\x91\x01T\x83T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90\x93U_\x90\x81\x90U`\xA8\x91\x90\x91\x1C`\xFF\x16\x15\x15\x91\x81\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x16\x84a\x13\xFCWPPb\x0FB@\x92a\x12\xA1\x86\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a3eV[\x85`@Q\x82\x81R\x83` \x82\x01R\x84`@\x82\x01R\x85``\x82\x01R\x86\x7F\x08\x9E\x9C6k\xCE\xC9y\x80}\x16\xF1\xDF\xD7x\xC1uy{\x86oci\xDB\xDF\x88\n+\xB7\xE7\x17\x9C`\x803\x93\xA4`@Q\x95` \x87\x01\x95\x86R3`@\x88\x01R``\x87\x01R`\x80\x86\x01R`\xA0\x85\x01R`\xC0\x84\x01R`\xE0\x83\x01R`\xE0\x82Ra\x13\x1Ba\x01\0\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa\x13\x90`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x08\x9E\x9C6k\xCE\xC9y\x80}\x16\xF1\xDF\xD7x\xC1uy{\x86oci\xDB\xDF\x88\n+\xB7\xE7\x17\x9C`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra\x08\xFB_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x08\x9E\x9C6k\xCE\xC9y\x80}\x16\xF1\xDF\xD7x\xC1uy{\x86oci\xDB\xDF\x88\n+\xB7\xE7\x17\x9C\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x92P\x92\x90Pb\x07\xA1 \x90a\x14;\x82\x93\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x1463\x82a2\xCAV[a2\xCAV[a\x12\xA1V[c\x19\x83UG`\xE0\x1B_R`\x04_\xFD[c\xA8\x05\x8E\xA9`\xE0\x1B_R`\x04_\xFD[c[\x95\x12\x91`\xE1\x1B_R`\x04_\xFD[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `@Q`x\x81R\xF3[4a\x06\xD0W`\xA06`\x03\x19\x01\x12a\x06\xD0W`$5`\x045`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x81`\x04\x01\x91a\x02\x846\x91\x01\x11a\x06\xD0W`D5\x91`\x01`\x01`@\x1B\x03\x83\x11a\x06\xD0W6`#\x84\x01\x12\x15a\x06\xD0W\x82`\x04\x015`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0W6`$\x82\x86\x01\x01\x11a\x06\xD0W`d5`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0W6`#\x82\x01\x12\x15a\x06\xD0W\x80`\x04\x015\x91`\x01`\x01`@\x1B\x03\x83\x11a\x06\xD0W\x82`\x05\x1B6`$\x82\x85\x01\x01\x11a\x06\xD0W0h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x14a\x07\tW0h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\x85_R`\x04` R`\x06`@_ \x01T\x15a\x0B\0W_\x86\x81R`\x04` R`@\x90 `\x07\x01T`\x01`\x01`\xA0\x1B\x03\x163\x03a\x1E\xABW\x85_R`\x04` R`\xFF`\x07`@_ \x01T`\xA0\x1C\x16a\x14@W`@Qc\x80\xA7,\x8B`\xE0\x1B\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x95\x90\x92` \x84`\x04\x81\x8AZ\xFA\x93\x84\x15a\x06\xDBW_\x94a\x1EgW[P`@Qc\t9\xB3\xF3`\xE3\x1B\x81R`\x80`\x04\x82\x01R\x98a\x03\x04\x8A\x01\x92\x80_`\x84\x8D\x01[\x8D`\x14\x83\x10a\x1E2WPPPPP\x90`$a\x16@\x93\x92`\x03\x19\x8C\x85\x03\x01\x82\x8D\x01R\x01a+\x8BV[\x87\x81\x03`\x03\x19\x01`D\x89\x01R\x84\x81R\x93`\x01`\x01`\xFB\x1B\x03\x10a\x06\xD0W` \x87\x82_\x96\x82\x96\x94`$\x84\x96\x01\x85\x83\x017`\x845`d\x84\x01R\x01\x03\x01\x91`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x92\x83\x15a\x06\xDBW_\x93a\x1DjW[P\x81_R`\x04` R`\xFF`@_ T\x16`\x02\x81\x10\x15a\x05\x96Wa\x19\x18WP\x80_R`\x04` Ra\x16\xCA`\x01`@_ \x01a%\x87V[\x80Q\x81\x01\x90` \x81\x83\x03\x12a\x06\xD0W` \x81\x01Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x01\x90`@\x82\x82\x03\x12a\x06\xD0W`@Q\x91a\x17\x06\x83a%/V[a\x17\x12` \x82\x01a,oV[\x83R`@\x81\x01Q\x91`\x01`\x01`@\x1B\x03\x83\x11a\x06\xD0Wa\x179\x92` \x80\x92\x01\x92\x01\x01a,)V[` \x82\x01\x81\x90R`\x80\x84\x01Q\x91Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16`X\x93\x90\x93\x1C\x16\x91\x90\x91\x14\x80\x15\x91\x90a\x18\xFAW[Pa\x18\xEBW[_\x81\x81R`\x04` \x90\x81R`@\x91\x82\x90 `\x07\x81\x01\x80T`\xFF`\xA0\x1B\x19\x16`\x01`\xA0\x1B\x17\x90UB`\x05\x90\x91\x01U\x83Q\x93\x81\x01Q\x82Q\x85\x81R\x91\x82\x01\x81\x90R\x913\x91\x84\x91\x7F\xFAyu\x85\xC9\x82}Y\xA7iN\xF3\x82$\x1F\x1A\x03\xCE\xD6\xA1\xA2\xB45;5\x93\x9A\xBCM\x04\xB2\x86\x91\xA3`@Q\x90` \x82\x01\x93\x83\x85R3`@\x84\x01R``\x83\x01R`\x80\x82\x01R`\x80\x81Ra\x17\xFD`\xA0\x82a%fV[`\x01\x80T\x01\x92\x83`\x01U` _\x80T\x92`@Qa\x18s`\xC0\x82\x86\x81\x01\x94\x88\x86R\x8B`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\xFAyu\x85\xC9\x82}Y\xA7iN\xF3\x82$\x1F\x1A\x03\xCE\xD6\xA1\xA2\xB45;5\x93\x9A\xBCM\x04\xB2\x86`\xA0\x83\x01R\x89Q\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBWa\n\xB4\x93_Q` a<\xB1_9_Q\x90_Ra\x18\xE3_Q\x94\x85_U`@Q\x91\x82\x91\x7F\xFAyu\x85\xC9\x82}Y\xA7iN\xF3\x82$\x1F\x1A\x03\xCE\xD6\xA1\xA2\xB45;5\x93\x9A\xBCM\x04\xB2\x86\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x03\x90\xA4a0\x87V[c\xD1\x97\xCB\x05`\xE0\x1B_R`\x04_\xFD[\x90P`\xA0\x83\x01Q` \x81Q\x91\x01 \x90` \x81Q\x91\x01 \x14\x15\x83a\x17fV[\x81_R`\x04` R`\xFF`@_ T\x16`\x02\x81\x10\x15a\x05\x96W`\x01\x14a\x19?W[Pa\x17lV[\x81_R`\x04` Ra\x19V`\x01`@_ \x01a%\x87V[`@\x81\x80Q\x81\x01\x03\x12a\x06\xD0W`@\x80Q\x91a\x19q\x83a%/V[a\x19}` \x82\x01a,oV[\x83R\x01Q\x90` \x81\x01\x91\x82R`@Qa\x19\x95\x81a%/V[_\x81R` \x81\x01\x93_\x85R`@Q\x90c\xDC\x8F\x863`\xE0\x1B\x82R` \x82`\x04\x81\x84Z\xFA\x91\x82\x15a\x06\xDBW_\x92a\x1D+W[P\x90` `\x04\x92`@Q\x93\x84\x80\x92c\xB9\x8Ec\x1D`\xE0\x1B\x82RZ\xFA\x91\x82\x15a\x06\xDBW_\x92a\x1C\xEFW[P`\x01\x80`\xA0\x1B\x03`\x80\x89\x01Q`X\x1C\x16`\xA0\x89\x01Q\x92`\x04\x84Q\x10a\x1C\xE0Wa\x1A\x16\x84a7@V[\x92`\x01`\x01`\xA0\x1B\x03\x16\x82\x03a\x1A\xDDWPP`\x01`\x01`\xE0\x1B\x03\x19\x16c\xA9\x05\x9C\xBB`\xE0\x1B\x81\x03a\x1A\x8CWPa\x1AJ\x90a<LV[\x85R`\x01`\x01`\xA0\x1B\x03\x16\x81R[Q\x90Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x16\x14\x80\x15\x92\x90a\x1A~W[PPa\x18\xEBW\x82a\x199V[Q\x90Q\x14\x15\x90P\x83\x80a\x1ArV[c#\xB8r\xDD`\xE0\x1B\x03a\x1A\xCEW`d\x81Q\x03a\x1A\xBFW`D\x81\x01Q`d\x90\x91\x01Q\x85R`\x01`\x01`\xA0\x1B\x03\x16\x81Ra\x1AXV[c\x9A\xC6\x0C-`\xE0\x1B_R`\x04_\xFD[c\t\x15\xB8{`\xE2\x1B_R`\x04_\xFD[`\x01`\x01`\xA0\x1B\x03\x16\x03a\x1A\xCEW`\x01`\x01`\xE0\x1B\x03\x19\x16cF\xE5\x7F\xF5`\xE1\x1B\x81\x03a\x1B\x1FWPa\x1B\r\x90a<LV[\x85R`\x01`\x01`\xA0\x1B\x03\x16\x81Ra\x1AXV[\x93\x96\x92\x95\x91\x94\x93\x90\x92\x91\x90c\x15\x92\xCA\x1B`\xE3\x1B\x03a\x1A\xCEW\x82Q``\x93`\x04\x80\x83\x11\x15a\x1C\xD9W[\x82\x81\x10a\x1C\x91W[PPP\x82Q\x83\x01\x92` \x81\x81\x86\x01\x95\x03\x12a\x06\xD0W` \x81\x01Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x01\x92\x80`?\x85\x01\x12\x15a\x06\xD0W` \x84\x01Qa\x1B\x93\x81a-5V[\x94a\x1B\xA1`@Q\x96\x87a%fV[\x81\x86R` \x80\x80\x88\x01\x93`\x05\x1B\x83\x01\x01\x01\x91\x83\x83\x11a\x06\xD0W`@\x82\x01\x90[\x83\x82\x10a\x1CbWPPPPP_\x96_[\x84Q\x81\x10\x15a\x1CFW` \x81`\x05\x1B\x86\x01\x01Q`\x04\x81Q\x10a\x1C=WcF\xE5\x7F\xF5`\xE1\x1B`\x01`\x01`\xE0\x1B\x03\x19a\x1C\x06\x83a7@V[\x16\x14a\x1C\x18W[P`\x01\x90[\x01a\x1B\xD0V[\x90\x98a\x1A\xCEWa\x1C'\x90a<LV[\x86R`\x01`\x01`\xA0\x1B\x03\x16\x86R`\x01\x97\x88a\x1C\rV[P`\x01\x90a\x1C\x12V[P\x93\x94\x91\x96\x90\x95\x92Pa\x1AXWc\t\x15\xB8{`\xE2\x1B_R`\x04_\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0W` \x91a\x1C\x86\x87\x84\x80\x80\x95\x89\x01\x01\x01a,)V[\x81R\x01\x91\x01\x90a\x1B\xC0V[`@Q\x95P\x91\x82\x90\x03\x91\x01`\x1F\x82\x01`\x1F\x19\x16[\x81\x81\x01Q\x86\x82\x01R`\x1F\x19\x01\x90\x81\x15a\x1C\xBEW\x90a\x1C\xA5V[PP`@\x81\x85\x01_` \x82\x01R\x01`@R\x83R\x87\x80\x80a\x1BOV[P\x81a\x1BGV[c\x12y\x95\x03`\xE0\x1B_R`\x04_\xFD[\x90\x91P` \x81=` \x11a\x1D#W[\x81a\x1D\x0B` \x93\x83a%fV[\x81\x01\x03\x12a\x06\xD0Wa\x1D\x1C\x90a,oV[\x90\x88a\x19\xEDV[=\x91Pa\x1C\xFEV[\x91P` \x82=` \x11a\x1DbW[\x81a\x1DF` \x93\x83a%fV[\x81\x01\x03\x12a\x06\xD0W` a\x1D[`\x04\x93a,oV[\x92Pa\x19\xC5V[=\x91Pa\x1D9V[\x90\x92P=\x80_\x83>a\x1D|\x81\x83a%fV[\x81\x01\x90` \x81\x83\x03\x12a\x06\xD0W\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x01`\xC0\x81\x83\x03\x12a\x06\xD0W`@Q\x91`\xC0\x83\x01\x83\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@R\x81Q\x83R` \x82\x01Q` \x84\x01R`@\x82\x01Qc\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x06\xD0W`@\x84\x01Ra\x1D\xF3``\x83\x01a,\x10V[``\x84\x01Ra\x1E\x04`\x80\x83\x01a,\x10V[`\x80\x84\x01R`\xA0\x82\x01Q`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0Wa\x1E&\x92\x01a,)V[`\xA0\x82\x01R\x91\x83a\x16\x94V[` a\x1EY`\x01\x93\x94\x95\x96\x99\x82\x93`\x83\x19\x90\x82\x03\x01\x86Ra\x1ES\x8B\x89a+ZV[\x90a+\x8BV[\x98\x01\x92\x01\x92\x01\x90\x92\x91a\x16\x19V[\x90\x93P` \x81=` \x11a\x1E\xA3W[\x81a\x1E\x83` \x93\x83a%fV[\x81\x01\x03\x12a\x06\xD0WQ`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x92\x89a\x15\xF6V[=\x91Pa\x1EvV[c\xC19\xEA\xBD`\xE0\x1B_R`\x04_\xFD[`@6`\x03\x19\x01\x12a\x06\xD0W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0W\x80`\x04\x01\x90\x806\x03`\xA0`\x03\x19\x82\x01\x12a\x06\xD0W`$5\x91`@Q` \x81\x01\x91` \x83R\x855`\x02\x81\x10\x15a\x06\xD0Wa\x1F\x13`@\x84\x01\x82a&'V[a\x1F5a\x1F$`$\x84\x01\x80\x99a+ZV[`\xA0``\x87\x01R`\xE0\x86\x01\x91a+\x8BV[\x95`D\x83\x01\x94`\x01`\x01`\xA0\x1B\x03a\x1FL\x87a&XV[\x16`\x80\x86\x01R`d\x84\x01\x94`\x01`\x01`\xA0\x1B\x03a\x1Fh\x87a&XV[\x16`\xA0\x82\x01Ra\x1F\x8C\x81`\x84\x87\x015\x9A\x8B`\xC0\x83\x01R\x03`\x1F\x19\x81\x01\x83R\x82a%fV[Q\x90 \x95`@Q` \x81\x01\x903``\x1B\x98\x89\x83R`4\x82\x01R\x83`T\x82\x01R`T\x81Ra\x1F\xBA`t\x82a%fV[Q\x90 \x96\x87_R`\x04` R`\x06`@_ \x01Ta\x06\xE6W\x82\x15a#cWa\x1F\xE1\x86a+\xABV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a#JW`@Q\x91\x8A``R0`@R`,Rc#\xB8r\xDD``\x1B`\x0CR` _`d`\x1C\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a#,W[PP_``R`@R[`@Q\x93a :\x85a$\xF9V[`@Q\x99a G\x8Ba%\x14V[\x84\x8BR5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x81\x01\x946`#\x87\x01\x12\x15a\x06\xD0W`$`\x04\x87\x015\x96\x01\x9Aa ~\x8C\x886\x91a+\xDAV[` \x82\x01Ra \x8C\x89a&XV[`@\x82\x01Ra \x9A\x88a&XV[``\x82\x01R\x8A`\x80\x82\x01R\x81R\x88` \x82\x01_\x81R`@\x83\x01\x86\x81R``\x84\x01\x93_\x85R`\x80\x81\x01\x91_\x83R`\xA0\x82\x01\x93`\x01\x85R`\xC0\x83\x01\x95_\x87R_R`\x04` R`@_ \x92Q\x80Q`\x02\x81\x10\x15a\x05\x96W`\xFF\x80\x19\x86T\x16\x91\x16\x17\x84U`\x01\x84\x01` \x82\x01Q\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06uWa!\x1F\x83Ta$\xC1V[`\x1F\x81\x11a\"\xFCW[P` \x90`\x1F\x83\x11`\x01\x14a\"\x81W`\x07\x94a\"!\x9C\x9B\x9A\x98\x94a!n\x85a!\xEB\x9A\x96a\"\x06\x9D\x9A\x96`\x80\x96_\x92a\x05\xAAWPP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[\x90U[`@\x81\x01Q`\x02\x86\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x17\x90\x91U``\x83\x01Q`\x03\x88\x01\x80T\x90\x92\x16\x90\x83\x16\x17\x90U\x91\x01Q`\x04\x85\x01U\x90Q`\x05\x84\x01U\x90Q`\x06\x83\x01U\x97Q\x91\x01\x80T\x92Q`\x01`\x01`\xA8\x1B\x03\x19\x90\x93\x16\x91\x90\x97\x16\x17\x90\x15\x15`\xA0\x1B`\xFF`\xA0\x1B\x16\x17\x85UV[Q\x83T`\xFF`\xA8\x1B\x19\x16\x90\x15\x15`\xA8\x1B`\xFF`\xA8\x1B\x16\x17\x83UV[Q\x81T`\xFF`\xB0\x1B\x19\x16\x90\x15\x15`\xB0\x1B`\xFF`\xB0\x1B\x16\x17\x90UV[a\"3a\"-\x87a+\xABV[\x97a+\xABV[\x91`\"\x19\x01\x13\x15a\x06\xD0W`\x01`\x01`@\x1B\x03\x84\x11a\x06\xD0W\x836\x03\x89\x13a\x06\xD0W\x87a\"y\x96a\"la\x07\x96\x9Ba\"t\x976\x91a+\xDAV[\x943\x8Aa4<V[a+\xABV[\x903\x90a5\xEFV[\x90`\x1F\x19\x83\x16\x91\x84_R\x81_ \x92_[\x81\x81\x10a\"\xE4WP\x94`\x01\x85a\"!\x9F\x9E\x9D\x9B\x97\x95`\x80\x95`\x07\x9A\x95a\"\x06\x9F\x9C\x98\x99a!\xEB\x9E\x9A\x10a\"\xCCW[PPP\x81\x1B\x01\x90Ua!qV[\x01Q_\x19`\xF8\x84`\x03\x1B\x16\x1C\x19\x16\x90U_\x80\x80a\"\xBFV[\x92\x93` `\x01\x81\x92\x87\x86\x01Q\x81U\x01\x95\x01\x93\x01a\"\x91V[a#&\x90\x84_R` _ `\x1F\x85\x01`\x05\x1C\x81\x01\x91` \x86\x10a\x06kW`\x1F\x01`\x05\x1C\x01\x90a&\xBEV[_a!(V[;\x15=\x17\x10\x15a#=W\x8A\x80a #V[cy9\xF4$_R`\x04`\x1C\xFD[PP4\x88\x14a -W[c\x1A\x84\xBCA`\xE2\x1B_R`\x04_\xFD[c\x1D\xA7Dy`\xE2\x1B_R`\x04_\xFD[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0Wa\x07\x96`\x045a'jV[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` _T`@Q\x90\x81R\xF3[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `@Qb\x0FB@\x81R\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W`\x045\x80_R`\x04` R`\x06`@_ \x01T\x15a\x0B\0W_\x81\x81R`\x04` R`@\x90 `\x07\x01T`\x01`\x01`\xA0\x1B\x03\x16a$qWa\x07\x96\x90a$=03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a.\xC2V[_\x81\x81R`\x04` R`@\x90 `\x07\x81\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x163\x90\x81\x17\x90\x91UB`\x05\x90\x92\x01\x91\x90\x91U\x90a/AV[c\x0C\x8D\x9E\xAB`\xE3\x1B_R`\x04_\xFD[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[\x90`\x01\x82\x81\x1C\x92\x16\x80\x15a$\xEFW[` \x83\x10\x14a$\xDBWV[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x91`\x7F\x16\x91a$\xD0V[`\xE0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[`\xA0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[a\x01@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[\x90`@Q\x91\x82_\x82T\x92a%\x9A\x84a$\xC1V[\x80\x84R\x93`\x01\x81\x16\x90\x81\x15a&\x05WP`\x01\x14a%\xC1W[Pa%\xBF\x92P\x03\x83a%fV[V[\x90P_\x92\x91\x92R` _ \x90_\x91[\x81\x83\x10a%\xE9WPP\x90` a%\xBF\x92\x82\x01\x01_a%\xB2V[` \x91\x93P\x80`\x01\x91T\x83\x85\x89\x01\x01R\x01\x91\x01\x90\x91\x84\x92a%\xD0V[\x90P` \x92Pa%\xBF\x94\x91P`\xFF\x19\x16\x82\x84\x01R\x15\x15`\x05\x1B\x82\x01\x01_a%\xB2V[\x90`\x02\x82\x10\x15a\x05\x96WRV[\x80Q\x80\x83R` \x92\x91\x81\x90\x84\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x06\xD0WV[`\xA0\x90`\x03\x19\x01\x12a\x06\xD0W`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x90`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x90`D5\x90`d5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x90`\x845\x90V[\x81\x81\x10a&\xC9WPPV[_\x81U`\x01\x01a&\xBEV[\x81\x81\x02\x92\x91\x81\x15\x91\x84\x04\x14\x17\x15a\x06\xF5WV[`\x07_\x91\x82\x81U`\x01\x81\x01a&\xFC\x81Ta$\xC1V[\x90\x81a''W[PP\x82`\x02\x82\x01U\x82`\x03\x82\x01U\x82`\x04\x82\x01U\x82`\x05\x82\x01U\x82`\x06\x82\x01U\x01UV[\x81`\x1F\x86\x93\x11`\x01\x14a'>WPU[_\x80a'\x03V[\x81\x83R` \x83 a'Z\x91`\x1F\x01`\x05\x1C\x81\x01\x90`\x01\x01a&\xBEV[\x80\x82R\x81` \x81 \x91UUa'7V[\x80_R`\x04` R`@_ \x90`\x06\x82\x01T\x80\x15a\x0B\0WB\x10a\x14OW_\x91`\x07\x81\x01\x92\x83T`\xFF\x81`\xA0\x1C\x16a)\xB3WPa(\xD4\x92\x93_\x92_\x90_\x92`\xFF\x81T`\xA8\x1C\x16a)\x84W[\x80T`\x01`\x01`\xA0\x1B\x03\x81\x16\x90\x81a(\xE7W[PPT\x94`\x01\x80`\xA0\x1B\x03`\x02\x83\x01T\x16\x91`\x03`\x01\x80`\xA0\x1B\x03\x91\x01T\x16`@Q\x92_\x84R`\xFF\x80\x89`\xA8\x1C\x16\x15\x15\x98\x89` \x87\x01R`\xB0\x1C\x16\x15\x15\x80`@\x86\x01R\x81``\x86\x01R\x82`\x80\x86\x01R\x83`\xA0\x86\x01R`\x01\x80`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x94\x85`\xC0\x82\x01R\x86`\xE0\x82\x01R\x87a\x01\0\x82\x01R\x88a\x01 \x82\x01R\x8B_Q` a<q_9_Q\x90_Ra\x01@3\x93\xA3`@Q\x98\x8B` \x8B\x01R3`@\x8B\x01R_``\x8B\x01R`\x80\x8A\x01R`\xA0\x89\x01R`\xC0\x88\x01R`\xE0\x87\x01Ra\x01\0\x86\x01Ra\x01 \x85\x01Ra\x01@\x84\x01Ra\x01`\x83\x01Ra\x01\x80\x82\x01Ra\x01\x80\x81Ra(\xCFa\x01\xA0\x82a%fV[a:\xD2V[_R`\x04` Ra%\xBF`@_ a&\xE7V[\x91\x94\x92\x93\x90\x92\x91`\xA8\x1C`\xFF\x16\x15a)LWPPPb\x07\xA1 \x90\x81\x92a)E\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a)13\x82a2\xCAV[`\x02\x84\x01T`\x01`\x01`\xA0\x1B\x03\x16\x90a2\xCAV[_\x80a'\xC8V[\x92\x91\x94P\x92a)\x7Fb\x0FB@\x95\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a3eV[a)EV[`\x04\x82\x01T`\x03\x83\x01T`\x02\x84\x01T\x91\x97Pa)\xAE\x91\x88\x91`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16a3\xD4V[a'\xB5V[`\xFF\x81`\xA8\x1C\x16\x90\x81a+KW[Pa+<W\x83a(\xD4\x93\x94T`\xFF\x81`\xA8\x1C\x16\x15\x80a+*W[a*\xEBW[PT\x91`\x01\x80`\xA0\x1B\x03`\x02\x82\x01T\x16\x90`\x03`\x01\x80`\xA0\x1B\x03\x91\x01T\x16`@Q\x91`\x01\x83R`\xFF\x80\x86`\xA8\x1C\x16\x15\x15\x95\x86` \x86\x01R`\xB0\x1C\x16\x15\x15\x80`@\x85\x01R\x81``\x85\x01R\x82`\x80\x85\x01R_`\xA0\x85\x01R`\x01\x80`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x93\x84`\xC0\x82\x01R_`\xE0\x82\x01R_a\x01\0\x82\x01R\x85a\x01 \x82\x01R\x88_Q` a<q_9_Q\x90_Ra\x01@3\x93\xA3`@Q\x95\x88` \x88\x01R3`@\x88\x01R`\x01``\x88\x01R`\x80\x87\x01R`\xA0\x86\x01R`\xC0\x85\x01R`\xE0\x84\x01R_a\x01\0\x84\x01Ra\x01 \x83\x01R_a\x01@\x83\x01R_a\x01`\x83\x01Ra\x01\x80\x82\x01Ra\x01\x80\x81Ra(\xCFa\x01\xA0\x82a%fV[b\x0FB@\x92Pa+$\x90`\x01`\x01`\xA0\x1B\x03\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a3eV[_a)\xE0V[P`\x01`\x01`\xA0\x1B\x03\x81\x16\x15\x15a)\xDBV[PPa+H\x91Pa0\x87V[PV[`\xFF\x91P`\xB0\x1C\x16\x15_a)\xC1V[\x905`\x1E\x19\x826\x03\x01\x81\x12\x15a\x06\xD0W\x01` \x815\x91\x01\x91`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x816\x03\x83\x13a\x06\xD0WV[\x90\x80` \x93\x92\x81\x84R\x84\x84\x017_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x90V[`\x01`\x01`@\x1B\x03\x81\x11a\x06uW`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x92\x91\x92a+\xE6\x82a+\xBFV[\x91a+\xF4`@Q\x93\x84a%fV[\x82\x94\x81\x84R\x81\x83\x01\x11a\x06\xD0W\x82\x81` \x93\x84_\x96\x017\x01\x01RV[Q\x90j\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x16\x82\x03a\x06\xD0WV[\x81`\x1F\x82\x01\x12\x15a\x06\xD0W\x80Q\x90a,@\x82a+\xBFV[\x92a,N`@Q\x94\x85a%fV[\x82\x84R` \x83\x83\x01\x01\x11a\x06\xD0W\x81_\x92` \x80\x93\x01\x83\x86\x01^\x83\x01\x01R\x90V[Q\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x06\xD0WV[\x91\x90\x82\x01\x80\x92\x11a\x06\xF5WV[b\x0FB@a,\xA4a,\xAE\x92`\x02T\x90a&\xD4V[\x04`\x03T\x90a,\x83V[\x90V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16` \x82\x01\x90\x81R\x93\x90\x92\x16\x90\x82\x01Ra-\"\x92\x91a\x01\x8F\x91a,\xE3\x81``\x81\x01\x85V[Q\x90 \x94`@Q\x94\x85\x93` \x85\x01\x97\x88\x92\x90\x91`t\x94\x92\x84R` \x84\x01Rk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90``\x1B\x16`@\x83\x01R`T\x82\x01R\x01\x90V[Q\x90 \x90V[\x91\x90\x82\x03\x91\x82\x11a\x06\xF5WV[`\x01`\x01`@\x1B\x03\x81\x11a\x06uW`\x05\x1B` \x01\x90V[`@Q\x90a-[` \x83a%fV[_\x82R\x81_\x80[\x81\x81\x10a-nWPPPV[`@Q\x90``\x82\x01\x91\x80\x83\x10`\x01`\x01`@\x1B\x03\x84\x11\x17a\x06uW` \x92`@R_\x81R_\x83\x82\x01R```@\x82\x01R\x82\x82\x86\x01\x01R\x01a-bV[\x91\x90\x91` \x81Ra\x01`\x81\x01\x90\x83Q` \x82\x01R`\x01\x80`\xA0\x1B\x03` \x85\x01Q\x16`@\x82\x01R`@\x84\x01Q\x15\x15``\x82\x01R``\x84\x01Q`\x80\x82\x01R`\x80\x84\x01Q`\xA0\x82\x01R`\xA0\x84\x01Q`\xC0\x82\x01R`\x01\x80`\xA0\x1B\x03`\xC0\x85\x01Q\x16`\xE0\x82\x01R`\x01\x80`\xA0\x1B\x03`\xE0\x85\x01Q\x16a\x01\0\x82\x01Ra\x01\0\x84\x01Q\x91a\x01@a\x01 \x83\x01R\x82Q\x80\x91Ra\x01\x80\x82\x01\x90` a\x01\x80\x82`\x05\x1B\x85\x01\x01\x94\x01\x91_\x90[\x82\x82\x10a.tWPPPPa\x01 a,\xAE\x93\x94\x01Q\x90a\x01@`\x1F\x19\x82\x85\x03\x01\x91\x01Ra&4V[\x90\x91\x92\x94` \x80a.\xB4`\x01\x93a\x01\x7F\x19\x89\x82\x03\x01\x86R```@\x8BQ\x87\x80`\xA0\x1B\x03\x81Q\x16\x84R\x85\x81\x01Q\x86\x85\x01R\x01Q\x91\x81`@\x82\x01R\x01\x90a&4V[\x97\x01\x92\x01\x92\x01\x90\x92\x91a.LV[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a/2W`@\x80Qb\x0FB@``\x90\x81R`\x01`\x01`\xA0\x1B\x03\x90\x95\x16\x90\x91R\x92\x1B`,Rc#\xB8r\xDD``\x1B`\x0CR` _`d`\x1C\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a/!W[PP_``R`@RV[;\x15=\x17\x10\x15a#=W_\x80a/\x16V[PPPb\x0FB@4\x03a#TWV[\x90`\x01\x80`\xA0\x1B\x03\x16\x80\x82\x7F\xBC?{~w\xA3\x95\xC1V\xC2M\xB8\xA8\xA7\x85\x02\t\xB2\xDFq\xA2V\x12\x92\xEE\xA2!\xE3+\xF5\xD4g` `@Qb\x0FB@\x81R\xA3`@Q\x91` \x83\x01R`@\x82\x01Rb\x0FB@``\x82\x01R``\x81Ra/\x9F`\x80\x82a%fV[`\x01\x80T\x01\x80`\x01U_T\x90` _`@Q\x82\x81\x01\x90\x85\x82R\x84`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F\xBC?{~w\xA3\x95\xC1V\xC2M\xB8\xA8\xA7\x85\x02\t\xB2\xDFq\xA2V\x12\x92\xEE\xA2!\xE3+\xF5\xD4g`\xA0\x82\x01Ra0\x16`\xC0\x82\x89Q\x80\x88\x8C\x01\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7F\xBC?{~w\xA3\x95\xC1V\xC2M\xB8\xA8\xA7\x85\x02\t\xB2\xDFq\xA2V\x12\x92\xEE\xA2!\xE3+\xF5\xD4g\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x03\x90\xA4V[\x80_R`\x04` R`@_ `\x07\x81\x01\x90\x81T`\xFF\x81`\xB0\x1C\x16\x80\x15a2\xBCW[\x80\x15a2\xAEW[a2\xA6W`\xFF`\xB0\x1B\x19\x81\x16`\x01`\xB0\x1B\x17\x83U`\x03\x82\x01\x80T`\x04\x90\x93\x01\x80T`@\x80Q`\x01`\x01`\xA0\x1B\x03\x96\x87\x16\x80\x82R` \x82\x01\x84\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x89\x16\x93\x83\x01\x84\x90Rb\x0FB@``\x84\x01R\x94\x97\x95\x96\x95\x90\x95\x16\x94\x91\x92\x91\x90\x85\x90\x8A\x90\x7F\x16\xBF\xB6J\xE7\x0B\x8A\x9B\xBD\xA2\x8D\xEB'\xA1\xCB\xC5\xEC>d\x97H\x17\x144L\"\x1BF\xC0w\x7F5\x90`\x80\x90\xA3`@Q\x94` \x86\x01\x99\x8AR`@\x86\x01R``\x85\x01R`\x80\x84\x01R`\xA0\x83\x01Rb\x0FB@`\xC0\x83\x01R`\xC0\x82Ra1\x8A`\xE0\x83a%fV[`\x01\x80T\x01\x91\x82`\x01U` _\x80T\x80\x99a2\x01`\xC0`@Q\x80\x93\x87\x82\x01\x95\x86R\x8A`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x16\xBF\xB6J\xE7\x0B\x8A\x9B\xBD\xA2\x8D\xEB'\xA1\xCB\xC5\xEC>d\x97H\x17\x144L\"\x1BF\xC0w\x7F5`\xA0\x83\x01R\x88Q\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBWa2\xA1\x96a2\x89\x93_Q` a<\xB1_9_Q\x90_Ra2u_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x16\xBF\xB6J\xE7\x0B\x8A\x9B\xBD\xA2\x8D\xEB'\xA1\xCB\xC5\xEC>d\x97H\x17\x144L\"\x1BF\xC0w\x7F5\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x03\x90\xA4\x84T`\x01`\x01`\xA0\x1B\x03\x16\x90a3eV[T\x91T\x90T\x91`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16a3\xD4V[`\x01\x90V[PPPP_\x90V[P`\xFF\x81`\xA8\x1C\x16\x15a0\xAFV[P`\xFF\x81`\xA0\x1C\x16\x15a0\xA8V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a38W`\x01`\x01`\xA0\x1B\x03\x16`\x14Rb\x07\xA1 `4Rc\xA9\x05\x9C\xBB``\x1B_\x90\x81R` \x90`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a3\x1AW[PP_`4RV[;\x15=\x17\x10\x15a3+W_\x80a3\x12V[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[_\x91P8\x90\x82\x90\x81\x90b\x07\xA1 \x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a3XWV[c\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a3\xB4W`\x01`\x01`\xA0\x1B\x03\x16`\x14Rb\x0FB@`4Rc\xA9\x05\x9C\xBB``\x1B_\x90\x81R` \x90`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a3\x1AWPP_`4RV[_\x91P8\x90\x82\x90\x81\x90b\x0FB@\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a3XWV[\x91\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a4 W`\x01`\x01`\xA0\x1B\x03\x16`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B_\x90\x81R` \x90`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a3\x1AWPP_`4RV[_\x92P8\x91\x83\x91\x82\x91\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a3XWV[\x95\x90\x91a5\x0E\x95\x94a5\0\x94\x98\x93`\x01\x80`\xA0\x1B\x03\x16\x95\x86\x89\x7Fo\x81\xB8\xAD\x07\x80\xA0\xFE\xBChz:s\xB1\x81C7\"\xB4\xBE0\xF7\xF0\xA0$\x16\x9FQa&r\x87`\xFF`@Q\x96\x16\x9C\x8D\x87R`\x01\x80`\xA0\x1B\x03\x16\x93\x84` \x88\x01R\x85`@\x88\x01R`\x01\x80`\xA0\x1B\x03\x16\x95\x86``\x82\x01R\x87`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x80a4\xC0`\xC0\x82\x01\x8Ba&4V[\x03\x90\xA3`@Q\x99\x8A\x97` \x89\x01\x9A\x8BR`@\x89\x01R``\x88\x01R`\x80\x87\x01R`\xA0\x86\x01R`\xC0\x85\x01R`\xE0\x84\x01Ra\x01\0\x80\x84\x01Ra\x01 \x83\x01\x90a&4V[\x03`\x1F\x19\x81\x01\x84R\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa5\x83`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7Fo\x81\xB8\xAD\x07\x80\xA0\xFE\xBChz:s\xB1\x81C7\"\xB4\xBE0\xF7\xF0\xA0$\x16\x9FQa&r\x87`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7Fo\x81\xB8\xAD\x07\x80\xA0\xFE\xBChz:s\xB1\x81C7\"\xB4\xBE0\xF7\xF0\xA0$\x16\x9FQa&r\x87\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x91\x92\x90`\x01\x80`\xA0\x1B\x03\x16\x92\x83\x83\x7F\x05Dt\x1F\xF6\xF2p\x80G\x13\x8C\x8F:h\xAB\xB9\x94\xE6(fm\xBAx_h_\xF1\x03Rt\xF9\xFB`@\x80Q\x94`\x01\x80`\xA0\x1B\x03\x16\x94\x85\x81R\x86` \x82\x01R\xA3`@Q\x93` \x85\x01\x93\x84R`@\x85\x01R``\x84\x01R`\x80\x83\x01R`\x80\x82Ra6_`\xA0\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa6\xD4`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x05Dt\x1F\xF6\xF2p\x80G\x13\x8C\x8F:h\xAB\xB9\x94\xE6(fm\xBAx_h_\xF1\x03Rt\xF9\xFB`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x05Dt\x1F\xF6\xF2p\x80G\x13\x8C\x8F:h\xAB\xB9\x94\xE6(fm\xBAx_h_\xF1\x03Rt\xF9\xFB\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x80Q` \x90\x91\x01Q`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x92\x91\x90`\x04\x82\x10a7bWPPV[`\x01`\x01`\xE0\x1B\x03\x19`\x04\x92\x90\x92\x03`\x03\x1B\x82\x90\x1B\x16\x16\x91PV[c\x8Bx\xC6\xD8\x19T3\x03a7\x8CWV[c\x82\xB4)\0_R`\x04`\x1C\xFD[`@\x80Q\x85\x81R`\x01`\x01`\xA0\x1B\x03\x80\x88\x16` \x83\x01R\x91\x81\x01\x88\x90R\x92\x81\x16\x96\x91\x95\x91\x94\x91\x93\x91\x92\x91\x16\x90\x81\x90\x87\x90\x87\x90\x7F\x11\x03\x9D\x94\x8EX\xAA\xBF\x98.\t\xEA\xB3\xF7\xCEm\xB7\xBFr\xAD\xD1\xD0\xB0Nc\xF0i~\xAC\x16\x02K\x90``\x90\xA4`@Q\x95` \x87\x01\x95\x86R`@\x87\x01R``\x86\x01R`\x80\x85\x01R`\x01\x80`\xA0\x1B\x03\x16`\xA0\x84\x01R`\xC0\x83\x01R`\xC0\x82Ra8,`\xE0\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa8\xA1`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x11\x03\x9D\x94\x8EX\xAA\xBF\x98.\t\xEA\xB3\xF7\xCEm\xB7\xBFr\xAD\xD1\xD0\xB0Nc\xF0i~\xAC\x16\x02K`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x11\x03\x9D\x94\x8EX\xAA\xBF\x98.\t\xEA\xB3\xF7\xCEm\xB7\xBFr\xAD\xD1\xD0\xB0Nc\xF0i~\xAC\x16\x02K\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x91\x92\x90\x92\x82\x7F\xC8S\xB9\xFB\xC6&W\x08\xCF\xC4s\xEF\xD1\xCE)\xB1\x9A6\x16\xB3\xED\xCC\xAE\xAFq\xA4\xA6\xB7x\xCB\x01\x0E```@Q\x87\x81R\x84` \x82\x01R\x85`@\x82\x01R\xA2`@Q\x93` \x85\x01\x93\x84R`@\x85\x01R``\x84\x01R`\x80\x83\x01R`\x80\x82Ra9q`\xA0\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa9\xE6`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\xC8S\xB9\xFB\xC6&W\x08\xCF\xC4s\xEF\xD1\xCE)\xB1\x9A6\x16\xB3\xED\xCC\xAE\xAFq\xA4\xA6\xB7x\xCB\x01\x0E`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7F\xC8S\xB9\xFB\xC6&W\x08\xCF\xC4s\xEF\xD1\xCE)\xB1\x9A6\x16\xB3\xED\xCC\xAE\xAFq\xA4\xA6\xB7x\xCB\x01\x0E\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15a:\xCCW`@Qcp\xA0\x821`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA\x90\x81\x15a\x06\xDBW_\x91a:\x9DWP\x90V[\x90P` \x81=` \x11a:\xC4W[\x81a:\xB8` \x93\x83a%fV[\x81\x01\x03\x12a\x06\xD0WQ\x90V[=\x91Pa:\xABV[\x90P1\x90V[`\x01\x80T\x01\x80`\x01U_T\x90` _`@Q\x82\x81\x01\x90\x85\x82R\x84`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R_Q` a<q_9_Q\x90_R`\xA0\x82\x01Ra;6`\xC0\x82\x89Q\x80\x88\x8C\x01\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91_Q` a<q_9_Q\x90_R\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[`\x01\x80T\x01\x80`\x01U_T\x90` _`@Q\x82\x81\x01\x90\x85\x82R\x84`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R_Q` a<\x91_9_Q\x90_R`\xA0\x82\x01Ra;\xF3`\xC0\x82\x89Q\x80\x88\x8C\x01\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91_Q` a<\x91_9_Q\x90_R\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x90`D\x82Q\x03a\x1A\xBFW`$\x82\x01Q`D\x90\x92\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90V\xFEm\xB2\xDA\x0Ff\x1DY\xD5\xA9\xC7g\xB6\xBAa\xA9\xC1\x92vZj\xAB\x95.^S\xEAw\x17S2\xF1=\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0x\x16\x0F\x0B\x1B+2\xB5*\0v\xD8\xF0\xF7\x08\x88h{\xA7\x02\xA4\xD9\x93\xD5Z\xC8\xD92}W\xA1'\xA1dsolcC\0\x08\x1B\0\n\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080806040526004361015610012575f80fd5b5f3560e01c9081632fb42d70146124805750806340e624cb146123c757806349c0c8b0146123aa5780634d53e9311461238e57806351ead90a14612372578063549f750514611eba5780635c23cc02146114885780635c66079a1461146d57806364a486c4146111d457806365604c32146111b7578063715018a6146111585780637bf8bb88146110e75780638da5cb5b146110bb5780638ebaebb21461109d5780639021578a14610f705780639ad42c1014610f4c578063af24400514610b8d578063b2a6178614610b70578063c54e44eb14610b2c578063e24d5c3514610b0f578063eba475ac1461091d578063ee98aaaa14610900578063f2af970b146107a5578063f2fde38b146107165763fcf98d851461012f575f80fd5b6101383661266c565b923068929eee149b4bd212685414610709573068929eee149b4bd21268558394620151804201908142116106f557604080516001600160a01b03808416602083019081529086169282019290925261019d81606081015b03601f198101835282612566565b5190206040805160208101838152918101889052606087811b6bffffffffffffffffffffffff191690820152607481018990529196916101e0816094810161018f565b51902096875f526004602052600660405f2001546106e657610200612d4c565b956102966020986040516102148b82612566565b5f8152601f198b01368c8301376040519161022e8361254a565b468352308c8401526001604084015260608301528560808301528460a083015260018060a01b038416998a60c08401528a60e08401526101008301526101208201528961027b3085613a52565b9160405180948192631ad1087b60e01b835260048301612daa565b03815f6001600160a01b038b165af180156106db576106a9575b6102c491506102bf3084613a52565b612d28565b9982610689575061032999925b6103376102e66102e086612c90565b86612d28565b604051906102f38261252f565b60018060a01b038a1682528b8201526040519c8d918c8301919091602080604083019460018060a01b0381511684520151910152565b03601f1981018d528c612566565b638b78c6d81954966040519561034c87612514565b600187528a87019c8d52604087019860018060a01b0316895260608701998a52608087019a868c5260405190610381826124f9565b8882525f818301528960408301525f60608301525f6080830152600160a08301525f60c08301528d5f526004815260405f20908251805160028110156105965760ff80198554169116178355818101518051906001600160401b038211610675576103ef60018601546124c1565b601f8111610639575b508390601f83116001146105b5579461050d94608061051c9c9a989561053d9f9e9c9a988660c097600797610442935f926105aa575b50508160011b915f199060031b1c19161790565b60018501555b6040818101516002860180546001600160a01b03199081166001600160a01b0393841617909155606080850151600389018054909316908416179091559390920151600486015592870151600585015591860151600684015585015192909101805460808601516001600160a81b0319909116939092169290921790151560a01b60ff60a01b16178155915b60a0810151835460ff60a81b191690151560a81b60ff60a81b161783550151815460ff60b01b191690151560b01b60ff60b01b16179055565b6001600160a01b03168d613799565b600254906105366003549161053081612c90565b90612d28565b918961390d565b51906002821015610596578351855193519751610588986105719591946001600160a01b039182169390911690338a61343c565b519051916001600160a01b039091169033906135ef565b3868929eee149b4bd2126855005b634e487b7160e01b5f52602160045260245ffd5b015190505f8061042e565b90600186015f52845f20915f5b601f1985168110610622575094608061051c9c9a989561053d9f9e9c9a98938660079660019261050d9b60c09a601f1981161061060a575b505050811b016001850155610448565b01515f1960f88460031b161c191690555f80806105fa565b9192866001819286850151815501940192016105c2565b61066590600187015f52855f20601f850160051c81019187861061066b575b601f0160051c01906126be565b5f6103f8565b9091508190610658565b634e487b7160e01b5f52604160045260245ffd5b9299820361069a57610329996102d1565b635964c15760e11b5f5260045ffd5b8982813d83116106d4575b6106be8183612566565b810103126106d0576102c491506102b0565b5f80fd5b503d6106b4565b6040513d5f823e3d90fd5b63119b4fd360e11b5f5260045ffd5b634e487b7160e01b5f52601160045260245ffd5b63ab143c065f526004601cfd5b60203660031901126106d0576004356001600160a01b038116908181036106d05761073f61377d565b60601b1561079857638b78c6d8198054908290556040516107969290916001600160a01b031681815f516020613c915f395f51905f525f80a36020830152604082015260408152610791606082612566565b613b8f565b005b637448fbae5f526004601cfd5b346106d05760403660031901126106d0576024356004356107c461377d565b80600255816003557f9d4c3779a823aa84b20dd2e8551e6ed95addbc562f3bc49b1e688ab785b05d9d60408051838152846020820152a1604051916020830191825260408301526040825261081a606083612566565b60018054018060015560205f80549360405161088f60c082868101948986528860408301524360608301524260808301527f9d4c3779a823aa84b20dd2e8551e6ed95addbc562f3bc49b1e688ab785b05d9d60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526108fb5f5194855f556040519182917f9d4c3779a823aa84b20dd2e8551e6ed95addbc562f3bc49b1e688ab785b05d9d8352604060208401526040830190612634565b0390a4005b346106d0575f3660031901126106d0576020600354604051908152f35b6109263661266c565b9093923068929eee149b4bd212685414610709573068929eee149b4bd21268556109538286858488612cb1565b93845f526004602052600660405f20015415610b0057845f52600460205260ff600760405f20015460a81c16610af157604080516001600160a01b0380841660208301908152941691810191909152610a5292906109b4816060810161018f565b5190206109bf612d4c565b906020958692604051916109d38584612566565b5f8352601f1985013686850137604051936109ed8561254a565b468552308686015260016040860152606085015260808401528660a084015260018060a01b038a168060c085015260e0840152610100830152610120820152610a363089613a52565b926040518080968194631ad1087b60e01b835260048301612daa565b039134906001600160a01b03165af180156106db57610ac3575b610a7b91506102bf3087613a52565b90810361069a57610ab4936004610aaf93855f5252600760405f2001600160a81b60ff60a81b1982541617905533846135ef565b613087565b503868929eee149b4bd2126855005b8382813d8311610aea575b610ad88183612566565b810103126106d057610a7b9150610a6c565b503d610ace565b635adf638760e01b5f5260045ffd5b6361ae648360e01b5f5260045ffd5b346106d0575f3660031901126106d0576020600154604051908152f35b346106d0575f3660031901126106d0576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346106d0575f3660031901126106d0576020604051620151808152f35b346106d057610b9b3661266c565b929093918315610f3d5762015180420142116106f557610bbe8486838587612cb1565b93845f526004602052600660405f2001546106e657610c6a95610c0230337f0000000000000000000000000000000000000000000000000000000000000000612ec2565b6002549260035494610c2b610c2587620f4240610c1f89896126d4565b04612c83565b85612d28565b96610c78604051610c3b8161252f565b6001600160a01b03841680825260209182018b8152604080519384019290925251908201529a8b906060820190565b03601f1981018c528b612566565b638b78c6d819546040519a610c8c8c612514565b60018c5260208c01526001600160a01b039081166040808d019190915290851660608c015260808b0186905251610cc2816124f9565b8a815242602082015262015180420160408201523360608201525f60808201525f60a08201525f60c0820152895f52600460205260405f208151805160028110156105965760ff8019845416911617825560208101518051906001600160401b03821161067557610d3660018501546124c1565b601f8111610f0a575b50602090601f8311600114610e8357610e359d9c9b9a9896946080610e2095610d8986610e2f9e9c9a9760c0976007975f926105aa5750508160011b915f199060031b1c19161790565b60018401555b6040818101516002850180546001600160a01b03199081166001600160a01b039384161790915560608085015160038801805490931690841617909155939092015160048501556020870151600585015586015160068401559085015192909101805460808601516001600160a81b0319909116939092169290921790151560a01b60ff60a01b16178155916104d4565b6001600160a01b03168a613799565b8461390d565b815160028110156105965761079692610e7c9160018060a01b03606083015116916080810151602060018060a01b036040840151169201519362015180420193338861343c565b3390612f41565b90600185015f52805f20915f5b601f1985168110610ef25750946080610e359f9e9d9c9a98969560018660c096610e2f9f9d9b9896610e209a600798601f19811610610eda575b505050811b016001840155610d8f565b01515f1960f88460031b161c191690555f8080610eca565b91926020600181928685015181550194019201610e90565b610f3790600186015f5260205f20601f850160051c8101916020861061066b57601f0160051c01906126be565b8f610d3f565b63263e880760e11b5f5260045ffd5b346106d0576020610f68610f5f3661266c565b93929092612cb1565b604051908152f35b346106d05760203660031901126106d0576004355f52600460205260405f20604051610f9b81612514565b60ff8254169160028310156105965761102392825260ff610fbe60018301612587565b6020840190815260018060a01b03600284015416926040850193845260018060a01b036003820154166060860190815260048201546080870190815260058301549161103760076006860154950154956040519a8b9a60e08c5260e08c019051612627565b5160a06101008b01526101808a0190612634565b96516001600160a01b039081166101208a0152905181166101408901529051610160880152602087019190915260408601919091528116606085015260a081811c83161515608086015260a882901c831615159085015260b01c16151560c08301520390f35b346106d05760203660031901126106d0576020610f68600435612c90565b346106d0575f3660031901126106d057638b78c6d819546040516001600160a01b039091168152602090f35b346106d05760203660031901126106d0576004353068929eee149b4bd212685414610709573068929eee149b4bd2126855805f526004602052600660405f20015415610b005761113690613087565b15611149573868929eee149b4bd2126855005b630c30209d60e31b5f5260045ffd5b5f3660031901126106d05761116b61377d565b638b78c6d81980545f918290556040516107969290916001600160a01b031690815f516020613c915f395f51905f528280a360208201525f604082015260408152610791606082612566565b346106d0575f3660031901126106d0576020600254604051908152f35b346106d05760203660031901126106d057600435805f52600460205260405f2090600682015415610b00576007820180546001600160a01b03811693841561145e57600581018054607881018091116106f557421061144f5760ff8360a01c166114405760029091015483546001600160a01b0319169093555f9081905560a89190911c60ff16151591819081906001600160a01b0316846113fc575050620f4240926112a1867f0000000000000000000000000000000000000000000000000000000000000000613365565b85604051828152836020820152846040820152856060820152867f089e9c366bcec979807d16f1dfd778c175797b866f6369dbdf880a2bb7e7179c60803393a460405195602087019586523360408801526060870152608086015260a085015260c084015260e083015260e0825261131b61010083612566565b60018054018060015560205f80549360405161139060c082868101948986528860408301524360608301524260808301527f089e9c366bcec979807d16f1dfd778c175797b866f6369dbdf880a2bb7e7179c60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526108fb5f5194855f556040519182917f089e9c366bcec979807d16f1dfd778c175797b866f6369dbdf880a2bb7e7179c8352604060208401526040830190612634565b92509290506207a1209061143b82937f000000000000000000000000000000000000000000000000000000000000000061143633826132ca565b6132ca565b6112a1565b631983554760e01b5f5260045ffd5b63a8058ea960e01b5f5260045ffd5b635b95129160e11b5f5260045ffd5b346106d0575f3660031901126106d057602060405160788152f35b346106d05760a03660031901126106d0576024356004356001600160401b0382116106d0578160040191610284369101116106d057604435916001600160401b0383116106d057366023840112156106d05782600401356001600160401b0381116106d05736602482860101116106d0576064356001600160401b0381116106d057366023820112156106d0578060040135916001600160401b0383116106d0578260051b36602482850101116106d0573068929eee149b4bd212685414610709573068929eee149b4bd2126855855f526004602052600660405f20015415610b00575f868152600460205260409020600701546001600160a01b03163303611eab57855f52600460205260ff600760405f20015460a01c16611440576040516380a72c8b60e01b81527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169590926020846004818a5afa9384156106db575f94611e67575b50604051630939b3f360e31b815260806004820152986103048a0192805f60848d015b8d60148310611e3257505050505090602461164093926003198c850301828d015201612b8b565b878103600319016044890152848152936001600160fb1b03106106d057602087825f968296946024849601858301376084356064840152010301916001600160a01b03165afa9283156106db575f93611d6a575b50815f52600460205260ff60405f2054166002811015610596576119185750805f5260046020526116ca600160405f2001612587565b80518101906020818303126106d0576020810151906001600160401b0382116106d05701906040828203126106d057604051916117068361252f565b61171260208201612c6f565b83526040810151916001600160401b0383116106d057611739926020809201920101612c29565b60208201819052608084015191516001600160a01b0390811660589390931c1691909114801591906118fa575b506118eb575b5f8181526004602090815260409182902060078101805460ff60a01b1916600160a01b17905542600590910155835193810151825185815291820181905291339184917ffa797585c9827d59a7694ef382241f1a03ced6a1a2b4353b35939abc4d04b28691a360405190602082019383855233604084015260608301526080820152608081526117fd60a082612566565b6001805401928360015560205f80549260405161187360c082868101948886528b60408301524360608301524260808301527ffa797585c9827d59a7694ef382241f1a03ced6a1a2b4353b35939abc4d04b28660a0830152895180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db57610ab4935f516020613cb15f395f51905f526118e35f5194855f556040519182917ffa797585c9827d59a7694ef382241f1a03ced6a1a2b4353b35939abc4d04b2868352604060208401526040830190612634565b0390a4613087565b63d197cb0560e01b5f5260045ffd5b905060a0830151602081519101209060208151910120141583611766565b815f52600460205260ff60405f20541660028110156105965760011461193f575b5061176c565b815f526004602052611956600160405f2001612587565b6040818051810103126106d05760408051916119718361252f565b61197d60208201612c6f565b8352015190602081019182526040516119958161252f565b5f815260208101935f85526040519063dc8f863360e01b8252602082600481845afa9182156106db575f92611d2b575b509060206004926040519384809263b98e631d60e01b82525afa9182156106db575f92611cef575b5060018060a01b03608089015160581c1660a0890151926004845110611ce057611a1684613740565b926001600160a01b03168203611add5750506001600160e01b03191663a9059cbb60e01b8103611a8c5750611a4a90613c4c565b85526001600160a01b031681525b5190516001600160a01b0390811691161480159290611a7e575b50506118eb5782611939565b519051141590508380611a72565b6323b872dd60e01b03611ace576064815103611abf57604481015160649091015185526001600160a01b03168152611a58565b639ac60c2d60e01b5f5260045ffd5b630915b87b60e21b5f5260045ffd5b6001600160a01b031603611ace576001600160e01b0319166346e57ff560e11b8103611b1f5750611b0d90613c4c565b85526001600160a01b03168152611a58565b9396929591949390929190631592ca1b60e31b03611ace578251606093600480831115611cd9575b828110611c91575b50505082518301926020818186019503126106d0576020810151906001600160401b0382116106d057019280603f850112156106d0576020840151611b9381612d35565b94611ba16040519687612566565b8186526020808088019360051b83010101918383116106d05760408201905b838210611c625750505050505f965f5b8451811015611c465760208160051b860101516004815110611c3d576346e57ff560e11b6001600160e01b0319611c0683613740565b1614611c18575b506001905b01611bd0565b9098611ace57611c2790613c4c565b86526001600160a01b0316865260019788611c0d565b50600190611c12565b509394919690959250611a5857630915b87b60e21b5f5260045ffd5b81516001600160401b0381116106d057602091611c86878480809589010101612c29565b815201910190611bc0565b6040519550918290039101601f8201601f19165b8181015186820152601f1901908115611cbe5790611ca5565b505060408185015f6020820152016040528352878080611b4f565b5081611b47565b631279950360e01b5f5260045ffd5b9091506020813d602011611d23575b81611d0b60209383612566565b810103126106d057611d1c90612c6f565b90886119ed565b3d9150611cfe565b91506020823d602011611d62575b81611d4660209383612566565b810103126106d0576020611d5b600493612c6f565b92506119c5565b3d9150611d39565b9092503d805f833e611d7c8183612566565b8101906020818303126106d0578051906001600160401b0382116106d0570160c0818303126106d0576040519160c083018381106001600160401b03821117610675576040528151835260208201516020840152604082015163ffffffff811681036106d0576040840152611df360608301612c10565b6060840152611e0460808301612c10565b608084015260a08201516001600160401b0381116106d057611e269201612c29565b60a08201529183611694565b6020611e59600193949596998293608319908203018652611e538b89612b5a565b90612b8b565b980192019201909291611619565b9093506020813d602011611ea3575b81611e8360209383612566565b810103126106d057516001600160a01b03811681036106d05792896115f6565b3d9150611e76565b63c139eabd60e01b5f5260045ffd5b60403660031901126106d0576004356001600160401b0381116106d057806004019080360360a06003198201126106d05760243591604051602081019160208352853560028110156106d057611f136040840182612627565b611f35611f24602484018099612b5a565b60a0606087015260e0860191612b8b565b9560448301946001600160a01b03611f4c87612658565b16608086015260648401946001600160a01b03611f6887612658565b1660a0820152611f8c8160848701359a8b60c083015203601f198101835282612566565b5190209560405160208101903360601b98898352603482015283605482015260548152611fba607482612566565b51902096875f526004602052600660405f2001546106e657821561236357611fe186612bab565b6001600160a01b0381161561234a57604051918a60605230604052602c526323b872dd60601b600c5260205f6064601c82855af1908160015f5114161561232c575b50505f6060526040525b6040519361203a856124f9565b604051996120478b612514565b848b5235906001600160401b0382116106d057810194366023870112156106d0576024600487013596019a61207e8c883691612bda565b602082015261208c89612658565b604082015261209a88612658565b60608201528a6080820152815288602082015f81526040830186815260608401935f855260808101915f835260a08201936001855260c08301955f87525f52600460205260405f209251805160028110156105965760ff801986541691161784556001840160208201518051906001600160401b0382116106755761211f83546124c1565b601f81116122fc575b50602090601f8311600114612281576007946122219c9b9a989461216e856121eb9a966122069d9a966080965f926105aa5750508160011b915f199060031b1c19161790565b90555b60408101516002860180546001600160a01b03199081166001600160a01b039384161790915560608301516003880180549092169083161790559101516004850155905160058401559051600683015597519101805492516001600160a81b0319909316919097161790151560a01b60ff60a01b16178555565b51835460ff60a81b191690151560a81b60ff60a81b16178355565b51815460ff60b01b191690151560b01b60ff60b01b16179055565b61223361222d87612bab565b97612bab565b916022190113156106d0576001600160401b0384116106d05783360389136106d057876122799661226c6107969b612274973691612bda565b94338a61343c565b612bab565b9033906135ef565b90601f19831691845f52815f20925f5b8181106122e45750946001856122219f9e9d9b979560809560079a956122069f9c98996121eb9e9a106122cc575b505050811b019055612171565b01515f1960f88460031b161c191690555f80806122bf565b92936020600181928786015181550195019301612291565b61232690845f5260205f20601f850160051c8101916020861061066b57601f0160051c01906126be565b5f612128565b3b153d17101561233d578a80612023565b637939f4245f526004601cfd5b505034881461202d575b631a84bc4160e21b5f5260045ffd5b631da7447960e21b5f5260045ffd5b346106d05760203660031901126106d05761079660043561276a565b346106d0575f3660031901126106d05760205f54604051908152f35b346106d0575f3660031901126106d0576020604051620f42408152f35b346106d05760203660031901126106d057600435805f526004602052600660405f20015415610b00575f818152600460205260409020600701546001600160a01b0316612471576107969061243d30337f0000000000000000000000000000000000000000000000000000000000000000612ec2565b5f8181526004602052604090206007810180546001600160a01b031916339081179091554260059092019190915590612f41565b630c8d9eab60e31b5f5260045ffd5b346106d0575f3660031901126106d0577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b90600182811c921680156124ef575b60208310146124db57565b634e487b7160e01b5f52602260045260245ffd5b91607f16916124d0565b60e081019081106001600160401b0382111761067557604052565b60a081019081106001600160401b0382111761067557604052565b604081019081106001600160401b0382111761067557604052565b61014081019081106001600160401b0382111761067557604052565b90601f801991011681019081106001600160401b0382111761067557604052565b9060405191825f82549261259a846124c1565b808452936001811690811561260557506001146125c1575b506125bf92500383612566565b565b90505f9291925260205f20905f915b8183106125e95750509060206125bf928201015f6125b2565b60209193508060019154838589010152019101909184926125d0565b9050602092506125bf94915060ff191682840152151560051b8201015f6125b2565b9060028210156105965752565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b35906001600160a01b03821682036106d057565b60a09060031901126106d0576004356001600160a01b03811681036106d057906024356001600160a01b03811681036106d05790604435906064356001600160a01b03811681036106d0579060843590565b8181106126c9575050565b5f81556001016126be565b818102929181159184041417156106f557565b60075f91828155600181016126fc81546124c1565b9081612727575b50508260028201558260038201558260048201558260058201558260068201550155565b81601f86931160011461273e5750555b5f80612703565b8183526020832061275a91601f0160051c8101906001016126be565b8082528160208120915555612737565b805f52600460205260405f209060068201548015610b0057421061144f575f916007810192835460ff8160a01c166129b357506128d492935f925f905f9260ff815460a81c16612984575b80546001600160a01b03811690816128e7575b5050549460018060a01b0360028301541691600360018060a01b0391015416604051925f845260ff808960a81c1615159889602087015260b01c1615158060408601528160608601528260808601528360a086015260018060a01b037f000000000000000000000000000000000000000000000000000000000000000016948560c08201528660e082015287610100820152886101208201528b5f516020613c715f395f51905f526101403393a3604051988b60208b01523360408b01525f60608b015260808a015260a089015260c088015260e087015261010086015261012085015261014084015261016083015261018082015261018081526128cf6101a082612566565b613ad2565b5f5260046020526125bf60405f206126e7565b9194929390929160a81c60ff161561294c575050506207a1209081926129457f000000000000000000000000000000000000000000000000000000000000000061293133826132ca565b60028401546001600160a01b0316906132ca565b5f806127c8565b929194509261297f620f4240957f0000000000000000000000000000000000000000000000000000000000000000613365565b612945565b6004820154600383015460028401549197506129ae9188916001600160a01b0391821691166133d4565b6127b5565b60ff8160a81c169081612b4b575b50612b3c57836128d493945460ff8160a81c161580612b2a575b612aeb575b50549160018060a01b0360028201541690600360018060a01b0391015416604051916001835260ff808660a81c1615159586602086015260b01c1615158060408501528160608501528260808501525f60a085015260018060a01b037f000000000000000000000000000000000000000000000000000000000000000016938460c08201525f60e08201525f61010082015285610120820152885f516020613c715f395f51905f526101403393a36040519588602088015233604088015260016060880152608087015260a086015260c085015260e08401525f6101008401526101208301525f6101408301525f61016083015261018082015261018081526128cf6101a082612566565b620f42409250612b24906001600160a01b03167f0000000000000000000000000000000000000000000000000000000000000000613365565b5f6129e0565b506001600160a01b03811615156129db565b5050612b489150613087565b50565b60ff915060b01c16155f6129c1565b9035601e19823603018112156106d05701602081359101916001600160401b0382116106d05781360383136106d057565b908060209392818452848401375f828201840152601f01601f1916010190565b356001600160a01b03811681036106d05790565b6001600160401b03811161067557601f01601f191660200190565b929192612be682612bbf565b91612bf46040519384612566565b8294818452818301116106d0578281602093845f960137010152565b51906affffffffffffffffffffff19821682036106d057565b81601f820112156106d057805190612c4082612bbf565b92612c4e6040519485612566565b828452602083830101116106d057815f9260208093018386015e8301015290565b51906001600160a01b03821682036106d057565b919082018092116106f557565b620f4240612ca4612cae92600254906126d4565b0460035490612c83565b90565b604080516001600160a01b03928316602082019081529390921690820152612d22929161018f91612ce3816060810185565b5190209460405194859360208501978892909160749492845260208401526bffffffffffffffffffffffff199060601b16604083015260548201520190565b51902090565b919082039182116106f557565b6001600160401b0381116106755760051b60200190565b60405190612d5b602083612566565b5f8252815f805b818110612d6e57505050565b6040519060608201918083106001600160401b03841117610675576020926040525f81525f838201526060604082015282828601015201612d62565b919091602081526101608101908351602082015260018060a01b03602085015116604082015260408401511515606082015260608401516080820152608084015160a082015260a084015160c082015260018060a01b0360c08501511660e082015260018060a01b0360e08501511661010082015261010084015191610140610120830152825180915261018082019060206101808260051b8501019401915f905b828210612e745750505050610120612cae9394015190610140601f1982850301910152612634565b90919294602080612eb460019361017f19898203018652606060408b51878060a01b03815116845285810151868501520151918160408201520190612634565b970192019201909291612e4c565b906001600160a01b03821615612f325760408051620f424060609081526001600160a01b03909516909152921b602c526323b872dd60601b600c5260205f6064601c82855af1908160015f51141615612f21575b50505f606052604052565b3b153d17101561233d575f80612f16565b505050620f4240340361235457565b9060018060a01b031680827fbc3f7b7e77a395c156c24db8a8a7850209b2df71a2561292eea221e32bf5d4676020604051620f42408152a36040519160208301526040820152620f4240606082015260608152612f9f608082612566565b6001805401806001555f549060205f604051828101908582528460408201524360608201524260808201527fbc3f7b7e77a395c156c24db8a8a7850209b2df71a2561292eea221e32bf5d46760a082015261301660c082895180888c018484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917fbc3f7b7e77a395c156c24db8a8a7850209b2df71a2561292eea221e32bf5d4678352604060208401526040830190612634565b0390a4565b805f52600460205260405f206007810190815460ff8160b01c1680156132bc575b80156132ae575b6132a65760ff60b01b198116600160b01b17835560038201805460049093018054604080516001600160a01b03968716808252602082018490527f0000000000000000000000000000000000000000000000000000000000000000808916938301849052620f424060608401529497959695909516949192919085908a907f16bfb64ae70b8a9bbda28deb27a1cbc5ec3e6497481714344c221b46c0777f3590608090a36040519460208601998a5260408601526060850152608084015260a0830152620f424060c083015260c0825261318a60e083612566565b6001805401918260015560205f8054809961320160c060405180938782019586528a60408301524360608301524260808301527f16bfb64ae70b8a9bbda28deb27a1cbc5ec3e6497481714344c221b46c0777f3560a0830152885180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db576132a196613289935f516020613cb15f395f51905f526132755f5194855f556040519182917f16bfb64ae70b8a9bbda28deb27a1cbc5ec3e6497481714344c221b46c0777f358352604060208401526040830190612634565b0390a484546001600160a01b031690613365565b5491549054916001600160a01b0391821691166133d4565b600190565b505050505f90565b5060ff8160a81c16156130af565b5060ff8160a01c16156130a8565b906001600160a01b03821615613338576001600160a01b03166014526207a12060345263a9059cbb60601b5f9081526020906044601082855af1908160015f5114161561331a575b50505f603452565b3b153d17101561332b575f80613312565b6390b8ec185f526004601cfd5b5f91503890829081906207a120906001600160a01b03165af11561335857565b63b12d13eb5f526004601cfd5b906001600160a01b038216156133b4576001600160a01b0316601452620f424060345263a9059cbb60601b5f9081526020906044601082855af1908160015f5114161561331a5750505f603452565b5f9150389082908190620f4240906001600160a01b03165af11561335857565b91906001600160a01b03831615613420576001600160a01b031660145260345263a9059cbb60601b5f9081526020906044601082855af1908160015f5114161561331a5750505f603452565b5f9250389183918291906001600160a01b03165af11561335857565b95909161350e959461350094989360018060a01b03169586897f6f81b8ad0780a0febc687a3a73b181433722b4be30f7f0a024169f516126728760ff60405196169c8d875260018060a01b03169384602088015285604088015260018060a01b03169586606082015287608082015260c060a0820152806134c060c082018b612634565b0390a3604051998a97602089019a8b5260408901526060880152608087015260a086015260c085015260e084015261010080840152610120830190612634565b03601f198101845283612566565b60018054018060015560205f80549360405161358360c082868101948986528860408301524360608301524260808301527f6f81b8ad0780a0febc687a3a73b181433722b4be30f7f0a024169f516126728760a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917f6f81b8ad0780a0febc687a3a73b181433722b4be30f7f0a024169f51612672878352604060208401526040830190612634565b91929060018060a01b03169283837f0544741ff6f2708047138c8f3a68abb994e628666dba785f685ff1035274f9fb604080519460018060a01b031694858152866020820152a360405193602085019384526040850152606084015260808301526080825261365f60a083612566565b60018054018060015560205f8054936040516136d460c082868101948986528860408301524360608301524260808301527f0544741ff6f2708047138c8f3a68abb994e628666dba785f685ff1035274f9fb60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917f0544741ff6f2708047138c8f3a68abb994e628666dba785f685ff1035274f9fb8352604060208401526040830190612634565b80516020909101516001600160e01b0319811692919060048210613762575050565b6001600160e01b031960049290920360031b82901b16169150565b638b78c6d81954330361378c57565b6382b429005f526004601cfd5b604080518581526001600160a01b0380881660208301529181018890529281169691959194919391929116908190879087907f11039d948e58aabf982e09eab3f7ce6db7bf72add1d0b04e63f0697eac16024b90606090a4604051956020870195865260408701526060860152608085015260018060a01b031660a084015260c083015260c0825261382c60e083612566565b60018054018060015560205f8054936040516138a160c082868101948986528860408301524360608301524260808301527f11039d948e58aabf982e09eab3f7ce6db7bf72add1d0b04e63f0697eac16024b60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917f11039d948e58aabf982e09eab3f7ce6db7bf72add1d0b04e63f0697eac16024b8352604060208401526040830190612634565b91929092827fc853b9fbc6265708cfc473efd1ce29b19a3616b3edccaeaf71a4a6b778cb010e6060604051878152846020820152856040820152a260405193602085019384526040850152606084015260808301526080825261397160a083612566565b60018054018060015560205f8054936040516139e660c082868101948986528860408301524360608301524260808301527fc853b9fbc6265708cfc473efd1ce29b19a3616b3edccaeaf71a4a6b778cb010e60a08301528a5180918484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182917fc853b9fbc6265708cfc473efd1ce29b19a3616b3edccaeaf71a4a6b778cb010e8352604060208401526040830190612634565b6001600160a01b0316908115613acc576040516370a0823160e01b81526001600160a01b03909116600482015290602090829060249082905afa9081156106db575f91613a9d575090565b90506020813d602011613ac4575b81613ab860209383612566565b810103126106d0575190565b3d9150613aab565b90503190565b6001805401806001555f549060205f604051828101908582528460408201524360608201524260808201525f516020613c715f395f51905f5260a0820152613b3660c082895180888c018484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182915f516020613c715f395f51905f528352604060208401526040830190612634565b6001805401806001555f549060205f604051828101908582528460408201524360608201524260808201525f516020613c915f395f51905f5260a0820152613bf360c082895180888c018484015e810186838201520301601f198101835282612566565b604051918291518091835e8101838152039060025afa156106db575f516020613cb15f395f51905f526130825f5194855f556040519182915f516020613c915f395f51905f528352604060208401526040830190612634565b906044825103611abf5760248201516044909201516001600160a01b03909216919056fe6db2da0f661d59d5a9c767b6ba61a9c192765a6aab952e5e53ea77175332f13d8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e078160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a127a164736f6c634300081b000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80\x80`@R`\x046\x10\x15a\0\x12W_\x80\xFD[_5`\xE0\x1C\x90\x81c/\xB4-p\x14a$\x80WP\x80c@\xE6$\xCB\x14a#\xC7W\x80cI\xC0\xC8\xB0\x14a#\xAAW\x80cMS\xE91\x14a#\x8EW\x80cQ\xEA\xD9\n\x14a#rW\x80cT\x9Fu\x05\x14a\x1E\xBAW\x80c\\#\xCC\x02\x14a\x14\x88W\x80c\\f\x07\x9A\x14a\x14mW\x80cd\xA4\x86\xC4\x14a\x11\xD4W\x80ce`L2\x14a\x11\xB7W\x80cqP\x18\xA6\x14a\x11XW\x80c{\xF8\xBB\x88\x14a\x10\xE7W\x80c\x8D\xA5\xCB[\x14a\x10\xBBW\x80c\x8E\xBA\xEB\xB2\x14a\x10\x9DW\x80c\x90!W\x8A\x14a\x0FpW\x80c\x9A\xD4,\x10\x14a\x0FLW\x80c\xAF$@\x05\x14a\x0B\x8DW\x80c\xB2\xA6\x17\x86\x14a\x0BpW\x80c\xC5ND\xEB\x14a\x0B,W\x80c\xE2M\\5\x14a\x0B\x0FW\x80c\xEB\xA4u\xAC\x14a\t\x1DW\x80c\xEE\x98\xAA\xAA\x14a\t\0W\x80c\xF2\xAF\x97\x0B\x14a\x07\xA5W\x80c\xF2\xFD\xE3\x8B\x14a\x07\x16Wc\xFC\xF9\x8D\x85\x14a\x01/W_\x80\xFD[a\x0186a&lV[\x920h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x14a\x07\tW0h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\x83\x94b\x01Q\x80B\x01\x90\x81B\x11a\x06\xF5W`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x84\x16` \x83\x01\x90\x81R\x90\x86\x16\x92\x82\x01\x92\x90\x92Ra\x01\x9D\x81``\x81\x01[\x03`\x1F\x19\x81\x01\x83R\x82a%fV[Q\x90 `@\x80Q` \x81\x01\x83\x81R\x91\x81\x01\x88\x90R``\x87\x81\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x82\x01R`t\x81\x01\x89\x90R\x91\x96\x91a\x01\xE0\x81`\x94\x81\x01a\x01\x8FV[Q\x90 \x96\x87_R`\x04` R`\x06`@_ \x01Ta\x06\xE6Wa\x02\0a-LV[\x95a\x02\x96` \x98`@Qa\x02\x14\x8B\x82a%fV[_\x81R`\x1F\x19\x8B\x016\x8C\x83\x017`@Q\x91a\x02.\x83a%JV[F\x83R0\x8C\x84\x01R`\x01`@\x84\x01R``\x83\x01R\x85`\x80\x83\x01R\x84`\xA0\x83\x01R`\x01\x80`\xA0\x1B\x03\x84\x16\x99\x8A`\xC0\x84\x01R\x8A`\xE0\x84\x01Ra\x01\0\x83\x01Ra\x01 \x82\x01R\x89a\x02{0\x85a:RV[\x91`@Q\x80\x94\x81\x92c\x1A\xD1\x08{`\xE0\x1B\x83R`\x04\x83\x01a-\xAAV[\x03\x81_`\x01`\x01`\xA0\x1B\x03\x8B\x16Z\xF1\x80\x15a\x06\xDBWa\x06\xA9W[a\x02\xC4\x91Pa\x02\xBF0\x84a:RV[a-(V[\x99\x82a\x06\x89WPa\x03)\x99\x92[a\x037a\x02\xE6a\x02\xE0\x86a,\x90V[\x86a-(V[`@Q\x90a\x02\xF3\x82a%/V[`\x01\x80`\xA0\x1B\x03\x8A\x16\x82R\x8B\x82\x01R`@Q\x9C\x8D\x91\x8C\x83\x01\x91\x90\x91` \x80`@\x83\x01\x94`\x01\x80`\xA0\x1B\x03\x81Q\x16\x84R\x01Q\x91\x01RV[\x03`\x1F\x19\x81\x01\x8DR\x8Ca%fV[c\x8Bx\xC6\xD8\x19T\x96`@Q\x95a\x03L\x87a%\x14V[`\x01\x87R\x8A\x87\x01\x9C\x8DR`@\x87\x01\x98`\x01\x80`\xA0\x1B\x03\x16\x89R``\x87\x01\x99\x8AR`\x80\x87\x01\x9A\x86\x8CR`@Q\x90a\x03\x81\x82a$\xF9V[\x88\x82R_\x81\x83\x01R\x89`@\x83\x01R_``\x83\x01R_`\x80\x83\x01R`\x01`\xA0\x83\x01R_`\xC0\x83\x01R\x8D_R`\x04\x81R`@_ \x90\x82Q\x80Q`\x02\x81\x10\x15a\x05\x96W`\xFF\x80\x19\x85T\x16\x91\x16\x17\x83U\x81\x81\x01Q\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06uWa\x03\xEF`\x01\x86\x01Ta$\xC1V[`\x1F\x81\x11a\x069W[P\x83\x90`\x1F\x83\x11`\x01\x14a\x05\xB5W\x94a\x05\r\x94`\x80a\x05\x1C\x9C\x9A\x98\x95a\x05=\x9F\x9E\x9C\x9A\x98\x86`\xC0\x97`\x07\x97a\x04B\x93_\x92a\x05\xAAW[PP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[`\x01\x85\x01U[`@\x81\x81\x01Q`\x02\x86\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x17\x90\x91U``\x80\x85\x01Q`\x03\x89\x01\x80T\x90\x93\x16\x90\x84\x16\x17\x90\x91U\x93\x90\x92\x01Q`\x04\x86\x01U\x92\x87\x01Q`\x05\x85\x01U\x91\x86\x01Q`\x06\x84\x01U\x85\x01Q\x92\x90\x91\x01\x80T`\x80\x86\x01Q`\x01`\x01`\xA8\x1B\x03\x19\x90\x91\x16\x93\x90\x92\x16\x92\x90\x92\x17\x90\x15\x15`\xA0\x1B`\xFF`\xA0\x1B\x16\x17\x81U\x91[`\xA0\x81\x01Q\x83T`\xFF`\xA8\x1B\x19\x16\x90\x15\x15`\xA8\x1B`\xFF`\xA8\x1B\x16\x17\x83U\x01Q\x81T`\xFF`\xB0\x1B\x19\x16\x90\x15\x15`\xB0\x1B`\xFF`\xB0\x1B\x16\x17\x90UV[`\x01`\x01`\xA0\x1B\x03\x16\x8Da7\x99V[`\x02T\x90a\x056`\x03T\x91a\x050\x81a,\x90V[\x90a-(V[\x91\x89a9\rV[Q\x90`\x02\x82\x10\x15a\x05\x96W\x83Q\x85Q\x93Q\x97Qa\x05\x88\x98a\x05q\x95\x91\x94`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x93\x90\x91\x16\x903\x8Aa4<V[Q\x90Q\x91`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x903\x90a5\xEFV[8h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\0[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[\x01Q\x90P_\x80a\x04.V[\x90`\x01\x86\x01_R\x84_ \x91_[`\x1F\x19\x85\x16\x81\x10a\x06\"WP\x94`\x80a\x05\x1C\x9C\x9A\x98\x95a\x05=\x9F\x9E\x9C\x9A\x98\x93\x86`\x07\x96`\x01\x92a\x05\r\x9B`\xC0\x9A`\x1F\x19\x81\x16\x10a\x06\nW[PPP\x81\x1B\x01`\x01\x85\x01Ua\x04HV[\x01Q_\x19`\xF8\x84`\x03\x1B\x16\x1C\x19\x16\x90U_\x80\x80a\x05\xFAV[\x91\x92\x86`\x01\x81\x92\x86\x85\x01Q\x81U\x01\x94\x01\x92\x01a\x05\xC2V[a\x06e\x90`\x01\x87\x01_R\x85_ `\x1F\x85\x01`\x05\x1C\x81\x01\x91\x87\x86\x10a\x06kW[`\x1F\x01`\x05\x1C\x01\x90a&\xBEV[_a\x03\xF8V[\x90\x91P\x81\x90a\x06XV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x92\x99\x82\x03a\x06\x9AWa\x03)\x99a\x02\xD1V[cYd\xC1W`\xE1\x1B_R`\x04_\xFD[\x89\x82\x81=\x83\x11a\x06\xD4W[a\x06\xBE\x81\x83a%fV[\x81\x01\x03\x12a\x06\xD0Wa\x02\xC4\x91Pa\x02\xB0V[_\x80\xFD[P=a\x06\xB4V[`@Q=_\x82>=\x90\xFD[c\x11\x9BO\xD3`\xE1\x1B_R`\x04_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[c\xAB\x14<\x06_R`\x04`\x1C\xFD[` 6`\x03\x19\x01\x12a\x06\xD0W`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x90\x81\x81\x03a\x06\xD0Wa\x07?a7}V[``\x1B\x15a\x07\x98Wc\x8Bx\xC6\xD8\x19\x80T\x90\x82\x90U`@Qa\x07\x96\x92\x90\x91`\x01`\x01`\xA0\x1B\x03\x16\x81\x81_Q` a<\x91_9_Q\x90_R_\x80\xA3` \x83\x01R`@\x82\x01R`@\x81Ra\x07\x91``\x82a%fV[a;\x8FV[\0[ctH\xFB\xAE_R`\x04`\x1C\xFD[4a\x06\xD0W`@6`\x03\x19\x01\x12a\x06\xD0W`$5`\x045a\x07\xC4a7}V[\x80`\x02U\x81`\x03U\x7F\x9DL7y\xA8#\xAA\x84\xB2\r\xD2\xE8U\x1En\xD9Z\xDD\xBCV/;\xC4\x9B\x1Eh\x8A\xB7\x85\xB0]\x9D`@\x80Q\x83\x81R\x84` \x82\x01R\xA1`@Q\x91` \x83\x01\x91\x82R`@\x83\x01R`@\x82Ra\x08\x1A``\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa\x08\x8F`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x9DL7y\xA8#\xAA\x84\xB2\r\xD2\xE8U\x1En\xD9Z\xDD\xBCV/;\xC4\x9B\x1Eh\x8A\xB7\x85\xB0]\x9D`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra\x08\xFB_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x9DL7y\xA8#\xAA\x84\xB2\r\xD2\xE8U\x1En\xD9Z\xDD\xBCV/;\xC4\x9B\x1Eh\x8A\xB7\x85\xB0]\x9D\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x03\x90\xA4\0[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `\x03T`@Q\x90\x81R\xF3[a\t&6a&lV[\x90\x93\x920h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x14a\x07\tW0h\x92\x9E\xEE\x14\x9BK\xD2\x12hUa\tS\x82\x86\x85\x84\x88a,\xB1V[\x93\x84_R`\x04` R`\x06`@_ \x01T\x15a\x0B\0W\x84_R`\x04` R`\xFF`\x07`@_ \x01T`\xA8\x1C\x16a\n\xF1W`@\x80Q`\x01`\x01`\xA0\x1B\x03\x80\x84\x16` \x83\x01\x90\x81R\x94\x16\x91\x81\x01\x91\x90\x91Ra\nR\x92\x90a\t\xB4\x81``\x81\x01a\x01\x8FV[Q\x90 a\t\xBFa-LV[\x90` \x95\x86\x92`@Q\x91a\t\xD3\x85\x84a%fV[_\x83R`\x1F\x19\x85\x016\x86\x85\x017`@Q\x93a\t\xED\x85a%JV[F\x85R0\x86\x86\x01R`\x01`@\x86\x01R``\x85\x01R`\x80\x84\x01R\x86`\xA0\x84\x01R`\x01\x80`\xA0\x1B\x03\x8A\x16\x80`\xC0\x85\x01R`\xE0\x84\x01Ra\x01\0\x83\x01Ra\x01 \x82\x01Ra\n60\x89a:RV[\x92`@Q\x80\x80\x96\x81\x94c\x1A\xD1\x08{`\xE0\x1B\x83R`\x04\x83\x01a-\xAAV[\x03\x914\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x80\x15a\x06\xDBWa\n\xC3W[a\n{\x91Pa\x02\xBF0\x87a:RV[\x90\x81\x03a\x06\x9AWa\n\xB4\x93`\x04a\n\xAF\x93\x85_RR`\x07`@_ \x01`\x01`\xA8\x1B`\xFF`\xA8\x1B\x19\x82T\x16\x17\x90U3\x84a5\xEFV[a0\x87V[P8h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\0[\x83\x82\x81=\x83\x11a\n\xEAW[a\n\xD8\x81\x83a%fV[\x81\x01\x03\x12a\x06\xD0Wa\n{\x91Pa\nlV[P=a\n\xCEV[cZ\xDFc\x87`\xE0\x1B_R`\x04_\xFD[ca\xAEd\x83`\xE0\x1B_R`\x04_\xFD[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `\x01T`@Q\x90\x81R\xF3[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `@Qb\x01Q\x80\x81R\xF3[4a\x06\xD0Wa\x0B\x9B6a&lV[\x92\x90\x93\x91\x83\x15a\x0F=Wb\x01Q\x80B\x01B\x11a\x06\xF5Wa\x0B\xBE\x84\x86\x83\x85\x87a,\xB1V[\x93\x84_R`\x04` R`\x06`@_ \x01Ta\x06\xE6Wa\x0Cj\x95a\x0C\x0203\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a.\xC2V[`\x02T\x92`\x03T\x94a\x0C+a\x0C%\x87b\x0FB@a\x0C\x1F\x89\x89a&\xD4V[\x04a,\x83V[\x85a-(V[\x96a\x0Cx`@Qa\x0C;\x81a%/V[`\x01`\x01`\xA0\x1B\x03\x84\x16\x80\x82R` \x91\x82\x01\x8B\x81R`@\x80Q\x93\x84\x01\x92\x90\x92RQ\x90\x82\x01R\x9A\x8B\x90``\x82\x01\x90V[\x03`\x1F\x19\x81\x01\x8CR\x8Ba%fV[c\x8Bx\xC6\xD8\x19T`@Q\x9Aa\x0C\x8C\x8Ca%\x14V[`\x01\x8CR` \x8C\x01R`\x01`\x01`\xA0\x1B\x03\x90\x81\x16`@\x80\x8D\x01\x91\x90\x91R\x90\x85\x16``\x8C\x01R`\x80\x8B\x01\x86\x90RQa\x0C\xC2\x81a$\xF9V[\x8A\x81RB` \x82\x01Rb\x01Q\x80B\x01`@\x82\x01R3``\x82\x01R_`\x80\x82\x01R_`\xA0\x82\x01R_`\xC0\x82\x01R\x89_R`\x04` R`@_ \x81Q\x80Q`\x02\x81\x10\x15a\x05\x96W`\xFF\x80\x19\x84T\x16\x91\x16\x17\x82U` \x81\x01Q\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06uWa\r6`\x01\x85\x01Ta$\xC1V[`\x1F\x81\x11a\x0F\nW[P` \x90`\x1F\x83\x11`\x01\x14a\x0E\x83Wa\x0E5\x9D\x9C\x9B\x9A\x98\x96\x94`\x80a\x0E \x95a\r\x89\x86a\x0E/\x9E\x9C\x9A\x97`\xC0\x97`\x07\x97_\x92a\x05\xAAWPP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[`\x01\x84\x01U[`@\x81\x81\x01Q`\x02\x85\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x17\x90\x91U``\x80\x85\x01Q`\x03\x88\x01\x80T\x90\x93\x16\x90\x84\x16\x17\x90\x91U\x93\x90\x92\x01Q`\x04\x85\x01U` \x87\x01Q`\x05\x85\x01U\x86\x01Q`\x06\x84\x01U\x90\x85\x01Q\x92\x90\x91\x01\x80T`\x80\x86\x01Q`\x01`\x01`\xA8\x1B\x03\x19\x90\x91\x16\x93\x90\x92\x16\x92\x90\x92\x17\x90\x15\x15`\xA0\x1B`\xFF`\xA0\x1B\x16\x17\x81U\x91a\x04\xD4V[`\x01`\x01`\xA0\x1B\x03\x16\x8Aa7\x99V[\x84a9\rV[\x81Q`\x02\x81\x10\x15a\x05\x96Wa\x07\x96\x92a\x0E|\x91`\x01\x80`\xA0\x1B\x03``\x83\x01Q\x16\x91`\x80\x81\x01Q` `\x01\x80`\xA0\x1B\x03`@\x84\x01Q\x16\x92\x01Q\x93b\x01Q\x80B\x01\x933\x88a4<V[3\x90a/AV[\x90`\x01\x85\x01_R\x80_ \x91_[`\x1F\x19\x85\x16\x81\x10a\x0E\xF2WP\x94`\x80a\x0E5\x9F\x9E\x9D\x9C\x9A\x98\x96\x95`\x01\x86`\xC0\x96a\x0E/\x9F\x9D\x9B\x98\x96a\x0E \x9A`\x07\x98`\x1F\x19\x81\x16\x10a\x0E\xDAW[PPP\x81\x1B\x01`\x01\x84\x01Ua\r\x8FV[\x01Q_\x19`\xF8\x84`\x03\x1B\x16\x1C\x19\x16\x90U_\x80\x80a\x0E\xCAV[\x91\x92` `\x01\x81\x92\x86\x85\x01Q\x81U\x01\x94\x01\x92\x01a\x0E\x90V[a\x0F7\x90`\x01\x86\x01_R` _ `\x1F\x85\x01`\x05\x1C\x81\x01\x91` \x86\x10a\x06kW`\x1F\x01`\x05\x1C\x01\x90a&\xBEV[\x8Fa\r?V[c&>\x88\x07`\xE1\x1B_R`\x04_\xFD[4a\x06\xD0W` a\x0Fha\x0F_6a&lV[\x93\x92\x90\x92a,\xB1V[`@Q\x90\x81R\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W`\x045_R`\x04` R`@_ `@Qa\x0F\x9B\x81a%\x14V[`\xFF\x82T\x16\x91`\x02\x83\x10\x15a\x05\x96Wa\x10#\x92\x82R`\xFFa\x0F\xBE`\x01\x83\x01a%\x87V[` \x84\x01\x90\x81R`\x01\x80`\xA0\x1B\x03`\x02\x84\x01T\x16\x92`@\x85\x01\x93\x84R`\x01\x80`\xA0\x1B\x03`\x03\x82\x01T\x16``\x86\x01\x90\x81R`\x04\x82\x01T`\x80\x87\x01\x90\x81R`\x05\x83\x01T\x91a\x107`\x07`\x06\x86\x01T\x95\x01T\x95`@Q\x9A\x8B\x9A`\xE0\x8CR`\xE0\x8C\x01\x90Qa&'V[Q`\xA0a\x01\0\x8B\x01Ra\x01\x80\x8A\x01\x90a&4V[\x96Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16a\x01 \x8A\x01R\x90Q\x81\x16a\x01@\x89\x01R\x90Qa\x01`\x88\x01R` \x87\x01\x91\x90\x91R`@\x86\x01\x91\x90\x91R\x81\x16``\x85\x01R`\xA0\x81\x81\x1C\x83\x16\x15\x15`\x80\x86\x01R`\xA8\x82\x90\x1C\x83\x16\x15\x15\x90\x85\x01R`\xB0\x1C\x16\x15\x15`\xC0\x83\x01R\x03\x90\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W` a\x0Fh`\x045a,\x90V[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0Wc\x8Bx\xC6\xD8\x19T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W`\x0450h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x14a\x07\tW0h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\x80_R`\x04` R`\x06`@_ \x01T\x15a\x0B\0Wa\x116\x90a0\x87V[\x15a\x11IW8h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\0[c\x0C0 \x9D`\xE3\x1B_R`\x04_\xFD[_6`\x03\x19\x01\x12a\x06\xD0Wa\x11ka7}V[c\x8Bx\xC6\xD8\x19\x80T_\x91\x82\x90U`@Qa\x07\x96\x92\x90\x91`\x01`\x01`\xA0\x1B\x03\x16\x90\x81_Q` a<\x91_9_Q\x90_R\x82\x80\xA3` \x82\x01R_`@\x82\x01R`@\x81Ra\x07\x91``\x82a%fV[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `\x02T`@Q\x90\x81R\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W`\x045\x80_R`\x04` R`@_ \x90`\x06\x82\x01T\x15a\x0B\0W`\x07\x82\x01\x80T`\x01`\x01`\xA0\x1B\x03\x81\x16\x93\x84\x15a\x14^W`\x05\x81\x01\x80T`x\x81\x01\x80\x91\x11a\x06\xF5WB\x10a\x14OW`\xFF\x83`\xA0\x1C\x16a\x14@W`\x02\x90\x91\x01T\x83T`\x01`\x01`\xA0\x1B\x03\x19\x16\x90\x93U_\x90\x81\x90U`\xA8\x91\x90\x91\x1C`\xFF\x16\x15\x15\x91\x81\x90\x81\x90`\x01`\x01`\xA0\x1B\x03\x16\x84a\x13\xFCWPPb\x0FB@\x92a\x12\xA1\x86\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a3eV[\x85`@Q\x82\x81R\x83` \x82\x01R\x84`@\x82\x01R\x85``\x82\x01R\x86\x7F\x08\x9E\x9C6k\xCE\xC9y\x80}\x16\xF1\xDF\xD7x\xC1uy{\x86oci\xDB\xDF\x88\n+\xB7\xE7\x17\x9C`\x803\x93\xA4`@Q\x95` \x87\x01\x95\x86R3`@\x88\x01R``\x87\x01R`\x80\x86\x01R`\xA0\x85\x01R`\xC0\x84\x01R`\xE0\x83\x01R`\xE0\x82Ra\x13\x1Ba\x01\0\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa\x13\x90`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x08\x9E\x9C6k\xCE\xC9y\x80}\x16\xF1\xDF\xD7x\xC1uy{\x86oci\xDB\xDF\x88\n+\xB7\xE7\x17\x9C`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra\x08\xFB_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x08\x9E\x9C6k\xCE\xC9y\x80}\x16\xF1\xDF\xD7x\xC1uy{\x86oci\xDB\xDF\x88\n+\xB7\xE7\x17\x9C\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x92P\x92\x90Pb\x07\xA1 \x90a\x14;\x82\x93\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x1463\x82a2\xCAV[a2\xCAV[a\x12\xA1V[c\x19\x83UG`\xE0\x1B_R`\x04_\xFD[c\xA8\x05\x8E\xA9`\xE0\x1B_R`\x04_\xFD[c[\x95\x12\x91`\xE1\x1B_R`\x04_\xFD[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `@Q`x\x81R\xF3[4a\x06\xD0W`\xA06`\x03\x19\x01\x12a\x06\xD0W`$5`\x045`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x81`\x04\x01\x91a\x02\x846\x91\x01\x11a\x06\xD0W`D5\x91`\x01`\x01`@\x1B\x03\x83\x11a\x06\xD0W6`#\x84\x01\x12\x15a\x06\xD0W\x82`\x04\x015`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0W6`$\x82\x86\x01\x01\x11a\x06\xD0W`d5`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0W6`#\x82\x01\x12\x15a\x06\xD0W\x80`\x04\x015\x91`\x01`\x01`@\x1B\x03\x83\x11a\x06\xD0W\x82`\x05\x1B6`$\x82\x85\x01\x01\x11a\x06\xD0W0h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x14a\x07\tW0h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\x85_R`\x04` R`\x06`@_ \x01T\x15a\x0B\0W_\x86\x81R`\x04` R`@\x90 `\x07\x01T`\x01`\x01`\xA0\x1B\x03\x163\x03a\x1E\xABW\x85_R`\x04` R`\xFF`\x07`@_ \x01T`\xA0\x1C\x16a\x14@W`@Qc\x80\xA7,\x8B`\xE0\x1B\x81R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x95\x90\x92` \x84`\x04\x81\x8AZ\xFA\x93\x84\x15a\x06\xDBW_\x94a\x1EgW[P`@Qc\t9\xB3\xF3`\xE3\x1B\x81R`\x80`\x04\x82\x01R\x98a\x03\x04\x8A\x01\x92\x80_`\x84\x8D\x01[\x8D`\x14\x83\x10a\x1E2WPPPPP\x90`$a\x16@\x93\x92`\x03\x19\x8C\x85\x03\x01\x82\x8D\x01R\x01a+\x8BV[\x87\x81\x03`\x03\x19\x01`D\x89\x01R\x84\x81R\x93`\x01`\x01`\xFB\x1B\x03\x10a\x06\xD0W` \x87\x82_\x96\x82\x96\x94`$\x84\x96\x01\x85\x83\x017`\x845`d\x84\x01R\x01\x03\x01\x91`\x01`\x01`\xA0\x1B\x03\x16Z\xFA\x92\x83\x15a\x06\xDBW_\x93a\x1DjW[P\x81_R`\x04` R`\xFF`@_ T\x16`\x02\x81\x10\x15a\x05\x96Wa\x19\x18WP\x80_R`\x04` Ra\x16\xCA`\x01`@_ \x01a%\x87V[\x80Q\x81\x01\x90` \x81\x83\x03\x12a\x06\xD0W` \x81\x01Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x01\x90`@\x82\x82\x03\x12a\x06\xD0W`@Q\x91a\x17\x06\x83a%/V[a\x17\x12` \x82\x01a,oV[\x83R`@\x81\x01Q\x91`\x01`\x01`@\x1B\x03\x83\x11a\x06\xD0Wa\x179\x92` \x80\x92\x01\x92\x01\x01a,)V[` \x82\x01\x81\x90R`\x80\x84\x01Q\x91Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16`X\x93\x90\x93\x1C\x16\x91\x90\x91\x14\x80\x15\x91\x90a\x18\xFAW[Pa\x18\xEBW[_\x81\x81R`\x04` \x90\x81R`@\x91\x82\x90 `\x07\x81\x01\x80T`\xFF`\xA0\x1B\x19\x16`\x01`\xA0\x1B\x17\x90UB`\x05\x90\x91\x01U\x83Q\x93\x81\x01Q\x82Q\x85\x81R\x91\x82\x01\x81\x90R\x913\x91\x84\x91\x7F\xFAyu\x85\xC9\x82}Y\xA7iN\xF3\x82$\x1F\x1A\x03\xCE\xD6\xA1\xA2\xB45;5\x93\x9A\xBCM\x04\xB2\x86\x91\xA3`@Q\x90` \x82\x01\x93\x83\x85R3`@\x84\x01R``\x83\x01R`\x80\x82\x01R`\x80\x81Ra\x17\xFD`\xA0\x82a%fV[`\x01\x80T\x01\x92\x83`\x01U` _\x80T\x92`@Qa\x18s`\xC0\x82\x86\x81\x01\x94\x88\x86R\x8B`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\xFAyu\x85\xC9\x82}Y\xA7iN\xF3\x82$\x1F\x1A\x03\xCE\xD6\xA1\xA2\xB45;5\x93\x9A\xBCM\x04\xB2\x86`\xA0\x83\x01R\x89Q\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBWa\n\xB4\x93_Q` a<\xB1_9_Q\x90_Ra\x18\xE3_Q\x94\x85_U`@Q\x91\x82\x91\x7F\xFAyu\x85\xC9\x82}Y\xA7iN\xF3\x82$\x1F\x1A\x03\xCE\xD6\xA1\xA2\xB45;5\x93\x9A\xBCM\x04\xB2\x86\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x03\x90\xA4a0\x87V[c\xD1\x97\xCB\x05`\xE0\x1B_R`\x04_\xFD[\x90P`\xA0\x83\x01Q` \x81Q\x91\x01 \x90` \x81Q\x91\x01 \x14\x15\x83a\x17fV[\x81_R`\x04` R`\xFF`@_ T\x16`\x02\x81\x10\x15a\x05\x96W`\x01\x14a\x19?W[Pa\x17lV[\x81_R`\x04` Ra\x19V`\x01`@_ \x01a%\x87V[`@\x81\x80Q\x81\x01\x03\x12a\x06\xD0W`@\x80Q\x91a\x19q\x83a%/V[a\x19}` \x82\x01a,oV[\x83R\x01Q\x90` \x81\x01\x91\x82R`@Qa\x19\x95\x81a%/V[_\x81R` \x81\x01\x93_\x85R`@Q\x90c\xDC\x8F\x863`\xE0\x1B\x82R` \x82`\x04\x81\x84Z\xFA\x91\x82\x15a\x06\xDBW_\x92a\x1D+W[P\x90` `\x04\x92`@Q\x93\x84\x80\x92c\xB9\x8Ec\x1D`\xE0\x1B\x82RZ\xFA\x91\x82\x15a\x06\xDBW_\x92a\x1C\xEFW[P`\x01\x80`\xA0\x1B\x03`\x80\x89\x01Q`X\x1C\x16`\xA0\x89\x01Q\x92`\x04\x84Q\x10a\x1C\xE0Wa\x1A\x16\x84a7@V[\x92`\x01`\x01`\xA0\x1B\x03\x16\x82\x03a\x1A\xDDWPP`\x01`\x01`\xE0\x1B\x03\x19\x16c\xA9\x05\x9C\xBB`\xE0\x1B\x81\x03a\x1A\x8CWPa\x1AJ\x90a<LV[\x85R`\x01`\x01`\xA0\x1B\x03\x16\x81R[Q\x90Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x16\x14\x80\x15\x92\x90a\x1A~W[PPa\x18\xEBW\x82a\x199V[Q\x90Q\x14\x15\x90P\x83\x80a\x1ArV[c#\xB8r\xDD`\xE0\x1B\x03a\x1A\xCEW`d\x81Q\x03a\x1A\xBFW`D\x81\x01Q`d\x90\x91\x01Q\x85R`\x01`\x01`\xA0\x1B\x03\x16\x81Ra\x1AXV[c\x9A\xC6\x0C-`\xE0\x1B_R`\x04_\xFD[c\t\x15\xB8{`\xE2\x1B_R`\x04_\xFD[`\x01`\x01`\xA0\x1B\x03\x16\x03a\x1A\xCEW`\x01`\x01`\xE0\x1B\x03\x19\x16cF\xE5\x7F\xF5`\xE1\x1B\x81\x03a\x1B\x1FWPa\x1B\r\x90a<LV[\x85R`\x01`\x01`\xA0\x1B\x03\x16\x81Ra\x1AXV[\x93\x96\x92\x95\x91\x94\x93\x90\x92\x91\x90c\x15\x92\xCA\x1B`\xE3\x1B\x03a\x1A\xCEW\x82Q``\x93`\x04\x80\x83\x11\x15a\x1C\xD9W[\x82\x81\x10a\x1C\x91W[PPP\x82Q\x83\x01\x92` \x81\x81\x86\x01\x95\x03\x12a\x06\xD0W` \x81\x01Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x01\x92\x80`?\x85\x01\x12\x15a\x06\xD0W` \x84\x01Qa\x1B\x93\x81a-5V[\x94a\x1B\xA1`@Q\x96\x87a%fV[\x81\x86R` \x80\x80\x88\x01\x93`\x05\x1B\x83\x01\x01\x01\x91\x83\x83\x11a\x06\xD0W`@\x82\x01\x90[\x83\x82\x10a\x1CbWPPPPP_\x96_[\x84Q\x81\x10\x15a\x1CFW` \x81`\x05\x1B\x86\x01\x01Q`\x04\x81Q\x10a\x1C=WcF\xE5\x7F\xF5`\xE1\x1B`\x01`\x01`\xE0\x1B\x03\x19a\x1C\x06\x83a7@V[\x16\x14a\x1C\x18W[P`\x01\x90[\x01a\x1B\xD0V[\x90\x98a\x1A\xCEWa\x1C'\x90a<LV[\x86R`\x01`\x01`\xA0\x1B\x03\x16\x86R`\x01\x97\x88a\x1C\rV[P`\x01\x90a\x1C\x12V[P\x93\x94\x91\x96\x90\x95\x92Pa\x1AXWc\t\x15\xB8{`\xE2\x1B_R`\x04_\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0W` \x91a\x1C\x86\x87\x84\x80\x80\x95\x89\x01\x01\x01a,)V[\x81R\x01\x91\x01\x90a\x1B\xC0V[`@Q\x95P\x91\x82\x90\x03\x91\x01`\x1F\x82\x01`\x1F\x19\x16[\x81\x81\x01Q\x86\x82\x01R`\x1F\x19\x01\x90\x81\x15a\x1C\xBEW\x90a\x1C\xA5V[PP`@\x81\x85\x01_` \x82\x01R\x01`@R\x83R\x87\x80\x80a\x1BOV[P\x81a\x1BGV[c\x12y\x95\x03`\xE0\x1B_R`\x04_\xFD[\x90\x91P` \x81=` \x11a\x1D#W[\x81a\x1D\x0B` \x93\x83a%fV[\x81\x01\x03\x12a\x06\xD0Wa\x1D\x1C\x90a,oV[\x90\x88a\x19\xEDV[=\x91Pa\x1C\xFEV[\x91P` \x82=` \x11a\x1DbW[\x81a\x1DF` \x93\x83a%fV[\x81\x01\x03\x12a\x06\xD0W` a\x1D[`\x04\x93a,oV[\x92Pa\x19\xC5V[=\x91Pa\x1D9V[\x90\x92P=\x80_\x83>a\x1D|\x81\x83a%fV[\x81\x01\x90` \x81\x83\x03\x12a\x06\xD0W\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x01`\xC0\x81\x83\x03\x12a\x06\xD0W`@Q\x91`\xC0\x83\x01\x83\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@R\x81Q\x83R` \x82\x01Q` \x84\x01R`@\x82\x01Qc\xFF\xFF\xFF\xFF\x81\x16\x81\x03a\x06\xD0W`@\x84\x01Ra\x1D\xF3``\x83\x01a,\x10V[``\x84\x01Ra\x1E\x04`\x80\x83\x01a,\x10V[`\x80\x84\x01R`\xA0\x82\x01Q`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0Wa\x1E&\x92\x01a,)V[`\xA0\x82\x01R\x91\x83a\x16\x94V[` a\x1EY`\x01\x93\x94\x95\x96\x99\x82\x93`\x83\x19\x90\x82\x03\x01\x86Ra\x1ES\x8B\x89a+ZV[\x90a+\x8BV[\x98\x01\x92\x01\x92\x01\x90\x92\x91a\x16\x19V[\x90\x93P` \x81=` \x11a\x1E\xA3W[\x81a\x1E\x83` \x93\x83a%fV[\x81\x01\x03\x12a\x06\xD0WQ`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x92\x89a\x15\xF6V[=\x91Pa\x1EvV[c\xC19\xEA\xBD`\xE0\x1B_R`\x04_\xFD[`@6`\x03\x19\x01\x12a\x06\xD0W`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x06\xD0W\x80`\x04\x01\x90\x806\x03`\xA0`\x03\x19\x82\x01\x12a\x06\xD0W`$5\x91`@Q` \x81\x01\x91` \x83R\x855`\x02\x81\x10\x15a\x06\xD0Wa\x1F\x13`@\x84\x01\x82a&'V[a\x1F5a\x1F$`$\x84\x01\x80\x99a+ZV[`\xA0``\x87\x01R`\xE0\x86\x01\x91a+\x8BV[\x95`D\x83\x01\x94`\x01`\x01`\xA0\x1B\x03a\x1FL\x87a&XV[\x16`\x80\x86\x01R`d\x84\x01\x94`\x01`\x01`\xA0\x1B\x03a\x1Fh\x87a&XV[\x16`\xA0\x82\x01Ra\x1F\x8C\x81`\x84\x87\x015\x9A\x8B`\xC0\x83\x01R\x03`\x1F\x19\x81\x01\x83R\x82a%fV[Q\x90 \x95`@Q` \x81\x01\x903``\x1B\x98\x89\x83R`4\x82\x01R\x83`T\x82\x01R`T\x81Ra\x1F\xBA`t\x82a%fV[Q\x90 \x96\x87_R`\x04` R`\x06`@_ \x01Ta\x06\xE6W\x82\x15a#cWa\x1F\xE1\x86a+\xABV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a#JW`@Q\x91\x8A``R0`@R`,Rc#\xB8r\xDD``\x1B`\x0CR` _`d`\x1C\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a#,W[PP_``R`@R[`@Q\x93a :\x85a$\xF9V[`@Q\x99a G\x8Ba%\x14V[\x84\x8BR5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x81\x01\x946`#\x87\x01\x12\x15a\x06\xD0W`$`\x04\x87\x015\x96\x01\x9Aa ~\x8C\x886\x91a+\xDAV[` \x82\x01Ra \x8C\x89a&XV[`@\x82\x01Ra \x9A\x88a&XV[``\x82\x01R\x8A`\x80\x82\x01R\x81R\x88` \x82\x01_\x81R`@\x83\x01\x86\x81R``\x84\x01\x93_\x85R`\x80\x81\x01\x91_\x83R`\xA0\x82\x01\x93`\x01\x85R`\xC0\x83\x01\x95_\x87R_R`\x04` R`@_ \x92Q\x80Q`\x02\x81\x10\x15a\x05\x96W`\xFF\x80\x19\x86T\x16\x91\x16\x17\x84U`\x01\x84\x01` \x82\x01Q\x80Q\x90`\x01`\x01`@\x1B\x03\x82\x11a\x06uWa!\x1F\x83Ta$\xC1V[`\x1F\x81\x11a\"\xFCW[P` \x90`\x1F\x83\x11`\x01\x14a\"\x81W`\x07\x94a\"!\x9C\x9B\x9A\x98\x94a!n\x85a!\xEB\x9A\x96a\"\x06\x9D\x9A\x96`\x80\x96_\x92a\x05\xAAWPP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[\x90U[`@\x81\x01Q`\x02\x86\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x90\x81\x16`\x01`\x01`\xA0\x1B\x03\x93\x84\x16\x17\x90\x91U``\x83\x01Q`\x03\x88\x01\x80T\x90\x92\x16\x90\x83\x16\x17\x90U\x91\x01Q`\x04\x85\x01U\x90Q`\x05\x84\x01U\x90Q`\x06\x83\x01U\x97Q\x91\x01\x80T\x92Q`\x01`\x01`\xA8\x1B\x03\x19\x90\x93\x16\x91\x90\x97\x16\x17\x90\x15\x15`\xA0\x1B`\xFF`\xA0\x1B\x16\x17\x85UV[Q\x83T`\xFF`\xA8\x1B\x19\x16\x90\x15\x15`\xA8\x1B`\xFF`\xA8\x1B\x16\x17\x83UV[Q\x81T`\xFF`\xB0\x1B\x19\x16\x90\x15\x15`\xB0\x1B`\xFF`\xB0\x1B\x16\x17\x90UV[a\"3a\"-\x87a+\xABV[\x97a+\xABV[\x91`\"\x19\x01\x13\x15a\x06\xD0W`\x01`\x01`@\x1B\x03\x84\x11a\x06\xD0W\x836\x03\x89\x13a\x06\xD0W\x87a\"y\x96a\"la\x07\x96\x9Ba\"t\x976\x91a+\xDAV[\x943\x8Aa4<V[a+\xABV[\x903\x90a5\xEFV[\x90`\x1F\x19\x83\x16\x91\x84_R\x81_ \x92_[\x81\x81\x10a\"\xE4WP\x94`\x01\x85a\"!\x9F\x9E\x9D\x9B\x97\x95`\x80\x95`\x07\x9A\x95a\"\x06\x9F\x9C\x98\x99a!\xEB\x9E\x9A\x10a\"\xCCW[PPP\x81\x1B\x01\x90Ua!qV[\x01Q_\x19`\xF8\x84`\x03\x1B\x16\x1C\x19\x16\x90U_\x80\x80a\"\xBFV[\x92\x93` `\x01\x81\x92\x87\x86\x01Q\x81U\x01\x95\x01\x93\x01a\"\x91V[a#&\x90\x84_R` _ `\x1F\x85\x01`\x05\x1C\x81\x01\x91` \x86\x10a\x06kW`\x1F\x01`\x05\x1C\x01\x90a&\xBEV[_a!(V[;\x15=\x17\x10\x15a#=W\x8A\x80a #V[cy9\xF4$_R`\x04`\x1C\xFD[PP4\x88\x14a -W[c\x1A\x84\xBCA`\xE2\x1B_R`\x04_\xFD[c\x1D\xA7Dy`\xE2\x1B_R`\x04_\xFD[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0Wa\x07\x96`\x045a'jV[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` _T`@Q\x90\x81R\xF3[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W` `@Qb\x0FB@\x81R\xF3[4a\x06\xD0W` 6`\x03\x19\x01\x12a\x06\xD0W`\x045\x80_R`\x04` R`\x06`@_ \x01T\x15a\x0B\0W_\x81\x81R`\x04` R`@\x90 `\x07\x01T`\x01`\x01`\xA0\x1B\x03\x16a$qWa\x07\x96\x90a$=03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a.\xC2V[_\x81\x81R`\x04` R`@\x90 `\x07\x81\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x163\x90\x81\x17\x90\x91UB`\x05\x90\x92\x01\x91\x90\x91U\x90a/AV[c\x0C\x8D\x9E\xAB`\xE3\x1B_R`\x04_\xFD[4a\x06\xD0W_6`\x03\x19\x01\x12a\x06\xD0W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[\x90`\x01\x82\x81\x1C\x92\x16\x80\x15a$\xEFW[` \x83\x10\x14a$\xDBWV[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x91`\x7F\x16\x91a$\xD0V[`\xE0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[`\xA0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[a\x01@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a\x06uW`@RV[\x90`@Q\x91\x82_\x82T\x92a%\x9A\x84a$\xC1V[\x80\x84R\x93`\x01\x81\x16\x90\x81\x15a&\x05WP`\x01\x14a%\xC1W[Pa%\xBF\x92P\x03\x83a%fV[V[\x90P_\x92\x91\x92R` _ \x90_\x91[\x81\x83\x10a%\xE9WPP\x90` a%\xBF\x92\x82\x01\x01_a%\xB2V[` \x91\x93P\x80`\x01\x91T\x83\x85\x89\x01\x01R\x01\x91\x01\x90\x91\x84\x92a%\xD0V[\x90P` \x92Pa%\xBF\x94\x91P`\xFF\x19\x16\x82\x84\x01R\x15\x15`\x05\x1B\x82\x01\x01_a%\xB2V[\x90`\x02\x82\x10\x15a\x05\x96WRV[\x80Q\x80\x83R` \x92\x91\x81\x90\x84\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[5\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x06\xD0WV[`\xA0\x90`\x03\x19\x01\x12a\x06\xD0W`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x90`$5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x90`D5\x90`d5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x90`\x845\x90V[\x81\x81\x10a&\xC9WPPV[_\x81U`\x01\x01a&\xBEV[\x81\x81\x02\x92\x91\x81\x15\x91\x84\x04\x14\x17\x15a\x06\xF5WV[`\x07_\x91\x82\x81U`\x01\x81\x01a&\xFC\x81Ta$\xC1V[\x90\x81a''W[PP\x82`\x02\x82\x01U\x82`\x03\x82\x01U\x82`\x04\x82\x01U\x82`\x05\x82\x01U\x82`\x06\x82\x01U\x01UV[\x81`\x1F\x86\x93\x11`\x01\x14a'>WPU[_\x80a'\x03V[\x81\x83R` \x83 a'Z\x91`\x1F\x01`\x05\x1C\x81\x01\x90`\x01\x01a&\xBEV[\x80\x82R\x81` \x81 \x91UUa'7V[\x80_R`\x04` R`@_ \x90`\x06\x82\x01T\x80\x15a\x0B\0WB\x10a\x14OW_\x91`\x07\x81\x01\x92\x83T`\xFF\x81`\xA0\x1C\x16a)\xB3WPa(\xD4\x92\x93_\x92_\x90_\x92`\xFF\x81T`\xA8\x1C\x16a)\x84W[\x80T`\x01`\x01`\xA0\x1B\x03\x81\x16\x90\x81a(\xE7W[PPT\x94`\x01\x80`\xA0\x1B\x03`\x02\x83\x01T\x16\x91`\x03`\x01\x80`\xA0\x1B\x03\x91\x01T\x16`@Q\x92_\x84R`\xFF\x80\x89`\xA8\x1C\x16\x15\x15\x98\x89` \x87\x01R`\xB0\x1C\x16\x15\x15\x80`@\x86\x01R\x81``\x86\x01R\x82`\x80\x86\x01R\x83`\xA0\x86\x01R`\x01\x80`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x94\x85`\xC0\x82\x01R\x86`\xE0\x82\x01R\x87a\x01\0\x82\x01R\x88a\x01 \x82\x01R\x8B_Q` a<q_9_Q\x90_Ra\x01@3\x93\xA3`@Q\x98\x8B` \x8B\x01R3`@\x8B\x01R_``\x8B\x01R`\x80\x8A\x01R`\xA0\x89\x01R`\xC0\x88\x01R`\xE0\x87\x01Ra\x01\0\x86\x01Ra\x01 \x85\x01Ra\x01@\x84\x01Ra\x01`\x83\x01Ra\x01\x80\x82\x01Ra\x01\x80\x81Ra(\xCFa\x01\xA0\x82a%fV[a:\xD2V[_R`\x04` Ra%\xBF`@_ a&\xE7V[\x91\x94\x92\x93\x90\x92\x91`\xA8\x1C`\xFF\x16\x15a)LWPPPb\x07\xA1 \x90\x81\x92a)E\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a)13\x82a2\xCAV[`\x02\x84\x01T`\x01`\x01`\xA0\x1B\x03\x16\x90a2\xCAV[_\x80a'\xC8V[\x92\x91\x94P\x92a)\x7Fb\x0FB@\x95\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a3eV[a)EV[`\x04\x82\x01T`\x03\x83\x01T`\x02\x84\x01T\x91\x97Pa)\xAE\x91\x88\x91`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16a3\xD4V[a'\xB5V[`\xFF\x81`\xA8\x1C\x16\x90\x81a+KW[Pa+<W\x83a(\xD4\x93\x94T`\xFF\x81`\xA8\x1C\x16\x15\x80a+*W[a*\xEBW[PT\x91`\x01\x80`\xA0\x1B\x03`\x02\x82\x01T\x16\x90`\x03`\x01\x80`\xA0\x1B\x03\x91\x01T\x16`@Q\x91`\x01\x83R`\xFF\x80\x86`\xA8\x1C\x16\x15\x15\x95\x86` \x86\x01R`\xB0\x1C\x16\x15\x15\x80`@\x85\x01R\x81``\x85\x01R\x82`\x80\x85\x01R_`\xA0\x85\x01R`\x01\x80`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x93\x84`\xC0\x82\x01R_`\xE0\x82\x01R_a\x01\0\x82\x01R\x85a\x01 \x82\x01R\x88_Q` a<q_9_Q\x90_Ra\x01@3\x93\xA3`@Q\x95\x88` \x88\x01R3`@\x88\x01R`\x01``\x88\x01R`\x80\x87\x01R`\xA0\x86\x01R`\xC0\x85\x01R`\xE0\x84\x01R_a\x01\0\x84\x01Ra\x01 \x83\x01R_a\x01@\x83\x01R_a\x01`\x83\x01Ra\x01\x80\x82\x01Ra\x01\x80\x81Ra(\xCFa\x01\xA0\x82a%fV[b\x0FB@\x92Pa+$\x90`\x01`\x01`\xA0\x1B\x03\x16\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a3eV[_a)\xE0V[P`\x01`\x01`\xA0\x1B\x03\x81\x16\x15\x15a)\xDBV[PPa+H\x91Pa0\x87V[PV[`\xFF\x91P`\xB0\x1C\x16\x15_a)\xC1V[\x905`\x1E\x19\x826\x03\x01\x81\x12\x15a\x06\xD0W\x01` \x815\x91\x01\x91`\x01`\x01`@\x1B\x03\x82\x11a\x06\xD0W\x816\x03\x83\x13a\x06\xD0WV[\x90\x80` \x93\x92\x81\x84R\x84\x84\x017_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[5`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x03a\x06\xD0W\x90V[`\x01`\x01`@\x1B\x03\x81\x11a\x06uW`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x92\x91\x92a+\xE6\x82a+\xBFV[\x91a+\xF4`@Q\x93\x84a%fV[\x82\x94\x81\x84R\x81\x83\x01\x11a\x06\xD0W\x82\x81` \x93\x84_\x96\x017\x01\x01RV[Q\x90j\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x82\x16\x82\x03a\x06\xD0WV[\x81`\x1F\x82\x01\x12\x15a\x06\xD0W\x80Q\x90a,@\x82a+\xBFV[\x92a,N`@Q\x94\x85a%fV[\x82\x84R` \x83\x83\x01\x01\x11a\x06\xD0W\x81_\x92` \x80\x93\x01\x83\x86\x01^\x83\x01\x01R\x90V[Q\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x06\xD0WV[\x91\x90\x82\x01\x80\x92\x11a\x06\xF5WV[b\x0FB@a,\xA4a,\xAE\x92`\x02T\x90a&\xD4V[\x04`\x03T\x90a,\x83V[\x90V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x92\x83\x16` \x82\x01\x90\x81R\x93\x90\x92\x16\x90\x82\x01Ra-\"\x92\x91a\x01\x8F\x91a,\xE3\x81``\x81\x01\x85V[Q\x90 \x94`@Q\x94\x85\x93` \x85\x01\x97\x88\x92\x90\x91`t\x94\x92\x84R` \x84\x01Rk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x90``\x1B\x16`@\x83\x01R`T\x82\x01R\x01\x90V[Q\x90 \x90V[\x91\x90\x82\x03\x91\x82\x11a\x06\xF5WV[`\x01`\x01`@\x1B\x03\x81\x11a\x06uW`\x05\x1B` \x01\x90V[`@Q\x90a-[` \x83a%fV[_\x82R\x81_\x80[\x81\x81\x10a-nWPPPV[`@Q\x90``\x82\x01\x91\x80\x83\x10`\x01`\x01`@\x1B\x03\x84\x11\x17a\x06uW` \x92`@R_\x81R_\x83\x82\x01R```@\x82\x01R\x82\x82\x86\x01\x01R\x01a-bV[\x91\x90\x91` \x81Ra\x01`\x81\x01\x90\x83Q` \x82\x01R`\x01\x80`\xA0\x1B\x03` \x85\x01Q\x16`@\x82\x01R`@\x84\x01Q\x15\x15``\x82\x01R``\x84\x01Q`\x80\x82\x01R`\x80\x84\x01Q`\xA0\x82\x01R`\xA0\x84\x01Q`\xC0\x82\x01R`\x01\x80`\xA0\x1B\x03`\xC0\x85\x01Q\x16`\xE0\x82\x01R`\x01\x80`\xA0\x1B\x03`\xE0\x85\x01Q\x16a\x01\0\x82\x01Ra\x01\0\x84\x01Q\x91a\x01@a\x01 \x83\x01R\x82Q\x80\x91Ra\x01\x80\x82\x01\x90` a\x01\x80\x82`\x05\x1B\x85\x01\x01\x94\x01\x91_\x90[\x82\x82\x10a.tWPPPPa\x01 a,\xAE\x93\x94\x01Q\x90a\x01@`\x1F\x19\x82\x85\x03\x01\x91\x01Ra&4V[\x90\x91\x92\x94` \x80a.\xB4`\x01\x93a\x01\x7F\x19\x89\x82\x03\x01\x86R```@\x8BQ\x87\x80`\xA0\x1B\x03\x81Q\x16\x84R\x85\x81\x01Q\x86\x85\x01R\x01Q\x91\x81`@\x82\x01R\x01\x90a&4V[\x97\x01\x92\x01\x92\x01\x90\x92\x91a.LV[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a/2W`@\x80Qb\x0FB@``\x90\x81R`\x01`\x01`\xA0\x1B\x03\x90\x95\x16\x90\x91R\x92\x1B`,Rc#\xB8r\xDD``\x1B`\x0CR` _`d`\x1C\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a/!W[PP_``R`@RV[;\x15=\x17\x10\x15a#=W_\x80a/\x16V[PPPb\x0FB@4\x03a#TWV[\x90`\x01\x80`\xA0\x1B\x03\x16\x80\x82\x7F\xBC?{~w\xA3\x95\xC1V\xC2M\xB8\xA8\xA7\x85\x02\t\xB2\xDFq\xA2V\x12\x92\xEE\xA2!\xE3+\xF5\xD4g` `@Qb\x0FB@\x81R\xA3`@Q\x91` \x83\x01R`@\x82\x01Rb\x0FB@``\x82\x01R``\x81Ra/\x9F`\x80\x82a%fV[`\x01\x80T\x01\x80`\x01U_T\x90` _`@Q\x82\x81\x01\x90\x85\x82R\x84`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F\xBC?{~w\xA3\x95\xC1V\xC2M\xB8\xA8\xA7\x85\x02\t\xB2\xDFq\xA2V\x12\x92\xEE\xA2!\xE3+\xF5\xD4g`\xA0\x82\x01Ra0\x16`\xC0\x82\x89Q\x80\x88\x8C\x01\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7F\xBC?{~w\xA3\x95\xC1V\xC2M\xB8\xA8\xA7\x85\x02\t\xB2\xDFq\xA2V\x12\x92\xEE\xA2!\xE3+\xF5\xD4g\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x03\x90\xA4V[\x80_R`\x04` R`@_ `\x07\x81\x01\x90\x81T`\xFF\x81`\xB0\x1C\x16\x80\x15a2\xBCW[\x80\x15a2\xAEW[a2\xA6W`\xFF`\xB0\x1B\x19\x81\x16`\x01`\xB0\x1B\x17\x83U`\x03\x82\x01\x80T`\x04\x90\x93\x01\x80T`@\x80Q`\x01`\x01`\xA0\x1B\x03\x96\x87\x16\x80\x82R` \x82\x01\x84\x90R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x80\x89\x16\x93\x83\x01\x84\x90Rb\x0FB@``\x84\x01R\x94\x97\x95\x96\x95\x90\x95\x16\x94\x91\x92\x91\x90\x85\x90\x8A\x90\x7F\x16\xBF\xB6J\xE7\x0B\x8A\x9B\xBD\xA2\x8D\xEB'\xA1\xCB\xC5\xEC>d\x97H\x17\x144L\"\x1BF\xC0w\x7F5\x90`\x80\x90\xA3`@Q\x94` \x86\x01\x99\x8AR`@\x86\x01R``\x85\x01R`\x80\x84\x01R`\xA0\x83\x01Rb\x0FB@`\xC0\x83\x01R`\xC0\x82Ra1\x8A`\xE0\x83a%fV[`\x01\x80T\x01\x91\x82`\x01U` _\x80T\x80\x99a2\x01`\xC0`@Q\x80\x93\x87\x82\x01\x95\x86R\x8A`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x16\xBF\xB6J\xE7\x0B\x8A\x9B\xBD\xA2\x8D\xEB'\xA1\xCB\xC5\xEC>d\x97H\x17\x144L\"\x1BF\xC0w\x7F5`\xA0\x83\x01R\x88Q\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBWa2\xA1\x96a2\x89\x93_Q` a<\xB1_9_Q\x90_Ra2u_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x16\xBF\xB6J\xE7\x0B\x8A\x9B\xBD\xA2\x8D\xEB'\xA1\xCB\xC5\xEC>d\x97H\x17\x144L\"\x1BF\xC0w\x7F5\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x03\x90\xA4\x84T`\x01`\x01`\xA0\x1B\x03\x16\x90a3eV[T\x91T\x90T\x91`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16a3\xD4V[`\x01\x90V[PPPP_\x90V[P`\xFF\x81`\xA8\x1C\x16\x15a0\xAFV[P`\xFF\x81`\xA0\x1C\x16\x15a0\xA8V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a38W`\x01`\x01`\xA0\x1B\x03\x16`\x14Rb\x07\xA1 `4Rc\xA9\x05\x9C\xBB``\x1B_\x90\x81R` \x90`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a3\x1AW[PP_`4RV[;\x15=\x17\x10\x15a3+W_\x80a3\x12V[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[_\x91P8\x90\x82\x90\x81\x90b\x07\xA1 \x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a3XWV[c\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a3\xB4W`\x01`\x01`\xA0\x1B\x03\x16`\x14Rb\x0FB@`4Rc\xA9\x05\x9C\xBB``\x1B_\x90\x81R` \x90`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a3\x1AWPP_`4RV[_\x91P8\x90\x82\x90\x81\x90b\x0FB@\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a3XWV[\x91\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a4 W`\x01`\x01`\xA0\x1B\x03\x16`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B_\x90\x81R` \x90`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a3\x1AWPP_`4RV[_\x92P8\x91\x83\x91\x82\x91\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a3XWV[\x95\x90\x91a5\x0E\x95\x94a5\0\x94\x98\x93`\x01\x80`\xA0\x1B\x03\x16\x95\x86\x89\x7Fo\x81\xB8\xAD\x07\x80\xA0\xFE\xBChz:s\xB1\x81C7\"\xB4\xBE0\xF7\xF0\xA0$\x16\x9FQa&r\x87`\xFF`@Q\x96\x16\x9C\x8D\x87R`\x01\x80`\xA0\x1B\x03\x16\x93\x84` \x88\x01R\x85`@\x88\x01R`\x01\x80`\xA0\x1B\x03\x16\x95\x86``\x82\x01R\x87`\x80\x82\x01R`\xC0`\xA0\x82\x01R\x80a4\xC0`\xC0\x82\x01\x8Ba&4V[\x03\x90\xA3`@Q\x99\x8A\x97` \x89\x01\x9A\x8BR`@\x89\x01R``\x88\x01R`\x80\x87\x01R`\xA0\x86\x01R`\xC0\x85\x01R`\xE0\x84\x01Ra\x01\0\x80\x84\x01Ra\x01 \x83\x01\x90a&4V[\x03`\x1F\x19\x81\x01\x84R\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa5\x83`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7Fo\x81\xB8\xAD\x07\x80\xA0\xFE\xBChz:s\xB1\x81C7\"\xB4\xBE0\xF7\xF0\xA0$\x16\x9FQa&r\x87`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7Fo\x81\xB8\xAD\x07\x80\xA0\xFE\xBChz:s\xB1\x81C7\"\xB4\xBE0\xF7\xF0\xA0$\x16\x9FQa&r\x87\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x91\x92\x90`\x01\x80`\xA0\x1B\x03\x16\x92\x83\x83\x7F\x05Dt\x1F\xF6\xF2p\x80G\x13\x8C\x8F:h\xAB\xB9\x94\xE6(fm\xBAx_h_\xF1\x03Rt\xF9\xFB`@\x80Q\x94`\x01\x80`\xA0\x1B\x03\x16\x94\x85\x81R\x86` \x82\x01R\xA3`@Q\x93` \x85\x01\x93\x84R`@\x85\x01R``\x84\x01R`\x80\x83\x01R`\x80\x82Ra6_`\xA0\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa6\xD4`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x05Dt\x1F\xF6\xF2p\x80G\x13\x8C\x8F:h\xAB\xB9\x94\xE6(fm\xBAx_h_\xF1\x03Rt\xF9\xFB`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x05Dt\x1F\xF6\xF2p\x80G\x13\x8C\x8F:h\xAB\xB9\x94\xE6(fm\xBAx_h_\xF1\x03Rt\xF9\xFB\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x80Q` \x90\x91\x01Q`\x01`\x01`\xE0\x1B\x03\x19\x81\x16\x92\x91\x90`\x04\x82\x10a7bWPPV[`\x01`\x01`\xE0\x1B\x03\x19`\x04\x92\x90\x92\x03`\x03\x1B\x82\x90\x1B\x16\x16\x91PV[c\x8Bx\xC6\xD8\x19T3\x03a7\x8CWV[c\x82\xB4)\0_R`\x04`\x1C\xFD[`@\x80Q\x85\x81R`\x01`\x01`\xA0\x1B\x03\x80\x88\x16` \x83\x01R\x91\x81\x01\x88\x90R\x92\x81\x16\x96\x91\x95\x91\x94\x91\x93\x91\x92\x91\x16\x90\x81\x90\x87\x90\x87\x90\x7F\x11\x03\x9D\x94\x8EX\xAA\xBF\x98.\t\xEA\xB3\xF7\xCEm\xB7\xBFr\xAD\xD1\xD0\xB0Nc\xF0i~\xAC\x16\x02K\x90``\x90\xA4`@Q\x95` \x87\x01\x95\x86R`@\x87\x01R``\x86\x01R`\x80\x85\x01R`\x01\x80`\xA0\x1B\x03\x16`\xA0\x84\x01R`\xC0\x83\x01R`\xC0\x82Ra8,`\xE0\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa8\xA1`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\x11\x03\x9D\x94\x8EX\xAA\xBF\x98.\t\xEA\xB3\xF7\xCEm\xB7\xBFr\xAD\xD1\xD0\xB0Nc\xF0i~\xAC\x16\x02K`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7F\x11\x03\x9D\x94\x8EX\xAA\xBF\x98.\t\xEA\xB3\xF7\xCEm\xB7\xBFr\xAD\xD1\xD0\xB0Nc\xF0i~\xAC\x16\x02K\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x91\x92\x90\x92\x82\x7F\xC8S\xB9\xFB\xC6&W\x08\xCF\xC4s\xEF\xD1\xCE)\xB1\x9A6\x16\xB3\xED\xCC\xAE\xAFq\xA4\xA6\xB7x\xCB\x01\x0E```@Q\x87\x81R\x84` \x82\x01R\x85`@\x82\x01R\xA2`@Q\x93` \x85\x01\x93\x84R`@\x85\x01R``\x84\x01R`\x80\x83\x01R`\x80\x82Ra9q`\xA0\x83a%fV[`\x01\x80T\x01\x80`\x01U` _\x80T\x93`@Qa9\xE6`\xC0\x82\x86\x81\x01\x94\x89\x86R\x88`@\x83\x01RC``\x83\x01RB`\x80\x83\x01R\x7F\xC8S\xB9\xFB\xC6&W\x08\xCF\xC4s\xEF\xD1\xCE)\xB1\x9A6\x16\xB3\xED\xCC\xAE\xAFq\xA4\xA6\xB7x\xCB\x01\x0E`\xA0\x83\x01R\x8AQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91\x7F\xC8S\xB9\xFB\xC6&W\x08\xCF\xC4s\xEF\xD1\xCE)\xB1\x9A6\x16\xB3\xED\xCC\xAE\xAFq\xA4\xA6\xB7x\xCB\x01\x0E\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15a:\xCCW`@Qcp\xA0\x821`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA\x90\x81\x15a\x06\xDBW_\x91a:\x9DWP\x90V[\x90P` \x81=` \x11a:\xC4W[\x81a:\xB8` \x93\x83a%fV[\x81\x01\x03\x12a\x06\xD0WQ\x90V[=\x91Pa:\xABV[\x90P1\x90V[`\x01\x80T\x01\x80`\x01U_T\x90` _`@Q\x82\x81\x01\x90\x85\x82R\x84`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R_Q` a<q_9_Q\x90_R`\xA0\x82\x01Ra;6`\xC0\x82\x89Q\x80\x88\x8C\x01\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91_Q` a<q_9_Q\x90_R\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[`\x01\x80T\x01\x80`\x01U_T\x90` _`@Q\x82\x81\x01\x90\x85\x82R\x84`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R_Q` a<\x91_9_Q\x90_R`\xA0\x82\x01Ra;\xF3`\xC0\x82\x89Q\x80\x88\x8C\x01\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a%fV[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x06\xDBW_Q` a<\xB1_9_Q\x90_Ra0\x82_Q\x94\x85_U`@Q\x91\x82\x91_Q` a<\x91_9_Q\x90_R\x83R`@` \x84\x01R`@\x83\x01\x90a&4V[\x90`D\x82Q\x03a\x1A\xBFW`$\x82\x01Q`D\x90\x92\x01Q`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90V\xFEm\xB2\xDA\x0Ff\x1DY\xD5\xA9\xC7g\xB6\xBAa\xA9\xC1\x92vZj\xAB\x95.^S\xEAw\x17S2\xF1=\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0x\x16\x0F\x0B\x1B+2\xB5*\0v\xD8\xF0\xF7\x08\x88h{\xA7\x02\xA4\xD9\x93\xD5Z\xC8\xD92}W\xA1'\xA1dsolcC\0\x08\x1B\0\n",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IntentType(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<IntentType> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        impl IntentType {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from_underlying(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into_underlying(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl From<u8> for IntentType {
            fn from(value: u8) -> Self {
                Self::from_underlying(value)
            }
        }
        #[automatically_derived]
        impl From<IntentType> for u8 {
            fn from(value: IntentType) -> Self {
                value.into_underlying()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for IntentType {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for IntentType {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Intent { IntentType intentType; bytes intentSpecs; address refundBeneficiary; address token; uint256 amount; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Intent {
        #[allow(missing_docs)]
        pub intentType: <IntentType as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub intentSpecs: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub refundBeneficiary: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            IntentType,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <IntentType as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Intent> for UnderlyingRustTuple<'_> {
            fn from(value: Intent) -> Self {
                (
                    value.intentType,
                    value.intentSpecs,
                    value.refundBeneficiary,
                    value.token,
                    value.amount,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Intent {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    intentType: tuple.0,
                    intentSpecs: tuple.1,
                    refundBeneficiary: tuple.2,
                    token: tuple.3,
                    amount: tuple.4,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Intent {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Intent {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <IntentType as alloy_sol_types::SolType>::tokenize(&self.intentType),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.intentSpecs,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.refundBeneficiary,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Intent {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Intent {
            const NAME: &'static str = "Intent";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Intent(uint8 intentType,bytes intentSpecs,address refundBeneficiary,address token,uint256 amount)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <IntentType as alloy_sol_types::SolType>::eip712_data_word(
                            &self.intentType,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.intentSpecs,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.refundBeneficiary,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.token,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Intent {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <IntentType as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.intentType,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.intentSpecs,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.refundBeneficiary,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.token,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <IntentType as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.intentType,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.intentSpecs,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.refundBeneficiary,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.token,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyClaimed()` and selector `0x646cf558`.
```solidity
error AlreadyClaimed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyClaimed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyClaimed> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyClaimed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyClaimed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyClaimed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyClaimed()";
            const SELECTOR: [u8; 4] = [100u8, 108u8, 245u8, 88u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyExists()` and selector `0x23369fa6`.
```solidity
error AlreadyExists();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyExists;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyExists> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyExists) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyExists {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyExists {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyExists()";
            const SELECTOR: [u8; 4] = [35u8, 54u8, 159u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyFunded()` and selector `0x5adf6387`.
```solidity
error AlreadyFunded();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyFunded;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyFunded> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyFunded) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyFunded {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyFunded {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyFunded()";
            const SELECTOR: [u8; 4] = [90u8, 223u8, 99u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyInitialized()` and selector `0x0dc149f0`.
```solidity
error AlreadyInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyInitialized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyInitialized()";
            const SELECTOR: [u8; 4] = [13u8, 193u8, 73u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadySolved()` and selector `0x19835547`.
```solidity
error AlreadySolved();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadySolved;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadySolved> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadySolved) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadySolved {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadySolved {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadySolved()";
            const SELECTOR: [u8; 4] = [25u8, 131u8, 85u8, 71u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `IncorrectPullAmount()` and selector `0xb2c982ae`.
```solidity
error IncorrectPullAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IncorrectPullAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IncorrectPullAmount> for UnderlyingRustTuple<'_> {
            fn from(value: IncorrectPullAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IncorrectPullAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IncorrectPullAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IncorrectPullAmount()";
            const SELECTOR: [u8; 4] = [178u8, 201u8, 130u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientETH()` and selector `0x6a12f104`.
```solidity
error InsufficientETH();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientETH;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientETH> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientETH) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientETH {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientETH {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientETH()";
            const SELECTOR: [u8; 4] = [106u8, 18u8, 241u8, 4u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `IntentNotFound()` and selector `0x61ae6483`.
```solidity
error IntentNotFound();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct IntentNotFound;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<IntentNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: IntentNotFound) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for IntentNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for IntentNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "IntentNotFound()";
            const SELECTOR: [u8; 4] = [97u8, 174u8, 100u8, 131u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidDeadline()` and selector `0x769d11e4`.
```solidity
error InvalidDeadline();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidDeadline;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidDeadline> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidDeadline) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidDeadline {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidDeadline {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidDeadline()";
            const SELECTOR: [u8; 4] = [118u8, 157u8, 17u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InvalidReceiverAmount()` and selector `0x4c7d100e`.
```solidity
error InvalidReceiverAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidReceiverAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidReceiverAmount> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidReceiverAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidReceiverAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidReceiverAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidReceiverAmount()";
            const SELECTOR: [u8; 4] = [76u8, 125u8, 16u8, 14u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NewOwnerIsZeroAddress()` and selector `0x7448fbae`.
```solidity
error NewOwnerIsZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NewOwnerIsZeroAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NewOwnerIsZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: NewOwnerIsZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NewOwnerIsZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NewOwnerIsZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NewOwnerIsZeroAddress()";
            const SELECTOR: [u8; 4] = [116u8, 72u8, 251u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotATrc20Transfer()` and selector `0x2456e1ec`.
```solidity
error NotATrc20Transfer();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotATrc20Transfer;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotATrc20Transfer> for UnderlyingRustTuple<'_> {
            fn from(value: NotATrc20Transfer) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotATrc20Transfer {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotATrc20Transfer {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotATrc20Transfer()";
            const SELECTOR: [u8; 4] = [36u8, 86u8, 225u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotClaimed()` and selector `0xb72a2522`.
```solidity
error NotClaimed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotClaimed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotClaimed> for UnderlyingRustTuple<'_> {
            fn from(value: NotClaimed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotClaimed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotClaimed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotClaimed()";
            const SELECTOR: [u8; 4] = [183u8, 42u8, 37u8, 34u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotExpiredYet()` and selector `0xa8058ea9`.
```solidity
error NotExpiredYet();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotExpiredYet;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotExpiredYet> for UnderlyingRustTuple<'_> {
            fn from(value: NotExpiredYet) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotExpiredYet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotExpiredYet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotExpiredYet()";
            const SELECTOR: [u8; 4] = [168u8, 5u8, 142u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NotSolver()` and selector `0xc139eabd`.
```solidity
error NotSolver();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotSolver;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotSolver> for UnderlyingRustTuple<'_> {
            fn from(value: NotSolver) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotSolver {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotSolver {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotSolver()";
            const SELECTOR: [u8; 4] = [193u8, 57u8, 234u8, 189u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NothingToSettle()` and selector `0x618104e8`.
```solidity
error NothingToSettle();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NothingToSettle;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NothingToSettle> for UnderlyingRustTuple<'_> {
            fn from(value: NothingToSettle) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NothingToSettle {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NothingToSettle {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NothingToSettle()";
            const SELECTOR: [u8; 4] = [97u8, 129u8, 4u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Reentrancy()` and selector `0xab143c06`.
```solidity
error Reentrancy();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Reentrancy;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Reentrancy> for UnderlyingRustTuple<'_> {
            fn from(value: Reentrancy) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Reentrancy {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Reentrancy {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Reentrancy()";
            const SELECTOR: [u8; 4] = [171u8, 20u8, 60u8, 6u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TronInvalidCalldataLength()` and selector `0x12799503`.
```solidity
error TronInvalidCalldataLength();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TronInvalidCalldataLength;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TronInvalidCalldataLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: TronInvalidCalldataLength) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for TronInvalidCalldataLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TronInvalidCalldataLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TronInvalidCalldataLength()";
            const SELECTOR: [u8; 4] = [18u8, 121u8, 149u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `TronInvalidTrc20DataLength()` and selector `0x9ac60c2d`.
```solidity
error TronInvalidTrc20DataLength();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TronInvalidTrc20DataLength;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TronInvalidTrc20DataLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: TronInvalidTrc20DataLength) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for TronInvalidTrc20DataLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TronInvalidTrc20DataLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TronInvalidTrc20DataLength()";
            const SELECTOR: [u8; 4] = [154u8, 198u8, 12u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Unauthorized()` and selector `0x82b42900`.
```solidity
error Unauthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Unauthorized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Unauthorized> for UnderlyingRustTuple<'_> {
            fn from(value: Unauthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Unauthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Unauthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Unauthorized()";
            const SELECTOR: [u8; 4] = [130u8, 180u8, 41u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `WrongTxProps()` and selector `0xd197cb05`.
```solidity
error WrongTxProps();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct WrongTxProps;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<WrongTxProps> for UnderlyingRustTuple<'_> {
            fn from(value: WrongTxProps) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for WrongTxProps {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for WrongTxProps {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "WrongTxProps()";
            const SELECTOR: [u8; 4] = [209u8, 151u8, 203u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EventAppended(uint256,bytes32,bytes32,bytes32,bytes)` and selector `0x78160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a127`.
```solidity
event EventAppended(uint256 indexed eventSeq, bytes32 indexed prevTip, bytes32 indexed newTip, bytes32 eventSignature, bytes abiEncodedEventData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EventAppended {
        #[allow(missing_docs)]
        pub eventSeq: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub prevTip: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newTip: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub eventSignature: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub abiEncodedEventData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EventAppended {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EventAppended(uint256,bytes32,bytes32,bytes32,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                120u8, 22u8, 15u8, 11u8, 27u8, 43u8, 50u8, 181u8, 42u8, 0u8, 118u8,
                216u8, 240u8, 247u8, 8u8, 136u8, 104u8, 123u8, 167u8, 2u8, 164u8, 217u8,
                147u8, 213u8, 90u8, 200u8, 217u8, 50u8, 125u8, 87u8, 161u8, 39u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    eventSeq: topics.1,
                    prevTip: topics.2,
                    newTip: topics.3,
                    eventSignature: data.0,
                    abiEncodedEventData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eventSignature),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.abiEncodedEventData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.eventSeq.clone(),
                    self.prevTip.clone(),
                    self.newTip.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.eventSeq);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.prevTip);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newTip);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EventAppended {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EventAppended> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EventAppended) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `IntentClaimed(bytes32,address,uint256)` and selector `0xbc3f7b7e77a395c156c24db8a8a7850209b2df71a2561292eea221e32bf5d467`.
```solidity
event IntentClaimed(bytes32 indexed id, address indexed solver, uint256 depositAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct IntentClaimed {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub solver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub depositAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for IntentClaimed {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "IntentClaimed(bytes32,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8, 63u8, 123u8, 126u8, 119u8, 163u8, 149u8, 193u8, 86u8, 194u8, 77u8,
                184u8, 168u8, 167u8, 133u8, 2u8, 9u8, 178u8, 223u8, 113u8, 162u8, 86u8,
                18u8, 146u8, 238u8, 162u8, 33u8, 227u8, 43u8, 245u8, 212u8, 103u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    solver: topics.2,
                    depositAmount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.depositAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone(), self.solver.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.solver,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for IntentClaimed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&IntentClaimed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &IntentClaimed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `IntentClosed(bytes32,address,bool,bool,bool,address,address,uint256,address,uint256,uint256,uint256)` and selector `0x6db2da0f661d59d5a9c767b6ba61a9c192765a6aab952e5e53ea77175332f13d`.
```solidity
event IntentClosed(bytes32 indexed id, address indexed caller, bool solved, bool funded, bool settled, address refundBeneficiary, address escrowToken, uint256 escrowRefunded, address depositToken, uint256 depositToCaller, uint256 depositToRefundBeneficiary, uint256 depositToSolver);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct IntentClosed {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub solved: bool,
        #[allow(missing_docs)]
        pub funded: bool,
        #[allow(missing_docs)]
        pub settled: bool,
        #[allow(missing_docs)]
        pub refundBeneficiary: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub escrowToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub escrowRefunded: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub depositToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub depositToCaller: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub depositToRefundBeneficiary: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub depositToSolver: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for IntentClosed {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "IntentClosed(bytes32,address,bool,bool,bool,address,address,uint256,address,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                109u8, 178u8, 218u8, 15u8, 102u8, 29u8, 89u8, 213u8, 169u8, 199u8, 103u8,
                182u8, 186u8, 97u8, 169u8, 193u8, 146u8, 118u8, 90u8, 106u8, 171u8,
                149u8, 46u8, 94u8, 83u8, 234u8, 119u8, 23u8, 83u8, 50u8, 241u8, 61u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    caller: topics.2,
                    solved: data.0,
                    funded: data.1,
                    settled: data.2,
                    refundBeneficiary: data.3,
                    escrowToken: data.4,
                    escrowRefunded: data.5,
                    depositToken: data.6,
                    depositToCaller: data.7,
                    depositToRefundBeneficiary: data.8,
                    depositToSolver: data.9,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.solved,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.funded,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.settled,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.refundBeneficiary,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.escrowToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.escrowRefunded),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.depositToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.depositToCaller),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.depositToRefundBeneficiary,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.depositToSolver),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone(), self.caller.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for IntentClosed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&IntentClosed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &IntentClosed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `IntentCreated(bytes32,address,uint8,address,uint256,address,uint256,bytes)` and selector `0x6f81b8ad0780a0febc687a3a73b181433722b4be30f7f0a024169f5161267287`.
```solidity
event IntentCreated(bytes32 indexed id, address indexed creator, uint8 intentType, address token, uint256 amount, address refundBeneficiary, uint256 deadline, bytes intentSpecs);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct IntentCreated {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub creator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub intentType: u8,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub refundBeneficiary: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub intentSpecs: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for IntentCreated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "IntentCreated(bytes32,address,uint8,address,uint256,address,uint256,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                111u8, 129u8, 184u8, 173u8, 7u8, 128u8, 160u8, 254u8, 188u8, 104u8,
                122u8, 58u8, 115u8, 177u8, 129u8, 67u8, 55u8, 34u8, 180u8, 190u8, 48u8,
                247u8, 240u8, 160u8, 36u8, 22u8, 159u8, 81u8, 97u8, 38u8, 114u8, 135u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    creator: topics.2,
                    intentType: data.0,
                    token: data.1,
                    amount: data.2,
                    refundBeneficiary: data.3,
                    deadline: data.4,
                    intentSpecs: data.5,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.intentType),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.refundBeneficiary,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.intentSpecs,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone(), self.creator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.creator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for IntentCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&IntentCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &IntentCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `IntentFunded(bytes32,address,address,uint256)` and selector `0x0544741ff6f2708047138c8f3a68abb994e628666dba785f685ff1035274f9fb`.
```solidity
event IntentFunded(bytes32 indexed id, address indexed funder, address token, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct IntentFunded {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub funder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for IntentFunded {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "IntentFunded(bytes32,address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                5u8, 68u8, 116u8, 31u8, 246u8, 242u8, 112u8, 128u8, 71u8, 19u8, 140u8,
                143u8, 58u8, 104u8, 171u8, 185u8, 148u8, 230u8, 40u8, 102u8, 109u8,
                186u8, 120u8, 95u8, 104u8, 95u8, 241u8, 3u8, 82u8, 116u8, 249u8, 251u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    funder: topics.2,
                    token: data.0,
                    amount: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone(), self.funder.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.funder,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for IntentFunded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&IntentFunded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &IntentFunded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `IntentSettled(bytes32,address,address,uint256,address,uint256)` and selector `0x16bfb64ae70b8a9bbda28deb27a1cbc5ec3e6497481714344c221b46c0777f35`.
```solidity
event IntentSettled(bytes32 indexed id, address indexed solver, address escrowToken, uint256 escrowAmount, address depositToken, uint256 depositAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct IntentSettled {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub solver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub escrowToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub escrowAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub depositToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub depositAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for IntentSettled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "IntentSettled(bytes32,address,address,uint256,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                22u8, 191u8, 182u8, 74u8, 231u8, 11u8, 138u8, 155u8, 189u8, 162u8, 141u8,
                235u8, 39u8, 161u8, 203u8, 197u8, 236u8, 62u8, 100u8, 151u8, 72u8, 23u8,
                20u8, 52u8, 76u8, 34u8, 27u8, 70u8, 192u8, 119u8, 127u8, 53u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    solver: topics.2,
                    escrowToken: data.0,
                    escrowAmount: data.1,
                    depositToken: data.2,
                    depositAmount: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.escrowToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.escrowAmount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.depositToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.depositAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone(), self.solver.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.solver,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for IntentSettled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&IntentSettled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &IntentSettled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `IntentSolved(bytes32,address,bytes32,uint256)` and selector `0xfa797585c9827d59a7694ef382241f1a03ced6a1a2b4353b35939abc4d04b286`.
```solidity
event IntentSolved(bytes32 indexed id, address indexed solver, bytes32 tronTxId, uint256 tronBlockNumber);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct IntentSolved {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub solver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tronTxId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub tronBlockNumber: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for IntentSolved {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "IntentSolved(bytes32,address,bytes32,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                250u8, 121u8, 117u8, 133u8, 201u8, 130u8, 125u8, 89u8, 167u8, 105u8,
                78u8, 243u8, 130u8, 36u8, 31u8, 26u8, 3u8, 206u8, 214u8, 161u8, 162u8,
                180u8, 53u8, 59u8, 53u8, 147u8, 154u8, 188u8, 77u8, 4u8, 178u8, 134u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    solver: topics.2,
                    tronTxId: data.0,
                    tronBlockNumber: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.tronTxId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tronBlockNumber),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone(), self.solver.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.solver,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for IntentSolved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&IntentSolved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &IntentSolved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `IntentUnclaimed(bytes32,address,address,bool,uint256,uint256,uint256)` and selector `0x089e9c366bcec979807d16f1dfd778c175797b866f6369dbdf880a2bb7e7179c`.
```solidity
event IntentUnclaimed(bytes32 indexed id, address indexed caller, address indexed prevSolver, bool funded, uint256 depositToCaller, uint256 depositToRefundBeneficiary, uint256 depositToPrevSolver);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct IntentUnclaimed {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub prevSolver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub funded: bool,
        #[allow(missing_docs)]
        pub depositToCaller: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub depositToRefundBeneficiary: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub depositToPrevSolver: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for IntentUnclaimed {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "IntentUnclaimed(bytes32,address,address,bool,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                8u8, 158u8, 156u8, 54u8, 107u8, 206u8, 201u8, 121u8, 128u8, 125u8, 22u8,
                241u8, 223u8, 215u8, 120u8, 193u8, 117u8, 121u8, 123u8, 134u8, 111u8,
                99u8, 105u8, 219u8, 223u8, 136u8, 10u8, 43u8, 183u8, 231u8, 23u8, 156u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    caller: topics.2,
                    prevSolver: topics.3,
                    funded: data.0,
                    depositToCaller: data.1,
                    depositToRefundBeneficiary: data.2,
                    depositToPrevSolver: data.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.funded,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.depositToCaller),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.depositToRefundBeneficiary,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.depositToPrevSolver),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.id.clone(),
                    self.caller.clone(),
                    self.prevSolver.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.caller,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.prevSolver,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for IntentUnclaimed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&IntentUnclaimed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &IntentUnclaimed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub oldOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ReceiverIntentFeeSnap(bytes32,uint256,uint256,uint256)` and selector `0xc853b9fbc6265708cfc473efd1ce29b19a3616b3edccaeaf71a4a6b778cb010e`.
```solidity
event ReceiverIntentFeeSnap(bytes32 indexed id, uint256 feePpm, uint256 feeFlat, uint256 tronPaymentAmount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ReceiverIntentFeeSnap {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub feePpm: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub feeFlat: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub tronPaymentAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ReceiverIntentFeeSnap {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "ReceiverIntentFeeSnap(bytes32,uint256,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                200u8, 83u8, 185u8, 251u8, 198u8, 38u8, 87u8, 8u8, 207u8, 196u8, 115u8,
                239u8, 209u8, 206u8, 41u8, 177u8, 154u8, 54u8, 22u8, 179u8, 237u8, 204u8,
                174u8, 175u8, 113u8, 164u8, 166u8, 183u8, 120u8, 203u8, 1u8, 14u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    feePpm: data.0,
                    feeFlat: data.1,
                    tronPaymentAmount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.feePpm),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.feeFlat),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.tronPaymentAmount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.id.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ReceiverIntentFeeSnap {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ReceiverIntentFeeSnap> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ReceiverIntentFeeSnap) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ReceiverIntentParams(bytes32,address,address,bytes32,address,uint256)` and selector `0x11039d948e58aabf982e09eab3f7ce6db7bf72add1d0b04e63f0697eac16024b`.
```solidity
event ReceiverIntentParams(bytes32 indexed id, address indexed forwarder, address indexed toTron, bytes32 forwardSalt, address token, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ReceiverIntentParams {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub forwarder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toTron: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub forwardSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ReceiverIntentParams {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ReceiverIntentParams(bytes32,address,address,bytes32,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                17u8, 3u8, 157u8, 148u8, 142u8, 88u8, 170u8, 191u8, 152u8, 46u8, 9u8,
                234u8, 179u8, 247u8, 206u8, 109u8, 183u8, 191u8, 114u8, 173u8, 209u8,
                208u8, 176u8, 78u8, 99u8, 240u8, 105u8, 126u8, 172u8, 22u8, 2u8, 75u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    id: topics.1,
                    forwarder: topics.2,
                    toTron: topics.3,
                    forwardSalt: data.0,
                    token: data.1,
                    amount: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.forwardSalt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.id.clone(),
                    self.forwarder.clone(),
                    self.toTron.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.id);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.forwarder,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.toTron,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ReceiverIntentParams {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ReceiverIntentParams> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ReceiverIntentParams) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `RecommendedIntentFeeSet(uint256,uint256)` and selector `0x9d4c3779a823aa84b20dd2e8551e6ed95addbc562f3bc49b1e688ab785b05d9d`.
```solidity
event RecommendedIntentFeeSet(uint256 feePpm, uint256 feeFlat);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RecommendedIntentFeeSet {
        #[allow(missing_docs)]
        pub feePpm: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub feeFlat: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RecommendedIntentFeeSet {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "RecommendedIntentFeeSet(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                157u8, 76u8, 55u8, 121u8, 168u8, 35u8, 170u8, 132u8, 178u8, 13u8, 210u8,
                232u8, 85u8, 30u8, 110u8, 217u8, 90u8, 221u8, 188u8, 86u8, 47u8, 59u8,
                196u8, 155u8, 30u8, 104u8, 138u8, 183u8, 133u8, 176u8, 93u8, 157u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    feePpm: data.0,
                    feeFlat: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.feePpm),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.feeFlat),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RecommendedIntentFeeSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RecommendedIntentFeeSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &RecommendedIntentFeeSet,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _owner, address v3, address usdt);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub v3: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub usdt: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._owner, value.v3, value.usdt)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _owner: tuple.0,
                        v3: tuple.1,
                        usdt: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.v3,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.usdt,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `INTENT_CLAIM_DEPOSIT()` and selector `0x49c0c8b0`.
```solidity
function INTENT_CLAIM_DEPOSIT() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INTENT_CLAIM_DEPOSITCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`INTENT_CLAIM_DEPOSIT()`](INTENT_CLAIM_DEPOSITCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct INTENT_CLAIM_DEPOSITReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INTENT_CLAIM_DEPOSITCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: INTENT_CLAIM_DEPOSITCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INTENT_CLAIM_DEPOSITCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<INTENT_CLAIM_DEPOSITReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: INTENT_CLAIM_DEPOSITReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for INTENT_CLAIM_DEPOSITReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for INTENT_CLAIM_DEPOSITCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "INTENT_CLAIM_DEPOSIT()";
            const SELECTOR: [u8; 4] = [73u8, 192u8, 200u8, 176u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: INTENT_CLAIM_DEPOSITReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: INTENT_CLAIM_DEPOSITReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `RECEIVER_INTENT_DURATION()` and selector `0xb2a61786`.
```solidity
function RECEIVER_INTENT_DURATION() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RECEIVER_INTENT_DURATIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`RECEIVER_INTENT_DURATION()`](RECEIVER_INTENT_DURATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RECEIVER_INTENT_DURATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RECEIVER_INTENT_DURATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: RECEIVER_INTENT_DURATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RECEIVER_INTENT_DURATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RECEIVER_INTENT_DURATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: RECEIVER_INTENT_DURATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RECEIVER_INTENT_DURATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for RECEIVER_INTENT_DURATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RECEIVER_INTENT_DURATION()";
            const SELECTOR: [u8; 4] = [178u8, 166u8, 23u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: RECEIVER_INTENT_DURATIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: RECEIVER_INTENT_DURATIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `TIME_TO_FILL()` and selector `0x5c66079a`.
```solidity
function TIME_TO_FILL() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TIME_TO_FILLCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`TIME_TO_FILL()`](TIME_TO_FILLCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TIME_TO_FILLReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TIME_TO_FILLCall> for UnderlyingRustTuple<'_> {
                fn from(value: TIME_TO_FILLCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TIME_TO_FILLCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TIME_TO_FILLReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TIME_TO_FILLReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TIME_TO_FILLReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TIME_TO_FILLCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TIME_TO_FILL()";
            const SELECTOR: [u8; 4] = [92u8, 102u8, 7u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: TIME_TO_FILLReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: TIME_TO_FILLReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `USDT()` and selector `0xc54e44eb`.
```solidity
function USDT() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct USDTCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`USDT()`](USDTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct USDTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USDTCall> for UnderlyingRustTuple<'_> {
                fn from(value: USDTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for USDTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USDTReturn> for UnderlyingRustTuple<'_> {
                fn from(value: USDTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for USDTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for USDTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "USDT()";
            const SELECTOR: [u8; 4] = [197u8, 78u8, 68u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: USDTReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: USDTReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `V3()` and selector `0x2fb42d70`.
```solidity
function V3() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct V3Call;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`V3()`](V3Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct V3Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<V3Call> for UnderlyingRustTuple<'_> {
                fn from(value: V3Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for V3Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<V3Return> for UnderlyingRustTuple<'_> {
                fn from(value: V3Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for V3Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for V3Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "V3()";
            const SELECTOR: [u8; 4] = [47u8, 180u8, 45u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: V3Return = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: V3Return = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimIntent(bytes32)` and selector `0x40e624cb`.
```solidity
function claimIntent(bytes32 id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimIntentCall {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`claimIntent(bytes32)`](claimIntentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimIntentReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimIntentCall> for UnderlyingRustTuple<'_> {
                fn from(value: claimIntentCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimIntentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimIntentReturn> for UnderlyingRustTuple<'_> {
                fn from(value: claimIntentReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimIntentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl claimIntentReturn {
            fn _tokenize(
                &self,
            ) -> <claimIntentCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimIntentCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimIntentReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimIntent(bytes32)";
            const SELECTOR: [u8; 4] = [64u8, 230u8, 36u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimIntentReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `claimVirtualReceiverIntent(address,address,bytes32,address,uint256)` and selector `0xaf244005`.
```solidity
function claimVirtualReceiverIntent(address forwarder, address toTron, bytes32 forwardSalt, address token, uint256 amount) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimVirtualReceiverIntentCall {
        #[allow(missing_docs)]
        pub forwarder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toTron: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub forwardSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`claimVirtualReceiverIntent(address,address,bytes32,address,uint256)`](claimVirtualReceiverIntentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimVirtualReceiverIntentReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimVirtualReceiverIntentCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimVirtualReceiverIntentCall) -> Self {
                    (
                        value.forwarder,
                        value.toTron,
                        value.forwardSalt,
                        value.token,
                        value.amount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimVirtualReceiverIntentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        forwarder: tuple.0,
                        toTron: tuple.1,
                        forwardSalt: tuple.2,
                        token: tuple.3,
                        amount: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimVirtualReceiverIntentReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimVirtualReceiverIntentReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimVirtualReceiverIntentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl claimVirtualReceiverIntentReturn {
            fn _tokenize(
                &self,
            ) -> <claimVirtualReceiverIntentCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimVirtualReceiverIntentCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimVirtualReceiverIntentReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimVirtualReceiverIntent(address,address,bytes32,address,uint256)";
            const SELECTOR: [u8; 4] = [175u8, 36u8, 64u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.forwarder,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.toTron,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.forwardSalt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                claimVirtualReceiverIntentReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `closeIntent(bytes32)` and selector `0x51ead90a`.
```solidity
function closeIntent(bytes32 id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeIntentCall {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`closeIntent(bytes32)`](closeIntentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct closeIntentReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeIntentCall> for UnderlyingRustTuple<'_> {
                fn from(value: closeIntentCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for closeIntentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<closeIntentReturn> for UnderlyingRustTuple<'_> {
                fn from(value: closeIntentReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for closeIntentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl closeIntentReturn {
            fn _tokenize(
                &self,
            ) -> <closeIntentCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for closeIntentCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = closeIntentReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "closeIntent(bytes32)";
            const SELECTOR: [u8; 4] = [81u8, 234u8, 217u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                closeIntentReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `createIntent((uint8,bytes,address,address,uint256),uint256)` and selector `0x549f7505`.
```solidity
function createIntent(Intent memory intent, uint256 deadline) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createIntentCall {
        #[allow(missing_docs)]
        pub intent: <Intent as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`createIntent((uint8,bytes,address,address,uint256),uint256)`](createIntentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createIntentReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                Intent,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Intent as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createIntentCall> for UnderlyingRustTuple<'_> {
                fn from(value: createIntentCall) -> Self {
                    (value.intent, value.deadline)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createIntentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        intent: tuple.0,
                        deadline: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createIntentReturn> for UnderlyingRustTuple<'_> {
                fn from(value: createIntentReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createIntentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl createIntentReturn {
            fn _tokenize(
                &self,
            ) -> <createIntentCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createIntentCall {
            type Parameters<'a> = (Intent, alloy::sol_types::sol_data::Uint<256>);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createIntentReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createIntent((uint8,bytes,address,address,uint256),uint256)";
            const SELECTOR: [u8; 4] = [84u8, 159u8, 117u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Intent as alloy_sol_types::SolType>::tokenize(&self.intent),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                createIntentReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `createIntentFromReceiver(address,address,bytes32,address,uint256)` and selector `0xfcf98d85`.
```solidity
function createIntentFromReceiver(address forwarder, address toTron, bytes32 forwardSalt, address token, uint256 amount) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createIntentFromReceiverCall {
        #[allow(missing_docs)]
        pub forwarder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toTron: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub forwardSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`createIntentFromReceiver(address,address,bytes32,address,uint256)`](createIntentFromReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createIntentFromReceiverReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createIntentFromReceiverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createIntentFromReceiverCall) -> Self {
                    (
                        value.forwarder,
                        value.toTron,
                        value.forwardSalt,
                        value.token,
                        value.amount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createIntentFromReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        forwarder: tuple.0,
                        toTron: tuple.1,
                        forwardSalt: tuple.2,
                        token: tuple.3,
                        amount: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createIntentFromReceiverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createIntentFromReceiverReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createIntentFromReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl createIntentFromReceiverReturn {
            fn _tokenize(
                &self,
            ) -> <createIntentFromReceiverCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createIntentFromReceiverCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createIntentFromReceiverReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createIntentFromReceiver(address,address,bytes32,address,uint256)";
            const SELECTOR: [u8; 4] = [252u8, 249u8, 141u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.forwarder,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.toTron,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.forwardSalt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                createIntentFromReceiverReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eventChainTip()` and selector `0x4d53e931`.
```solidity
function eventChainTip() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eventChainTip()`](eventChainTipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipCall> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eventChainTipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eventChainTip()";
            const SELECTOR: [u8; 4] = [77u8, 83u8, 233u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eventSeq()` and selector `0xe24d5c35`.
```solidity
function eventSeq() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventSeqCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eventSeq()`](eventSeqCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventSeqReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventSeqCall> for UnderlyingRustTuple<'_> {
                fn from(value: eventSeqCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventSeqCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventSeqReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eventSeqReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventSeqReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eventSeqCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eventSeq()";
            const SELECTOR: [u8; 4] = [226u8, 77u8, 92u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: eventSeqReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: eventSeqReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `fundReceiverIntent(address,address,bytes32,address,uint256)` and selector `0xeba475ac`.
```solidity
function fundReceiverIntent(address forwarder, address toTron, bytes32 forwardSalt, address token, uint256 amount) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fundReceiverIntentCall {
        #[allow(missing_docs)]
        pub forwarder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toTron: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub forwardSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`fundReceiverIntent(address,address,bytes32,address,uint256)`](fundReceiverIntentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fundReceiverIntentReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fundReceiverIntentCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: fundReceiverIntentCall) -> Self {
                    (
                        value.forwarder,
                        value.toTron,
                        value.forwardSalt,
                        value.token,
                        value.amount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fundReceiverIntentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        forwarder: tuple.0,
                        toTron: tuple.1,
                        forwardSalt: tuple.2,
                        token: tuple.3,
                        amount: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fundReceiverIntentReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: fundReceiverIntentReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for fundReceiverIntentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl fundReceiverIntentReturn {
            fn _tokenize(
                &self,
            ) -> <fundReceiverIntentCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fundReceiverIntentCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = fundReceiverIntentReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fundReceiverIntent(address,address,bytes32,address,uint256)";
            const SELECTOR: [u8; 4] = [235u8, 164u8, 117u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.forwarder,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.toTron,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.forwardSalt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                fundReceiverIntentReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `intents(bytes32)` and selector `0x9021578a`.
```solidity
function intents(bytes32) external view returns (Intent memory intent, uint256 solverClaimedAt, uint256 deadline, address solver, bool solved, bool funded, bool settled);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct intentsCall(pub alloy::sol_types::private::FixedBytes<32>);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`intents(bytes32)`](intentsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct intentsReturn {
        #[allow(missing_docs)]
        pub intent: <Intent as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub solverClaimedAt: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub deadline: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub solver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub solved: bool,
        #[allow(missing_docs)]
        pub funded: bool,
        #[allow(missing_docs)]
        pub settled: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<intentsCall> for UnderlyingRustTuple<'_> {
                fn from(value: intentsCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for intentsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                Intent,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Intent as alloy::sol_types::SolType>::RustType,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Address,
                bool,
                bool,
                bool,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<intentsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: intentsReturn) -> Self {
                    (
                        value.intent,
                        value.solverClaimedAt,
                        value.deadline,
                        value.solver,
                        value.solved,
                        value.funded,
                        value.settled,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for intentsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        intent: tuple.0,
                        solverClaimedAt: tuple.1,
                        deadline: tuple.2,
                        solver: tuple.3,
                        solved: tuple.4,
                        funded: tuple.5,
                        settled: tuple.6,
                    }
                }
            }
        }
        impl intentsReturn {
            fn _tokenize(
                &self,
            ) -> <intentsCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                (
                    <Intent as alloy_sol_types::SolType>::tokenize(&self.intent),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.solverClaimedAt),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.deadline),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.solver,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.solved,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.funded,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.settled,
                    ),
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for intentsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = intentsReturn;
            type ReturnTuple<'a> = (
                Intent,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "intents(bytes32)";
            const SELECTOR: [u8; 4] = [144u8, 33u8, 87u8, 138u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.0),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                intentsReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `proveIntentFill(bytes32,bytes[20],bytes,bytes32[],uint256)` and selector `0x5c23cc02`.
```solidity
function proveIntentFill(bytes32 id, bytes[20] memory blocks, bytes memory encodedTx, bytes32[] memory proof, uint256 index) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveIntentFillCall {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub blocks: [alloy::sol_types::private::Bytes; 20usize],
        #[allow(missing_docs)]
        pub encodedTx: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub proof: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        #[allow(missing_docs)]
        pub index: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`proveIntentFill(bytes32,bytes[20],bytes,bytes32[],uint256)`](proveIntentFillCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proveIntentFillReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Bytes,
                    20usize,
                >,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                [alloy::sol_types::private::Bytes; 20usize],
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveIntentFillCall> for UnderlyingRustTuple<'_> {
                fn from(value: proveIntentFillCall) -> Self {
                    (value.id, value.blocks, value.encodedTx, value.proof, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proveIntentFillCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        id: tuple.0,
                        blocks: tuple.1,
                        encodedTx: tuple.2,
                        proof: tuple.3,
                        index: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proveIntentFillReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: proveIntentFillReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for proveIntentFillReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl proveIntentFillReturn {
            fn _tokenize(
                &self,
            ) -> <proveIntentFillCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proveIntentFillCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Bytes,
                    20usize,
                >,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proveIntentFillReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proveIntentFill(bytes32,bytes[20],bytes,bytes32[],uint256)";
            const SELECTOR: [u8; 4] = [92u8, 35u8, 204u8, 2u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Bytes,
                        20usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.blocks),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.encodedTx,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.proof),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.index),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                proveIntentFillReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `receiverIntentId(address,address,bytes32,address,uint256)` and selector `0x9ad42c10`.
```solidity
function receiverIntentId(address forwarder, address toTron, bytes32 forwardSalt, address token, uint256 amount) external pure returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct receiverIntentIdCall {
        #[allow(missing_docs)]
        pub forwarder: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub toTron: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub forwardSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`receiverIntentId(address,address,bytes32,address,uint256)`](receiverIntentIdCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct receiverIntentIdReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<receiverIntentIdCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: receiverIntentIdCall) -> Self {
                    (
                        value.forwarder,
                        value.toTron,
                        value.forwardSalt,
                        value.token,
                        value.amount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for receiverIntentIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        forwarder: tuple.0,
                        toTron: tuple.1,
                        forwardSalt: tuple.2,
                        token: tuple.3,
                        amount: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<receiverIntentIdReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: receiverIntentIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for receiverIntentIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for receiverIntentIdCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "receiverIntentId(address,address,bytes32,address,uint256)";
            const SELECTOR: [u8; 4] = [154u8, 212u8, 44u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.forwarder,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.toTron,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.forwardSalt),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: receiverIntentIdReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: receiverIntentIdReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `recommendedIntentFee(uint256)` and selector `0x8ebaebb2`.
```solidity
function recommendedIntentFee(uint256 amount) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recommendedIntentFeeCall {
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`recommendedIntentFee(uint256)`](recommendedIntentFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recommendedIntentFeeReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recommendedIntentFeeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: recommendedIntentFeeCall) -> Self {
                    (value.amount,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for recommendedIntentFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amount: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recommendedIntentFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: recommendedIntentFeeReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for recommendedIntentFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recommendedIntentFeeCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "recommendedIntentFee(uint256)";
            const SELECTOR: [u8; 4] = [142u8, 186u8, 235u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: recommendedIntentFeeReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: recommendedIntentFeeReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `recommendedIntentFeeFlat()` and selector `0xee98aaaa`.
```solidity
function recommendedIntentFeeFlat() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recommendedIntentFeeFlatCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`recommendedIntentFeeFlat()`](recommendedIntentFeeFlatCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recommendedIntentFeeFlatReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recommendedIntentFeeFlatCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: recommendedIntentFeeFlatCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for recommendedIntentFeeFlatCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recommendedIntentFeeFlatReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: recommendedIntentFeeFlatReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for recommendedIntentFeeFlatReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recommendedIntentFeeFlatCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "recommendedIntentFeeFlat()";
            const SELECTOR: [u8; 4] = [238u8, 152u8, 170u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: recommendedIntentFeeFlatReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: recommendedIntentFeeFlatReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `recommendedIntentFeePpm()` and selector `0x65604c32`.
```solidity
function recommendedIntentFeePpm() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recommendedIntentFeePpmCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`recommendedIntentFeePpm()`](recommendedIntentFeePpmCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct recommendedIntentFeePpmReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recommendedIntentFeePpmCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: recommendedIntentFeePpmCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for recommendedIntentFeePpmCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<recommendedIntentFeePpmReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: recommendedIntentFeePpmReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for recommendedIntentFeePpmReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for recommendedIntentFeePpmCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "recommendedIntentFeePpm()";
            const SELECTOR: [u8; 4] = [101u8, 96u8, 76u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: recommendedIntentFeePpmReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: recommendedIntentFeePpmReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall;
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <renounceOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setRecommendedIntentFee(uint256,uint256)` and selector `0xf2af970b`.
```solidity
function setRecommendedIntentFee(uint256 ppm, uint256 flat) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRecommendedIntentFeeCall {
        #[allow(missing_docs)]
        pub ppm: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub flat: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`setRecommendedIntentFee(uint256,uint256)`](setRecommendedIntentFeeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setRecommendedIntentFeeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRecommendedIntentFeeCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRecommendedIntentFeeCall) -> Self {
                    (value.ppm, value.flat)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRecommendedIntentFeeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        ppm: tuple.0,
                        flat: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setRecommendedIntentFeeReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setRecommendedIntentFeeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setRecommendedIntentFeeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setRecommendedIntentFeeReturn {
            fn _tokenize(
                &self,
            ) -> <setRecommendedIntentFeeCall as alloy_sol_types::SolCall>::ReturnToken<
                '_,
            > {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setRecommendedIntentFeeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setRecommendedIntentFeeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setRecommendedIntentFee(uint256,uint256)";
            const SELECTOR: [u8; 4] = [242u8, 175u8, 151u8, 11u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.ppm),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.flat),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setRecommendedIntentFeeReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `settleIntent(bytes32)` and selector `0x7bf8bb88`.
```solidity
function settleIntent(bytes32 id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct settleIntentCall {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`settleIntent(bytes32)`](settleIntentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct settleIntentReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settleIntentCall> for UnderlyingRustTuple<'_> {
                fn from(value: settleIntentCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for settleIntentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<settleIntentReturn> for UnderlyingRustTuple<'_> {
                fn from(value: settleIntentReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for settleIntentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl settleIntentReturn {
            fn _tokenize(
                &self,
            ) -> <settleIntentCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for settleIntentCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = settleIntentReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "settleIntent(bytes32)";
            const SELECTOR: [u8; 4] = [123u8, 248u8, 187u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                settleIntentReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <transferOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `unclaimIntent(bytes32)` and selector `0x64a486c4`.
```solidity
function unclaimIntent(bytes32 id) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unclaimIntentCall {
        #[allow(missing_docs)]
        pub id: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`unclaimIntent(bytes32)`](unclaimIntentCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unclaimIntentReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unclaimIntentCall> for UnderlyingRustTuple<'_> {
                fn from(value: unclaimIntentCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unclaimIntentCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unclaimIntentReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unclaimIntentReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unclaimIntentReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl unclaimIntentReturn {
            fn _tokenize(
                &self,
            ) -> <unclaimIntentCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unclaimIntentCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unclaimIntentReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unclaimIntent(bytes32)";
            const SELECTOR: [u8; 4] = [100u8, 164u8, 134u8, 196u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                unclaimIntentReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`UntronIntents`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum UntronIntentsCalls {
        #[allow(missing_docs)]
        INTENT_CLAIM_DEPOSIT(INTENT_CLAIM_DEPOSITCall),
        #[allow(missing_docs)]
        RECEIVER_INTENT_DURATION(RECEIVER_INTENT_DURATIONCall),
        #[allow(missing_docs)]
        TIME_TO_FILL(TIME_TO_FILLCall),
        #[allow(missing_docs)]
        USDT(USDTCall),
        #[allow(missing_docs)]
        V3(V3Call),
        #[allow(missing_docs)]
        claimIntent(claimIntentCall),
        #[allow(missing_docs)]
        claimVirtualReceiverIntent(claimVirtualReceiverIntentCall),
        #[allow(missing_docs)]
        closeIntent(closeIntentCall),
        #[allow(missing_docs)]
        createIntent(createIntentCall),
        #[allow(missing_docs)]
        createIntentFromReceiver(createIntentFromReceiverCall),
        #[allow(missing_docs)]
        eventChainTip(eventChainTipCall),
        #[allow(missing_docs)]
        eventSeq(eventSeqCall),
        #[allow(missing_docs)]
        fundReceiverIntent(fundReceiverIntentCall),
        #[allow(missing_docs)]
        intents(intentsCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        proveIntentFill(proveIntentFillCall),
        #[allow(missing_docs)]
        receiverIntentId(receiverIntentIdCall),
        #[allow(missing_docs)]
        recommendedIntentFee(recommendedIntentFeeCall),
        #[allow(missing_docs)]
        recommendedIntentFeeFlat(recommendedIntentFeeFlatCall),
        #[allow(missing_docs)]
        recommendedIntentFeePpm(recommendedIntentFeePpmCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        setRecommendedIntentFee(setRecommendedIntentFeeCall),
        #[allow(missing_docs)]
        settleIntent(settleIntentCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        unclaimIntent(unclaimIntentCall),
    }
    impl UntronIntentsCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [47u8, 180u8, 45u8, 112u8],
            [64u8, 230u8, 36u8, 203u8],
            [73u8, 192u8, 200u8, 176u8],
            [77u8, 83u8, 233u8, 49u8],
            [81u8, 234u8, 217u8, 10u8],
            [84u8, 159u8, 117u8, 5u8],
            [92u8, 35u8, 204u8, 2u8],
            [92u8, 102u8, 7u8, 154u8],
            [100u8, 164u8, 134u8, 196u8],
            [101u8, 96u8, 76u8, 50u8],
            [113u8, 80u8, 24u8, 166u8],
            [123u8, 248u8, 187u8, 136u8],
            [141u8, 165u8, 203u8, 91u8],
            [142u8, 186u8, 235u8, 178u8],
            [144u8, 33u8, 87u8, 138u8],
            [154u8, 212u8, 44u8, 16u8],
            [175u8, 36u8, 64u8, 5u8],
            [178u8, 166u8, 23u8, 134u8],
            [197u8, 78u8, 68u8, 235u8],
            [226u8, 77u8, 92u8, 53u8],
            [235u8, 164u8, 117u8, 172u8],
            [238u8, 152u8, 170u8, 170u8],
            [242u8, 175u8, 151u8, 11u8],
            [242u8, 253u8, 227u8, 139u8],
            [252u8, 249u8, 141u8, 133u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(V3),
            ::core::stringify!(claimIntent),
            ::core::stringify!(INTENT_CLAIM_DEPOSIT),
            ::core::stringify!(eventChainTip),
            ::core::stringify!(closeIntent),
            ::core::stringify!(createIntent),
            ::core::stringify!(proveIntentFill),
            ::core::stringify!(TIME_TO_FILL),
            ::core::stringify!(unclaimIntent),
            ::core::stringify!(recommendedIntentFeePpm),
            ::core::stringify!(renounceOwnership),
            ::core::stringify!(settleIntent),
            ::core::stringify!(owner),
            ::core::stringify!(recommendedIntentFee),
            ::core::stringify!(intents),
            ::core::stringify!(receiverIntentId),
            ::core::stringify!(claimVirtualReceiverIntent),
            ::core::stringify!(RECEIVER_INTENT_DURATION),
            ::core::stringify!(USDT),
            ::core::stringify!(eventSeq),
            ::core::stringify!(fundReceiverIntent),
            ::core::stringify!(recommendedIntentFeeFlat),
            ::core::stringify!(setRecommendedIntentFee),
            ::core::stringify!(transferOwnership),
            ::core::stringify!(createIntentFromReceiver),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <V3Call as alloy_sol_types::SolCall>::SIGNATURE,
            <claimIntentCall as alloy_sol_types::SolCall>::SIGNATURE,
            <INTENT_CLAIM_DEPOSITCall as alloy_sol_types::SolCall>::SIGNATURE,
            <eventChainTipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <closeIntentCall as alloy_sol_types::SolCall>::SIGNATURE,
            <createIntentCall as alloy_sol_types::SolCall>::SIGNATURE,
            <proveIntentFillCall as alloy_sol_types::SolCall>::SIGNATURE,
            <TIME_TO_FILLCall as alloy_sol_types::SolCall>::SIGNATURE,
            <unclaimIntentCall as alloy_sol_types::SolCall>::SIGNATURE,
            <recommendedIntentFeePpmCall as alloy_sol_types::SolCall>::SIGNATURE,
            <renounceOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <settleIntentCall as alloy_sol_types::SolCall>::SIGNATURE,
            <ownerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <recommendedIntentFeeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <intentsCall as alloy_sol_types::SolCall>::SIGNATURE,
            <receiverIntentIdCall as alloy_sol_types::SolCall>::SIGNATURE,
            <claimVirtualReceiverIntentCall as alloy_sol_types::SolCall>::SIGNATURE,
            <RECEIVER_INTENT_DURATIONCall as alloy_sol_types::SolCall>::SIGNATURE,
            <USDTCall as alloy_sol_types::SolCall>::SIGNATURE,
            <eventSeqCall as alloy_sol_types::SolCall>::SIGNATURE,
            <fundReceiverIntentCall as alloy_sol_types::SolCall>::SIGNATURE,
            <recommendedIntentFeeFlatCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setRecommendedIntentFeeCall as alloy_sol_types::SolCall>::SIGNATURE,
            <transferOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <createIntentFromReceiverCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for UntronIntentsCalls {
        const NAME: &'static str = "UntronIntentsCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 25usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::INTENT_CLAIM_DEPOSIT(_) => {
                    <INTENT_CLAIM_DEPOSITCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::RECEIVER_INTENT_DURATION(_) => {
                    <RECEIVER_INTENT_DURATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TIME_TO_FILL(_) => {
                    <TIME_TO_FILLCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::USDT(_) => <USDTCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::V3(_) => <V3Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::claimIntent(_) => {
                    <claimIntentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimVirtualReceiverIntent(_) => {
                    <claimVirtualReceiverIntentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::closeIntent(_) => {
                    <closeIntentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createIntent(_) => {
                    <createIntentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createIntentFromReceiver(_) => {
                    <createIntentFromReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eventChainTip(_) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eventSeq(_) => <eventSeqCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::fundReceiverIntent(_) => {
                    <fundReceiverIntentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::intents(_) => <intentsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::proveIntentFill(_) => {
                    <proveIntentFillCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::receiverIntentId(_) => {
                    <receiverIntentIdCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::recommendedIntentFee(_) => {
                    <recommendedIntentFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::recommendedIntentFeeFlat(_) => {
                    <recommendedIntentFeeFlatCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::recommendedIntentFeePpm(_) => {
                    <recommendedIntentFeePpmCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setRecommendedIntentFee(_) => {
                    <setRecommendedIntentFeeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::settleIntent(_) => {
                    <settleIntentCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unclaimIntent(_) => {
                    <unclaimIntentCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UntronIntentsCalls>] = &[
                {
                    fn V3(data: &[u8]) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <V3Call as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronIntentsCalls::V3)
                    }
                    V3
                },
                {
                    fn claimIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <claimIntentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::claimIntent)
                    }
                    claimIntent
                },
                {
                    fn INTENT_CLAIM_DEPOSIT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <INTENT_CLAIM_DEPOSITCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::INTENT_CLAIM_DEPOSIT)
                    }
                    INTENT_CLAIM_DEPOSIT
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn closeIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <closeIntentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::closeIntent)
                    }
                    closeIntent
                },
                {
                    fn createIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <createIntentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::createIntent)
                    }
                    createIntent
                },
                {
                    fn proveIntentFill(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <proveIntentFillCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::proveIntentFill)
                    }
                    proveIntentFill
                },
                {
                    fn TIME_TO_FILL(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <TIME_TO_FILLCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::TIME_TO_FILL)
                    }
                    TIME_TO_FILL
                },
                {
                    fn unclaimIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <unclaimIntentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::unclaimIntent)
                    }
                    unclaimIntent
                },
                {
                    fn recommendedIntentFeePpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <recommendedIntentFeePpmCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::recommendedIntentFeePpm)
                    }
                    recommendedIntentFeePpm
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn settleIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <settleIntentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::settleIntent)
                    }
                    settleIntent
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronIntentsCalls::owner)
                    }
                    owner
                },
                {
                    fn recommendedIntentFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <recommendedIntentFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::recommendedIntentFee)
                    }
                    recommendedIntentFee
                },
                {
                    fn intents(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <intentsCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronIntentsCalls::intents)
                    }
                    intents
                },
                {
                    fn receiverIntentId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <receiverIntentIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::receiverIntentId)
                    }
                    receiverIntentId
                },
                {
                    fn claimVirtualReceiverIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <claimVirtualReceiverIntentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::claimVirtualReceiverIntent)
                    }
                    claimVirtualReceiverIntent
                },
                {
                    fn RECEIVER_INTENT_DURATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <RECEIVER_INTENT_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::RECEIVER_INTENT_DURATION)
                    }
                    RECEIVER_INTENT_DURATION
                },
                {
                    fn USDT(data: &[u8]) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <USDTCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronIntentsCalls::USDT)
                    }
                    USDT
                },
                {
                    fn eventSeq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <eventSeqCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(UntronIntentsCalls::eventSeq)
                    }
                    eventSeq
                },
                {
                    fn fundReceiverIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <fundReceiverIntentCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::fundReceiverIntent)
                    }
                    fundReceiverIntent
                },
                {
                    fn recommendedIntentFeeFlat(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <recommendedIntentFeeFlatCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::recommendedIntentFeeFlat)
                    }
                    recommendedIntentFeeFlat
                },
                {
                    fn setRecommendedIntentFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <setRecommendedIntentFeeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::setRecommendedIntentFee)
                    }
                    setRecommendedIntentFee
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn createIntentFromReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <createIntentFromReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsCalls::createIntentFromReceiver)
                    }
                    createIntentFromReceiver
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UntronIntentsCalls>] = &[
                {
                    fn V3(data: &[u8]) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <V3Call as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::V3)
                    }
                    V3
                },
                {
                    fn claimIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <claimIntentCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::claimIntent)
                    }
                    claimIntent
                },
                {
                    fn INTENT_CLAIM_DEPOSIT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <INTENT_CLAIM_DEPOSITCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::INTENT_CLAIM_DEPOSIT)
                    }
                    INTENT_CLAIM_DEPOSIT
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn closeIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <closeIntentCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::closeIntent)
                    }
                    closeIntent
                },
                {
                    fn createIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <createIntentCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::createIntent)
                    }
                    createIntent
                },
                {
                    fn proveIntentFill(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <proveIntentFillCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::proveIntentFill)
                    }
                    proveIntentFill
                },
                {
                    fn TIME_TO_FILL(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <TIME_TO_FILLCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::TIME_TO_FILL)
                    }
                    TIME_TO_FILL
                },
                {
                    fn unclaimIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <unclaimIntentCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::unclaimIntent)
                    }
                    unclaimIntent
                },
                {
                    fn recommendedIntentFeePpm(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <recommendedIntentFeePpmCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::recommendedIntentFeePpm)
                    }
                    recommendedIntentFeePpm
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn settleIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <settleIntentCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::settleIntent)
                    }
                    settleIntent
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::owner)
                    }
                    owner
                },
                {
                    fn recommendedIntentFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <recommendedIntentFeeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::recommendedIntentFee)
                    }
                    recommendedIntentFee
                },
                {
                    fn intents(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <intentsCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::intents)
                    }
                    intents
                },
                {
                    fn receiverIntentId(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <receiverIntentIdCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::receiverIntentId)
                    }
                    receiverIntentId
                },
                {
                    fn claimVirtualReceiverIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <claimVirtualReceiverIntentCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::claimVirtualReceiverIntent)
                    }
                    claimVirtualReceiverIntent
                },
                {
                    fn RECEIVER_INTENT_DURATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <RECEIVER_INTENT_DURATIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::RECEIVER_INTENT_DURATION)
                    }
                    RECEIVER_INTENT_DURATION
                },
                {
                    fn USDT(data: &[u8]) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <USDTCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::USDT)
                    }
                    USDT
                },
                {
                    fn eventSeq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <eventSeqCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::eventSeq)
                    }
                    eventSeq
                },
                {
                    fn fundReceiverIntent(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <fundReceiverIntentCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::fundReceiverIntent)
                    }
                    fundReceiverIntent
                },
                {
                    fn recommendedIntentFeeFlat(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <recommendedIntentFeeFlatCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::recommendedIntentFeeFlat)
                    }
                    recommendedIntentFeeFlat
                },
                {
                    fn setRecommendedIntentFee(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <setRecommendedIntentFeeCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::setRecommendedIntentFee)
                    }
                    setRecommendedIntentFee
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn createIntentFromReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsCalls> {
                        <createIntentFromReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsCalls::createIntentFromReceiver)
                    }
                    createIntentFromReceiver
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::INTENT_CLAIM_DEPOSIT(inner) => {
                    <INTENT_CLAIM_DEPOSITCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RECEIVER_INTENT_DURATION(inner) => {
                    <RECEIVER_INTENT_DURATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TIME_TO_FILL(inner) => {
                    <TIME_TO_FILLCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::USDT(inner) => {
                    <USDTCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::V3(inner) => {
                    <V3Call as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::claimIntent(inner) => {
                    <claimIntentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimVirtualReceiverIntent(inner) => {
                    <claimVirtualReceiverIntentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::closeIntent(inner) => {
                    <closeIntentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createIntent(inner) => {
                    <createIntentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createIntentFromReceiver(inner) => {
                    <createIntentFromReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eventSeq(inner) => {
                    <eventSeqCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::fundReceiverIntent(inner) => {
                    <fundReceiverIntentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::intents(inner) => {
                    <intentsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::proveIntentFill(inner) => {
                    <proveIntentFillCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::receiverIntentId(inner) => {
                    <receiverIntentIdCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::recommendedIntentFee(inner) => {
                    <recommendedIntentFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::recommendedIntentFeeFlat(inner) => {
                    <recommendedIntentFeeFlatCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::recommendedIntentFeePpm(inner) => {
                    <recommendedIntentFeePpmCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setRecommendedIntentFee(inner) => {
                    <setRecommendedIntentFeeCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::settleIntent(inner) => {
                    <settleIntentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unclaimIntent(inner) => {
                    <unclaimIntentCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::INTENT_CLAIM_DEPOSIT(inner) => {
                    <INTENT_CLAIM_DEPOSITCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RECEIVER_INTENT_DURATION(inner) => {
                    <RECEIVER_INTENT_DURATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TIME_TO_FILL(inner) => {
                    <TIME_TO_FILLCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::USDT(inner) => {
                    <USDTCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::V3(inner) => {
                    <V3Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::claimIntent(inner) => {
                    <claimIntentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimVirtualReceiverIntent(inner) => {
                    <claimVirtualReceiverIntentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::closeIntent(inner) => {
                    <closeIntentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createIntent(inner) => {
                    <createIntentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createIntentFromReceiver(inner) => {
                    <createIntentFromReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eventSeq(inner) => {
                    <eventSeqCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fundReceiverIntent(inner) => {
                    <fundReceiverIntentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::intents(inner) => {
                    <intentsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::proveIntentFill(inner) => {
                    <proveIntentFillCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::receiverIntentId(inner) => {
                    <receiverIntentIdCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::recommendedIntentFee(inner) => {
                    <recommendedIntentFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::recommendedIntentFeeFlat(inner) => {
                    <recommendedIntentFeeFlatCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::recommendedIntentFeePpm(inner) => {
                    <recommendedIntentFeePpmCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setRecommendedIntentFee(inner) => {
                    <setRecommendedIntentFeeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::settleIntent(inner) => {
                    <settleIntentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unclaimIntent(inner) => {
                    <unclaimIntentCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`UntronIntents`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum UntronIntentsErrors {
        #[allow(missing_docs)]
        AlreadyClaimed(AlreadyClaimed),
        #[allow(missing_docs)]
        AlreadyExists(AlreadyExists),
        #[allow(missing_docs)]
        AlreadyFunded(AlreadyFunded),
        #[allow(missing_docs)]
        AlreadyInitialized(AlreadyInitialized),
        #[allow(missing_docs)]
        AlreadySolved(AlreadySolved),
        #[allow(missing_docs)]
        IncorrectPullAmount(IncorrectPullAmount),
        #[allow(missing_docs)]
        InsufficientETH(InsufficientETH),
        #[allow(missing_docs)]
        IntentNotFound(IntentNotFound),
        #[allow(missing_docs)]
        InvalidDeadline(InvalidDeadline),
        #[allow(missing_docs)]
        InvalidReceiverAmount(InvalidReceiverAmount),
        #[allow(missing_docs)]
        NewOwnerIsZeroAddress(NewOwnerIsZeroAddress),
        #[allow(missing_docs)]
        NotATrc20Transfer(NotATrc20Transfer),
        #[allow(missing_docs)]
        NotClaimed(NotClaimed),
        #[allow(missing_docs)]
        NotExpiredYet(NotExpiredYet),
        #[allow(missing_docs)]
        NotSolver(NotSolver),
        #[allow(missing_docs)]
        NothingToSettle(NothingToSettle),
        #[allow(missing_docs)]
        Reentrancy(Reentrancy),
        #[allow(missing_docs)]
        TronInvalidCalldataLength(TronInvalidCalldataLength),
        #[allow(missing_docs)]
        TronInvalidTrc20DataLength(TronInvalidTrc20DataLength),
        #[allow(missing_docs)]
        Unauthorized(Unauthorized),
        #[allow(missing_docs)]
        WrongTxProps(WrongTxProps),
    }
    impl UntronIntentsErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [13u8, 193u8, 73u8, 240u8],
            [18u8, 121u8, 149u8, 3u8],
            [25u8, 131u8, 85u8, 71u8],
            [35u8, 54u8, 159u8, 166u8],
            [36u8, 86u8, 225u8, 236u8],
            [76u8, 125u8, 16u8, 14u8],
            [90u8, 223u8, 99u8, 135u8],
            [97u8, 129u8, 4u8, 232u8],
            [97u8, 174u8, 100u8, 131u8],
            [100u8, 108u8, 245u8, 88u8],
            [106u8, 18u8, 241u8, 4u8],
            [116u8, 72u8, 251u8, 174u8],
            [118u8, 157u8, 17u8, 228u8],
            [130u8, 180u8, 41u8, 0u8],
            [154u8, 198u8, 12u8, 45u8],
            [168u8, 5u8, 142u8, 169u8],
            [171u8, 20u8, 60u8, 6u8],
            [178u8, 201u8, 130u8, 174u8],
            [183u8, 42u8, 37u8, 34u8],
            [193u8, 57u8, 234u8, 189u8],
            [209u8, 151u8, 203u8, 5u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(AlreadyInitialized),
            ::core::stringify!(TronInvalidCalldataLength),
            ::core::stringify!(AlreadySolved),
            ::core::stringify!(AlreadyExists),
            ::core::stringify!(NotATrc20Transfer),
            ::core::stringify!(InvalidReceiverAmount),
            ::core::stringify!(AlreadyFunded),
            ::core::stringify!(NothingToSettle),
            ::core::stringify!(IntentNotFound),
            ::core::stringify!(AlreadyClaimed),
            ::core::stringify!(InsufficientETH),
            ::core::stringify!(NewOwnerIsZeroAddress),
            ::core::stringify!(InvalidDeadline),
            ::core::stringify!(Unauthorized),
            ::core::stringify!(TronInvalidTrc20DataLength),
            ::core::stringify!(NotExpiredYet),
            ::core::stringify!(Reentrancy),
            ::core::stringify!(IncorrectPullAmount),
            ::core::stringify!(NotClaimed),
            ::core::stringify!(NotSolver),
            ::core::stringify!(WrongTxProps),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <AlreadyInitialized as alloy_sol_types::SolError>::SIGNATURE,
            <TronInvalidCalldataLength as alloy_sol_types::SolError>::SIGNATURE,
            <AlreadySolved as alloy_sol_types::SolError>::SIGNATURE,
            <AlreadyExists as alloy_sol_types::SolError>::SIGNATURE,
            <NotATrc20Transfer as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidReceiverAmount as alloy_sol_types::SolError>::SIGNATURE,
            <AlreadyFunded as alloy_sol_types::SolError>::SIGNATURE,
            <NothingToSettle as alloy_sol_types::SolError>::SIGNATURE,
            <IntentNotFound as alloy_sol_types::SolError>::SIGNATURE,
            <AlreadyClaimed as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientETH as alloy_sol_types::SolError>::SIGNATURE,
            <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::SIGNATURE,
            <InvalidDeadline as alloy_sol_types::SolError>::SIGNATURE,
            <Unauthorized as alloy_sol_types::SolError>::SIGNATURE,
            <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::SIGNATURE,
            <NotExpiredYet as alloy_sol_types::SolError>::SIGNATURE,
            <Reentrancy as alloy_sol_types::SolError>::SIGNATURE,
            <IncorrectPullAmount as alloy_sol_types::SolError>::SIGNATURE,
            <NotClaimed as alloy_sol_types::SolError>::SIGNATURE,
            <NotSolver as alloy_sol_types::SolError>::SIGNATURE,
            <WrongTxProps as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for UntronIntentsErrors {
        const NAME: &'static str = "UntronIntentsErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 21usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyClaimed(_) => {
                    <AlreadyClaimed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AlreadyExists(_) => {
                    <AlreadyExists as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AlreadyFunded(_) => {
                    <AlreadyFunded as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AlreadyInitialized(_) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AlreadySolved(_) => {
                    <AlreadySolved as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IncorrectPullAmount(_) => {
                    <IncorrectPullAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientETH(_) => {
                    <InsufficientETH as alloy_sol_types::SolError>::SELECTOR
                }
                Self::IntentNotFound(_) => {
                    <IntentNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidDeadline(_) => {
                    <InvalidDeadline as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidReceiverAmount(_) => {
                    <InvalidReceiverAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NewOwnerIsZeroAddress(_) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotATrc20Transfer(_) => {
                    <NotATrc20Transfer as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotClaimed(_) => {
                    <NotClaimed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotExpiredYet(_) => {
                    <NotExpiredYet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotSolver(_) => <NotSolver as alloy_sol_types::SolError>::SELECTOR,
                Self::NothingToSettle(_) => {
                    <NothingToSettle as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Reentrancy(_) => {
                    <Reentrancy as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TronInvalidCalldataLength(_) => {
                    <TronInvalidCalldataLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TronInvalidTrc20DataLength(_) => {
                    <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Unauthorized(_) => {
                    <Unauthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::WrongTxProps(_) => {
                    <WrongTxProps as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UntronIntentsErrors>] = &[
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn TronInvalidCalldataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <TronInvalidCalldataLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::TronInvalidCalldataLength)
                    }
                    TronInvalidCalldataLength
                },
                {
                    fn AlreadySolved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadySolved as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadySolved)
                    }
                    AlreadySolved
                },
                {
                    fn AlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadyExists as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadyExists)
                    }
                    AlreadyExists
                },
                {
                    fn NotATrc20Transfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NotATrc20Transfer as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::NotATrc20Transfer)
                    }
                    NotATrc20Transfer
                },
                {
                    fn InvalidReceiverAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <InvalidReceiverAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::InvalidReceiverAmount)
                    }
                    InvalidReceiverAmount
                },
                {
                    fn AlreadyFunded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadyFunded as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadyFunded)
                    }
                    AlreadyFunded
                },
                {
                    fn NothingToSettle(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NothingToSettle as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::NothingToSettle)
                    }
                    NothingToSettle
                },
                {
                    fn IntentNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <IntentNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::IntentNotFound)
                    }
                    IntentNotFound
                },
                {
                    fn AlreadyClaimed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadyClaimed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadyClaimed)
                    }
                    AlreadyClaimed
                },
                {
                    fn InsufficientETH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <InsufficientETH as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::InsufficientETH)
                    }
                    InsufficientETH
                },
                {
                    fn NewOwnerIsZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::NewOwnerIsZeroAddress)
                    }
                    NewOwnerIsZeroAddress
                },
                {
                    fn InvalidDeadline(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <InvalidDeadline as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::InvalidDeadline)
                    }
                    InvalidDeadline
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronIntentsErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn TronInvalidTrc20DataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::TronInvalidTrc20DataLength)
                    }
                    TronInvalidTrc20DataLength
                },
                {
                    fn NotExpiredYet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NotExpiredYet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::NotExpiredYet)
                    }
                    NotExpiredYet
                },
                {
                    fn Reentrancy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <Reentrancy as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronIntentsErrors::Reentrancy)
                    }
                    Reentrancy
                },
                {
                    fn IncorrectPullAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <IncorrectPullAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(UntronIntentsErrors::IncorrectPullAmount)
                    }
                    IncorrectPullAmount
                },
                {
                    fn NotClaimed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NotClaimed as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronIntentsErrors::NotClaimed)
                    }
                    NotClaimed
                },
                {
                    fn NotSolver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NotSolver as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronIntentsErrors::NotSolver)
                    }
                    NotSolver
                },
                {
                    fn WrongTxProps(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <WrongTxProps as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(UntronIntentsErrors::WrongTxProps)
                    }
                    WrongTxProps
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<UntronIntentsErrors>] = &[
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn TronInvalidCalldataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <TronInvalidCalldataLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::TronInvalidCalldataLength)
                    }
                    TronInvalidCalldataLength
                },
                {
                    fn AlreadySolved(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadySolved as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadySolved)
                    }
                    AlreadySolved
                },
                {
                    fn AlreadyExists(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadyExists as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadyExists)
                    }
                    AlreadyExists
                },
                {
                    fn NotATrc20Transfer(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NotATrc20Transfer as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::NotATrc20Transfer)
                    }
                    NotATrc20Transfer
                },
                {
                    fn InvalidReceiverAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <InvalidReceiverAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::InvalidReceiverAmount)
                    }
                    InvalidReceiverAmount
                },
                {
                    fn AlreadyFunded(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadyFunded as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadyFunded)
                    }
                    AlreadyFunded
                },
                {
                    fn NothingToSettle(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NothingToSettle as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::NothingToSettle)
                    }
                    NothingToSettle
                },
                {
                    fn IntentNotFound(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <IntentNotFound as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::IntentNotFound)
                    }
                    IntentNotFound
                },
                {
                    fn AlreadyClaimed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <AlreadyClaimed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::AlreadyClaimed)
                    }
                    AlreadyClaimed
                },
                {
                    fn InsufficientETH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <InsufficientETH as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::InsufficientETH)
                    }
                    InsufficientETH
                },
                {
                    fn NewOwnerIsZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::NewOwnerIsZeroAddress)
                    }
                    NewOwnerIsZeroAddress
                },
                {
                    fn InvalidDeadline(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <InvalidDeadline as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::InvalidDeadline)
                    }
                    InvalidDeadline
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn TronInvalidTrc20DataLength(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::TronInvalidTrc20DataLength)
                    }
                    TronInvalidTrc20DataLength
                },
                {
                    fn NotExpiredYet(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NotExpiredYet as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::NotExpiredYet)
                    }
                    NotExpiredYet
                },
                {
                    fn Reentrancy(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <Reentrancy as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::Reentrancy)
                    }
                    Reentrancy
                },
                {
                    fn IncorrectPullAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <IncorrectPullAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::IncorrectPullAmount)
                    }
                    IncorrectPullAmount
                },
                {
                    fn NotClaimed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NotClaimed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::NotClaimed)
                    }
                    NotClaimed
                },
                {
                    fn NotSolver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <NotSolver as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::NotSolver)
                    }
                    NotSolver
                },
                {
                    fn WrongTxProps(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<UntronIntentsErrors> {
                        <WrongTxProps as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(UntronIntentsErrors::WrongTxProps)
                    }
                    WrongTxProps
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyClaimed(inner) => {
                    <AlreadyClaimed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AlreadyExists(inner) => {
                    <AlreadyExists as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::AlreadyFunded(inner) => {
                    <AlreadyFunded as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AlreadySolved(inner) => {
                    <AlreadySolved as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::IncorrectPullAmount(inner) => {
                    <IncorrectPullAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientETH(inner) => {
                    <InsufficientETH as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::IntentNotFound(inner) => {
                    <IntentNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidDeadline(inner) => {
                    <InvalidDeadline as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidReceiverAmount(inner) => {
                    <InvalidReceiverAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotATrc20Transfer(inner) => {
                    <NotATrc20Transfer as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotClaimed(inner) => {
                    <NotClaimed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotExpiredYet(inner) => {
                    <NotExpiredYet as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotSolver(inner) => {
                    <NotSolver as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NothingToSettle(inner) => {
                    <NothingToSettle as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Reentrancy(inner) => {
                    <Reentrancy as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::TronInvalidCalldataLength(inner) => {
                    <TronInvalidCalldataLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TronInvalidTrc20DataLength(inner) => {
                    <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::WrongTxProps(inner) => {
                    <WrongTxProps as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyClaimed(inner) => {
                    <AlreadyClaimed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AlreadyExists(inner) => {
                    <AlreadyExists as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AlreadyFunded(inner) => {
                    <AlreadyFunded as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AlreadySolved(inner) => {
                    <AlreadySolved as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IncorrectPullAmount(inner) => {
                    <IncorrectPullAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientETH(inner) => {
                    <InsufficientETH as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::IntentNotFound(inner) => {
                    <IntentNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidDeadline(inner) => {
                    <InvalidDeadline as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidReceiverAmount(inner) => {
                    <InvalidReceiverAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotATrc20Transfer(inner) => {
                    <NotATrc20Transfer as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotClaimed(inner) => {
                    <NotClaimed as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NotExpiredYet(inner) => {
                    <NotExpiredYet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotSolver(inner) => {
                    <NotSolver as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NothingToSettle(inner) => {
                    <NothingToSettle as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Reentrancy(inner) => {
                    <Reentrancy as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::TronInvalidCalldataLength(inner) => {
                    <TronInvalidCalldataLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TronInvalidTrc20DataLength(inner) => {
                    <TronInvalidTrc20DataLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::WrongTxProps(inner) => {
                    <WrongTxProps as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`UntronIntents`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum UntronIntentsEvents {
        #[allow(missing_docs)]
        EventAppended(EventAppended),
        #[allow(missing_docs)]
        IntentClaimed(IntentClaimed),
        #[allow(missing_docs)]
        IntentClosed(IntentClosed),
        #[allow(missing_docs)]
        IntentCreated(IntentCreated),
        #[allow(missing_docs)]
        IntentFunded(IntentFunded),
        #[allow(missing_docs)]
        IntentSettled(IntentSettled),
        #[allow(missing_docs)]
        IntentSolved(IntentSolved),
        #[allow(missing_docs)]
        IntentUnclaimed(IntentUnclaimed),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        ReceiverIntentFeeSnap(ReceiverIntentFeeSnap),
        #[allow(missing_docs)]
        ReceiverIntentParams(ReceiverIntentParams),
        #[allow(missing_docs)]
        RecommendedIntentFeeSet(RecommendedIntentFeeSet),
    }
    impl UntronIntentsEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                5u8, 68u8, 116u8, 31u8, 246u8, 242u8, 112u8, 128u8, 71u8, 19u8, 140u8,
                143u8, 58u8, 104u8, 171u8, 185u8, 148u8, 230u8, 40u8, 102u8, 109u8,
                186u8, 120u8, 95u8, 104u8, 95u8, 241u8, 3u8, 82u8, 116u8, 249u8, 251u8,
            ],
            [
                8u8, 158u8, 156u8, 54u8, 107u8, 206u8, 201u8, 121u8, 128u8, 125u8, 22u8,
                241u8, 223u8, 215u8, 120u8, 193u8, 117u8, 121u8, 123u8, 134u8, 111u8,
                99u8, 105u8, 219u8, 223u8, 136u8, 10u8, 43u8, 183u8, 231u8, 23u8, 156u8,
            ],
            [
                17u8, 3u8, 157u8, 148u8, 142u8, 88u8, 170u8, 191u8, 152u8, 46u8, 9u8,
                234u8, 179u8, 247u8, 206u8, 109u8, 183u8, 191u8, 114u8, 173u8, 209u8,
                208u8, 176u8, 78u8, 99u8, 240u8, 105u8, 126u8, 172u8, 22u8, 2u8, 75u8,
            ],
            [
                22u8, 191u8, 182u8, 74u8, 231u8, 11u8, 138u8, 155u8, 189u8, 162u8, 141u8,
                235u8, 39u8, 161u8, 203u8, 197u8, 236u8, 62u8, 100u8, 151u8, 72u8, 23u8,
                20u8, 52u8, 76u8, 34u8, 27u8, 70u8, 192u8, 119u8, 127u8, 53u8,
            ],
            [
                109u8, 178u8, 218u8, 15u8, 102u8, 29u8, 89u8, 213u8, 169u8, 199u8, 103u8,
                182u8, 186u8, 97u8, 169u8, 193u8, 146u8, 118u8, 90u8, 106u8, 171u8,
                149u8, 46u8, 94u8, 83u8, 234u8, 119u8, 23u8, 83u8, 50u8, 241u8, 61u8,
            ],
            [
                111u8, 129u8, 184u8, 173u8, 7u8, 128u8, 160u8, 254u8, 188u8, 104u8,
                122u8, 58u8, 115u8, 177u8, 129u8, 67u8, 55u8, 34u8, 180u8, 190u8, 48u8,
                247u8, 240u8, 160u8, 36u8, 22u8, 159u8, 81u8, 97u8, 38u8, 114u8, 135u8,
            ],
            [
                120u8, 22u8, 15u8, 11u8, 27u8, 43u8, 50u8, 181u8, 42u8, 0u8, 118u8,
                216u8, 240u8, 247u8, 8u8, 136u8, 104u8, 123u8, 167u8, 2u8, 164u8, 217u8,
                147u8, 213u8, 90u8, 200u8, 217u8, 50u8, 125u8, 87u8, 161u8, 39u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                157u8, 76u8, 55u8, 121u8, 168u8, 35u8, 170u8, 132u8, 178u8, 13u8, 210u8,
                232u8, 85u8, 30u8, 110u8, 217u8, 90u8, 221u8, 188u8, 86u8, 47u8, 59u8,
                196u8, 155u8, 30u8, 104u8, 138u8, 183u8, 133u8, 176u8, 93u8, 157u8,
            ],
            [
                188u8, 63u8, 123u8, 126u8, 119u8, 163u8, 149u8, 193u8, 86u8, 194u8, 77u8,
                184u8, 168u8, 167u8, 133u8, 2u8, 9u8, 178u8, 223u8, 113u8, 162u8, 86u8,
                18u8, 146u8, 238u8, 162u8, 33u8, 227u8, 43u8, 245u8, 212u8, 103u8,
            ],
            [
                200u8, 83u8, 185u8, 251u8, 198u8, 38u8, 87u8, 8u8, 207u8, 196u8, 115u8,
                239u8, 209u8, 206u8, 41u8, 177u8, 154u8, 54u8, 22u8, 179u8, 237u8, 204u8,
                174u8, 175u8, 113u8, 164u8, 166u8, 183u8, 120u8, 203u8, 1u8, 14u8,
            ],
            [
                250u8, 121u8, 117u8, 133u8, 201u8, 130u8, 125u8, 89u8, 167u8, 105u8,
                78u8, 243u8, 130u8, 36u8, 31u8, 26u8, 3u8, 206u8, 214u8, 161u8, 162u8,
                180u8, 53u8, 59u8, 53u8, 147u8, 154u8, 188u8, 77u8, 4u8, 178u8, 134u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(IntentFunded),
            ::core::stringify!(IntentUnclaimed),
            ::core::stringify!(ReceiverIntentParams),
            ::core::stringify!(IntentSettled),
            ::core::stringify!(IntentClosed),
            ::core::stringify!(IntentCreated),
            ::core::stringify!(EventAppended),
            ::core::stringify!(OwnershipTransferred),
            ::core::stringify!(RecommendedIntentFeeSet),
            ::core::stringify!(IntentClaimed),
            ::core::stringify!(ReceiverIntentFeeSnap),
            ::core::stringify!(IntentSolved),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <IntentFunded as alloy_sol_types::SolEvent>::SIGNATURE,
            <IntentUnclaimed as alloy_sol_types::SolEvent>::SIGNATURE,
            <ReceiverIntentParams as alloy_sol_types::SolEvent>::SIGNATURE,
            <IntentSettled as alloy_sol_types::SolEvent>::SIGNATURE,
            <IntentClosed as alloy_sol_types::SolEvent>::SIGNATURE,
            <IntentCreated as alloy_sol_types::SolEvent>::SIGNATURE,
            <EventAppended as alloy_sol_types::SolEvent>::SIGNATURE,
            <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE,
            <RecommendedIntentFeeSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <IntentClaimed as alloy_sol_types::SolEvent>::SIGNATURE,
            <ReceiverIntentFeeSnap as alloy_sol_types::SolEvent>::SIGNATURE,
            <IntentSolved as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for UntronIntentsEvents {
        const NAME: &'static str = "UntronIntentsEvents";
        const COUNT: usize = 12usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<EventAppended as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EventAppended as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::EventAppended)
                }
                Some(<IntentClaimed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <IntentClaimed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::IntentClaimed)
                }
                Some(<IntentClosed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <IntentClosed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::IntentClosed)
                }
                Some(<IntentCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <IntentCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::IntentCreated)
                }
                Some(<IntentFunded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <IntentFunded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::IntentFunded)
                }
                Some(<IntentSettled as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <IntentSettled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::IntentSettled)
                }
                Some(<IntentSolved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <IntentSolved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::IntentSolved)
                }
                Some(<IntentUnclaimed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <IntentUnclaimed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::IntentUnclaimed)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(
                    <ReceiverIntentFeeSnap as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ReceiverIntentFeeSnap as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ReceiverIntentFeeSnap)
                }
                Some(
                    <ReceiverIntentParams as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ReceiverIntentParams as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ReceiverIntentParams)
                }
                Some(
                    <RecommendedIntentFeeSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <RecommendedIntentFeeSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::RecommendedIntentFeeSet)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for UntronIntentsEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::EventAppended(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::IntentClaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::IntentClosed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::IntentCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::IntentFunded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::IntentSettled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::IntentSolved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::IntentUnclaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ReceiverIntentFeeSnap(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ReceiverIntentParams(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RecommendedIntentFeeSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::EventAppended(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::IntentClaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::IntentClosed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::IntentCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::IntentFunded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::IntentSettled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::IntentSolved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::IntentUnclaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ReceiverIntentFeeSnap(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ReceiverIntentParams(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RecommendedIntentFeeSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`UntronIntents`](self) contract instance.

See the [wrapper's documentation](`UntronIntentsInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> UntronIntentsInstance<P, N> {
        UntronIntentsInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _owner: alloy::sol_types::private::Address,
        v3: alloy::sol_types::private::Address,
        usdt: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<UntronIntentsInstance<P, N>>,
    > {
        UntronIntentsInstance::<P, N>::deploy(__provider, _owner, v3, usdt)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _owner: alloy::sol_types::private::Address,
        v3: alloy::sol_types::private::Address,
        usdt: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        UntronIntentsInstance::<P, N>::deploy_builder(__provider, _owner, v3, usdt)
    }
    /**A [`UntronIntents`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`UntronIntents`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct UntronIntentsInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for UntronIntentsInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("UntronIntentsInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronIntentsInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`UntronIntents`](self) contract instance.

See the [wrapper's documentation](`UntronIntentsInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            _owner: alloy::sol_types::private::Address,
            v3: alloy::sol_types::private::Address,
            usdt: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<UntronIntentsInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider, _owner, v3, usdt);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            _owner: alloy::sol_types::private::Address,
            v3: alloy::sol_types::private::Address,
            usdt: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _owner,
                            v3,
                            usdt,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> UntronIntentsInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> UntronIntentsInstance<P, N> {
            UntronIntentsInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronIntentsInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`INTENT_CLAIM_DEPOSIT`] function.
        pub fn INTENT_CLAIM_DEPOSIT(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, INTENT_CLAIM_DEPOSITCall, N> {
            self.call_builder(&INTENT_CLAIM_DEPOSITCall)
        }
        ///Creates a new call builder for the [`RECEIVER_INTENT_DURATION`] function.
        pub fn RECEIVER_INTENT_DURATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, RECEIVER_INTENT_DURATIONCall, N> {
            self.call_builder(&RECEIVER_INTENT_DURATIONCall)
        }
        ///Creates a new call builder for the [`TIME_TO_FILL`] function.
        pub fn TIME_TO_FILL(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, TIME_TO_FILLCall, N> {
            self.call_builder(&TIME_TO_FILLCall)
        }
        ///Creates a new call builder for the [`USDT`] function.
        pub fn USDT(&self) -> alloy_contract::SolCallBuilder<&P, USDTCall, N> {
            self.call_builder(&USDTCall)
        }
        ///Creates a new call builder for the [`V3`] function.
        pub fn V3(&self) -> alloy_contract::SolCallBuilder<&P, V3Call, N> {
            self.call_builder(&V3Call)
        }
        ///Creates a new call builder for the [`claimIntent`] function.
        pub fn claimIntent(
            &self,
            id: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, claimIntentCall, N> {
            self.call_builder(&claimIntentCall { id })
        }
        ///Creates a new call builder for the [`claimVirtualReceiverIntent`] function.
        pub fn claimVirtualReceiverIntent(
            &self,
            forwarder: alloy::sol_types::private::Address,
            toTron: alloy::sol_types::private::Address,
            forwardSalt: alloy::sol_types::private::FixedBytes<32>,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, claimVirtualReceiverIntentCall, N> {
            self.call_builder(
                &claimVirtualReceiverIntentCall {
                    forwarder,
                    toTron,
                    forwardSalt,
                    token,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`closeIntent`] function.
        pub fn closeIntent(
            &self,
            id: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, closeIntentCall, N> {
            self.call_builder(&closeIntentCall { id })
        }
        ///Creates a new call builder for the [`createIntent`] function.
        pub fn createIntent(
            &self,
            intent: <Intent as alloy::sol_types::SolType>::RustType,
            deadline: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, createIntentCall, N> {
            self.call_builder(
                &createIntentCall {
                    intent,
                    deadline,
                },
            )
        }
        ///Creates a new call builder for the [`createIntentFromReceiver`] function.
        pub fn createIntentFromReceiver(
            &self,
            forwarder: alloy::sol_types::private::Address,
            toTron: alloy::sol_types::private::Address,
            forwardSalt: alloy::sol_types::private::FixedBytes<32>,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, createIntentFromReceiverCall, N> {
            self.call_builder(
                &createIntentFromReceiverCall {
                    forwarder,
                    toTron,
                    forwardSalt,
                    token,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`eventChainTip`] function.
        pub fn eventChainTip(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, eventChainTipCall, N> {
            self.call_builder(&eventChainTipCall)
        }
        ///Creates a new call builder for the [`eventSeq`] function.
        pub fn eventSeq(&self) -> alloy_contract::SolCallBuilder<&P, eventSeqCall, N> {
            self.call_builder(&eventSeqCall)
        }
        ///Creates a new call builder for the [`fundReceiverIntent`] function.
        pub fn fundReceiverIntent(
            &self,
            forwarder: alloy::sol_types::private::Address,
            toTron: alloy::sol_types::private::Address,
            forwardSalt: alloy::sol_types::private::FixedBytes<32>,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, fundReceiverIntentCall, N> {
            self.call_builder(
                &fundReceiverIntentCall {
                    forwarder,
                    toTron,
                    forwardSalt,
                    token,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`intents`] function.
        pub fn intents(
            &self,
            _0: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, intentsCall, N> {
            self.call_builder(&intentsCall(_0))
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<&P, ownerCall, N> {
            self.call_builder(&ownerCall)
        }
        ///Creates a new call builder for the [`proveIntentFill`] function.
        pub fn proveIntentFill(
            &self,
            id: alloy::sol_types::private::FixedBytes<32>,
            blocks: [alloy::sol_types::private::Bytes; 20usize],
            encodedTx: alloy::sol_types::private::Bytes,
            proof: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            index: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, proveIntentFillCall, N> {
            self.call_builder(
                &proveIntentFillCall {
                    id,
                    blocks,
                    encodedTx,
                    proof,
                    index,
                },
            )
        }
        ///Creates a new call builder for the [`receiverIntentId`] function.
        pub fn receiverIntentId(
            &self,
            forwarder: alloy::sol_types::private::Address,
            toTron: alloy::sol_types::private::Address,
            forwardSalt: alloy::sol_types::private::FixedBytes<32>,
            token: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, receiverIntentIdCall, N> {
            self.call_builder(
                &receiverIntentIdCall {
                    forwarder,
                    toTron,
                    forwardSalt,
                    token,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`recommendedIntentFee`] function.
        pub fn recommendedIntentFee(
            &self,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, recommendedIntentFeeCall, N> {
            self.call_builder(&recommendedIntentFeeCall { amount })
        }
        ///Creates a new call builder for the [`recommendedIntentFeeFlat`] function.
        pub fn recommendedIntentFeeFlat(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, recommendedIntentFeeFlatCall, N> {
            self.call_builder(&recommendedIntentFeeFlatCall)
        }
        ///Creates a new call builder for the [`recommendedIntentFeePpm`] function.
        pub fn recommendedIntentFeePpm(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, recommendedIntentFeePpmCall, N> {
            self.call_builder(&recommendedIntentFeePpmCall)
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall)
        }
        ///Creates a new call builder for the [`setRecommendedIntentFee`] function.
        pub fn setRecommendedIntentFee(
            &self,
            ppm: alloy::sol_types::private::primitives::aliases::U256,
            flat: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<&P, setRecommendedIntentFeeCall, N> {
            self.call_builder(
                &setRecommendedIntentFeeCall {
                    ppm,
                    flat,
                },
            )
        }
        ///Creates a new call builder for the [`settleIntent`] function.
        pub fn settleIntent(
            &self,
            id: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, settleIntentCall, N> {
            self.call_builder(&settleIntentCall { id })
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`unclaimIntent`] function.
        pub fn unclaimIntent(
            &self,
            id: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, unclaimIntentCall, N> {
            self.call_builder(&unclaimIntentCall { id })
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > UntronIntentsInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`EventAppended`] event.
        pub fn EventAppended_filter(
            &self,
        ) -> alloy_contract::Event<&P, EventAppended, N> {
            self.event_filter::<EventAppended>()
        }
        ///Creates a new event filter for the [`IntentClaimed`] event.
        pub fn IntentClaimed_filter(
            &self,
        ) -> alloy_contract::Event<&P, IntentClaimed, N> {
            self.event_filter::<IntentClaimed>()
        }
        ///Creates a new event filter for the [`IntentClosed`] event.
        pub fn IntentClosed_filter(&self) -> alloy_contract::Event<&P, IntentClosed, N> {
            self.event_filter::<IntentClosed>()
        }
        ///Creates a new event filter for the [`IntentCreated`] event.
        pub fn IntentCreated_filter(
            &self,
        ) -> alloy_contract::Event<&P, IntentCreated, N> {
            self.event_filter::<IntentCreated>()
        }
        ///Creates a new event filter for the [`IntentFunded`] event.
        pub fn IntentFunded_filter(&self) -> alloy_contract::Event<&P, IntentFunded, N> {
            self.event_filter::<IntentFunded>()
        }
        ///Creates a new event filter for the [`IntentSettled`] event.
        pub fn IntentSettled_filter(
            &self,
        ) -> alloy_contract::Event<&P, IntentSettled, N> {
            self.event_filter::<IntentSettled>()
        }
        ///Creates a new event filter for the [`IntentSolved`] event.
        pub fn IntentSolved_filter(&self) -> alloy_contract::Event<&P, IntentSolved, N> {
            self.event_filter::<IntentSolved>()
        }
        ///Creates a new event filter for the [`IntentUnclaimed`] event.
        pub fn IntentUnclaimed_filter(
            &self,
        ) -> alloy_contract::Event<&P, IntentUnclaimed, N> {
            self.event_filter::<IntentUnclaimed>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`ReceiverIntentFeeSnap`] event.
        pub fn ReceiverIntentFeeSnap_filter(
            &self,
        ) -> alloy_contract::Event<&P, ReceiverIntentFeeSnap, N> {
            self.event_filter::<ReceiverIntentFeeSnap>()
        }
        ///Creates a new event filter for the [`ReceiverIntentParams`] event.
        pub fn ReceiverIntentParams_filter(
            &self,
        ) -> alloy_contract::Event<&P, ReceiverIntentParams, N> {
            self.event_filter::<ReceiverIntentParams>()
        }
        ///Creates a new event filter for the [`RecommendedIntentFeeSet`] event.
        pub fn RecommendedIntentFeeSet_filter(
            &self,
        ) -> alloy_contract::Event<&P, RecommendedIntentFeeSet, N> {
            self.event_filter::<RecommendedIntentFeeSet>()
        }
    }
}
