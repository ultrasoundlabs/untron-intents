/**

Generated by the following Solidity interface...
```solidity
interface IntentsForwarder {
    struct Call {
        address to;
        uint256 value;
        bytes data;
    }
    struct PullRequest {
        uint256 targetChain;
        address payable beneficiary;
        bool beneficiaryClaimOnly;
        bytes32 intentHash;
        bytes32 forwardSalt;
        uint256 balance;
        address tokenIn;
        address tokenOut;
        Call[] swapData;
        bytes bridgeData;
    }

    error AlreadyInitialized();
    error InsufficientOutputAmount();
    error NewOwnerIsZeroAddress();
    error PullerUnauthorized();
    error SwapOnEphemeralReceiversNotAllowed();
    error Unauthorized();
    error UnsupportedOutputToken();

    event BridgeInitiated(bytes32 indexed forwardId, address indexed bridger, address indexed tokenOut, uint256 amountIn, uint256 targetChain);
    event BridgersSet(address indexed usdtBridger, address indexed usdcBridger);
    event EventAppended(uint256 indexed eventSeq, bytes32 indexed prevTip, bytes32 indexed newTip, bytes32 eventSignature, bytes abiEncodedEventData);
    event ForwardCompleted(bytes32 indexed forwardId, bool ephemeral, uint256 amountPulled, uint256 amountForwarded, uint256 relayerRebate, uint256 msgValueRefunded, bool settledLocally, address bridger, uint256 expectedBridgeOut, bytes32 bridgeDataHash);
    event ForwardStarted(bytes32 indexed forwardId, bytes32 indexed baseReceiverSalt, bytes32 indexed forwardSalt, bytes32 intentHash, uint256 targetChain, address beneficiary, bool beneficiaryClaimOnly, uint256 balanceParam, address tokenIn, address tokenOut, address receiverUsed, address ephemeralReceiver);
    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
    event QuoterSet(address indexed tokenIn, address indexed quoter);
    event ReceiverDeployed(bytes32 indexed receiverSalt, address indexed receiver, address implementation);
    event SwapExecuted(bytes32 indexed forwardId, address indexed tokenIn, address indexed tokenOut, uint256 minOut, uint256 actualOut);

    constructor(address _usdt, address _usdc, address _owner);

    receive() external payable;

    function RECEIVER_BYTECODE_HASH() external view returns (bytes32);
    function RECEIVER_IMPLEMENTATION() external view returns (address);
    function SWAP_EXECUTOR() external view returns (address);
    function USDC() external view returns (address);
    function USDT() external view returns (address);
    function eventChainTip() external view returns (bytes32);
    function eventSeq() external view returns (uint256);
    function getReceiver(bytes32 salt) external returns (address receiver);
    function owner() external view returns (address result);
    function predictReceiverAddress(bytes32 salt) external view returns (address payable predicted);
    function pullFromReceiver(PullRequest memory req) external payable returns (uint256 amountOut);
    function quoterByToken(address) external view returns (address);
    function renounceOwnership() external payable;
    function setBridgers(address _usdtBridger, address _usdcBridger) external;
    function setQuoter(address targetToken, address quoter) external;
    function transferOwnership(address newOwner) external payable;
    function usdcBridger() external view returns (address);
    function usdtBridger() external view returns (address);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "_usdt",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_usdc",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "_owner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "RECEIVER_BYTECODE_HASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "RECEIVER_IMPLEMENTATION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SWAP_EXECUTOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract SwapExecutor"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "USDC",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "USDT",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eventChainTip",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eventSeq",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getReceiver",
    "inputs": [
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "receiver",
        "type": "address",
        "internalType": "contract UntronReceiver"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "result",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "predictReceiverAddress",
    "inputs": [
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "predicted",
        "type": "address",
        "internalType": "address payable"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pullFromReceiver",
    "inputs": [
      {
        "name": "req",
        "type": "tuple",
        "internalType": "struct IntentsForwarder.PullRequest",
        "components": [
          {
            "name": "targetChain",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "beneficiary",
            "type": "address",
            "internalType": "address payable"
          },
          {
            "name": "beneficiaryClaimOnly",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "intentHash",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "forwardSalt",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "balance",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "tokenIn",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "tokenOut",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "swapData",
            "type": "tuple[]",
            "internalType": "struct Call[]",
            "components": [
              {
                "name": "to",
                "type": "address",
                "internalType": "address"
              },
              {
                "name": "value",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "data",
                "type": "bytes",
                "internalType": "bytes"
              }
            ]
          },
          {
            "name": "bridgeData",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "amountOut",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "quoterByToken",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IQuoter"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "setBridgers",
    "inputs": [
      {
        "name": "_usdtBridger",
        "type": "address",
        "internalType": "contract IBridger"
      },
      {
        "name": "_usdcBridger",
        "type": "address",
        "internalType": "contract IBridger"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setQuoter",
    "inputs": [
      {
        "name": "targetToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "quoter",
        "type": "address",
        "internalType": "contract IQuoter"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "usdcBridger",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridger"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "usdtBridger",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "contract IBridger"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "event",
    "name": "BridgeInitiated",
    "inputs": [
      {
        "name": "forwardId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "bridger",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenOut",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amountIn",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "targetChain",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BridgersSet",
    "inputs": [
      {
        "name": "usdtBridger",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "usdcBridger",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EventAppended",
    "inputs": [
      {
        "name": "eventSeq",
        "type": "uint256",
        "indexed": true,
        "internalType": "uint256"
      },
      {
        "name": "prevTip",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newTip",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "eventSignature",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "abiEncodedEventData",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ForwardCompleted",
    "inputs": [
      {
        "name": "forwardId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "ephemeral",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "amountPulled",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amountForwarded",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "relayerRebate",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "msgValueRefunded",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "settledLocally",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "bridger",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "expectedBridgeOut",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "bridgeDataHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ForwardStarted",
    "inputs": [
      {
        "name": "forwardId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "baseReceiverSalt",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "forwardSalt",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "intentHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "targetChain",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "beneficiary",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "beneficiaryClaimOnly",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "balanceParam",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "tokenIn",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "tokenOut",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "receiverUsed",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "ephemeralReceiver",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "oldOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "QuoterSet",
    "inputs": [
      {
        "name": "tokenIn",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "quoter",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ReceiverDeployed",
    "inputs": [
      {
        "name": "receiverSalt",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "receiver",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "implementation",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SwapExecuted",
    "inputs": [
      {
        "name": "forwardId",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "tokenIn",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenOut",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "minOut",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "actualOut",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AlreadyInitialized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientOutputAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NewOwnerIsZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PullerUnauthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SwapOnEphemeralReceiversNotAllowed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Unauthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnsupportedOutputToken",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod IntentsForwarder {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6101208060405234610514576060816128ba80380380916100208285610518565b833981010312610514576100338161053b565b61004b60406100446020850161053b565b930161053b565b6040516101a081016001600160401b03811182821017610500576020915f9160405261016281528281017f4a757374696e2053756e20697320726573706f6e7369626c6520666f7220736581527f7474696e67206261636b2074686520696e6576697461626c6520676c6f62616c60408301527f20737461626c65636f696e207265766f6c7574696f6e2062792079656172732060608301527f7468726f756768206578706c6f6974696e672054726f6e20555344542773206e60808301527f6574776f726b206566666563747320616e6420696d706f73696e672076656e6460a08301527f6f72206c6f636b2d696e206f6e2068756e6472656473206f66206d696c6c696f60c08301527f6e73206f662070656f706c6520696e2074686520546869726420576f726c642c60e08301527f2077686f2072656c79206f6e20737461626c65636f696e7320666f722072656d6101008301527f697474616e63657320616e6420746f2073746f726520746865697220736176696101208301527f6e677320696e20756e737461626c652c206f766572726567756c6174656420656101408301527f636f6e6f6d6965732e204c6574277320556e74726f6e207468652050656f706c61016083015261329760f11b61018083015261027260366040518093878201957f496e74656e7473466f72776172646572496e6465780a0000000000000000000087525180918484015e810186838201520301601f198101835282610518565b604051918291518091835e8101838152039060025afa156104f5575f515f5560018060a01b031680638b78c6d8195560405190805f5f51602061289a5f395f51905f528180a360208201905f82526040830152604082526102d4606083610518565b6001805401806001555f549160205f604051828101908682528560408201524360608201524260808201525f51602061289a5f395f51905f5260a082015261033660c0828a5180898484015e810186838201520301601f198101835282610518565b604051918291518091835e8101838152039060025afa156104f5577f78160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a1279060605f5195865f556040519283915f51602061289a5f395f51905f528352604060208401525180918160408501528484015e5f828201840152601f01601f19168101030190a460405161019f8082016001600160401b038111838210176105005782916122e4833903905ff080156104f5576001600160a01b03811660c0526040517f3d602d80600a3d3981f3363d3d373d3d3d363d730000000000000000000000006020820190815260609290921b6001600160601b03191660348201526e5af43d82803e903d91602b57fd5bf360881b604882015260378152610459605782610518565b51902060a0526040516104178082016001600160401b03811183821017610500578291612483833903905ff080156104f55760805260e05261010052604051611d94908161055082396080518181816101f80152611321015260a0518181816108900152610a76015260c0518181816101b40152610ad9015260e051818181610805015261103301526101005181818161079501526112340152f35b6040513d5f823e3d90fd5b634e487b7160e01b5f52604160045260245ffd5b5f80fd5b601f909101601f19168101906001600160401b0382119082101761050057604052565b51906001600160a01b03821682036105145756fe6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c80627f2b66146101385780630496c2f1146101335780630b3458791461012e5780631ad1087b146101295780632b0f3ee4146101245780633fea34881461011f5780634d53e9311461011a57806352d62f80146101155780636264257a14610110578063715018a61461010b57806389a30271146101065780638da5cb5b14610101578063c54e44eb146100fc578063d08bd89f146100f7578063e24d5c35146100f2578063e8e3cc1c146100ed578063ed61a911146100e85763f2fde38b0361000e576108cb565b6108b3565b610879565b61085c565b610834565b6107f0565b6107c4565b610780565b610714565b61065b565b610633565b610617565b6105ed565b610518565b610227565b6101e3565b61019f565b610152565b6001600160a01b0381160361014e57565b5f80fd5b3461014e57602036600319011261014e5760043561016f8161013d565b60018060a01b03165f526004602052602060018060a01b0360405f205416604051908152f35b5f91031261014e57565b3461014e575f36600319011261014e576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461014e575f36600319011261014e576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b602036600319011261014e5767ffffffffffffffff6004351161014e576101406004353603600319011261014e576105086102e06104f760a46004350135600435600401356104ae61027d60246004350161095f565b61028b60446004350161096c565b604080516020810186815260609490941b6bffffffffffffffffffffffff19169181019190915290151560f81b605482015260043560640135605582018190529681607581015b03601f19810183528261098d565b51902094608460043501359561049d878661033c61030260e46004350161095f565b6102d26040519384926020840196898892909160749492845260208401526001600160601b03199060601b16604083015260548201520190565b519020928261034f60c46004350161095f565b6103e88b6102d261036460e46004350161095f565b8c8c61037460246004350161095f565b9161038360446004350161096c565b6040805130602082019081524692820192909252606081019b909b5260808b01979097526001600160a01b0398891660a08b015293881660c08a015260e089015261010088015290941661012086015292151561014085015292918290610160820190565b519020986103f46109b4565b968a8852610417610410610124600435016004356004016109dd565b3691610a10565b805160209182012090890152881561050c5761044161043587610a56565b6001600160a01b031690565b918961044f61043589610a56565b948d61045f60246004350161095f565b9461046e60446004350161096c565b9261047d60c46004350161095f565b958b61048d60e46004350161095f565b986001600160a01b031694610bb7565b600435600401918515159188610f0d565b805194602082019586516040840151906060850151926104d16080870151151590565b60a087015190959060209060c0906001600160a01b031698015198015198151590611463565b516040519081529081906020820190565b0390f35b61044161043586610a56565b3461014e57604036600319011261014e576100186004356105388161013d565b6105d6602435916105488361013d565b61055061153e565b60018060a01b031691826001600160601b0360a01b600254161760025560018060a01b031691826001600160601b0360a01b60035416176003556102d260405193828186947f14c028d3d668eb3454bce44d123ceeeb9fb4e74bee073c41f4001e63f06130945f80a36001600160a01b0390811660208501521660408301526060820190565b61159e565b602090600319011261014e5760043590565b3461014e576020610605610600366105db565b610a56565b6040516001600160a01b039091168152f35b3461014e575f36600319011261014e5760205f54604051908152f35b3461014e575f36600319011261014e576002546040516001600160a01b039091168152602090f35b3461014e57604036600319011261014e5761001860043561067b8161013d565b61070f60243561068a8161013d565b61069261153e565b6001600160a01b038381165f8181526004602052604080822080546001600160a01b0319169590941694851790935591519485936102d293909283917f2e3d7d02ba3c4bd8b1f8995cd3a23ef0193922ebc4ee23249ead4d0ca2e34c689080a36001600160a01b0390811660208501521660408301526060820190565b611665565b5f36600319011261014e5761072761153e565b610018638b78c6d819545f638b78c6d8195561077b60405180925f60018060a01b0382165f516020611d485f395f51905f528280a36001600160a01b031660208201525f604091820152825260608261098d565b61193d565b3461014e575f36600319011261014e576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461014e575f36600319011261014e57638b78c6d819546040516001600160a01b039091168152602090f35b3461014e575f36600319011261014e576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461014e575f36600319011261014e576003546040516001600160a01b039091168152602090f35b3461014e575f36600319011261014e576020600154604051908152f35b3461014e575f36600319011261014e5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461014e5760206106056108c6366105db565b610ab9565b602036600319011261014e576004356108e38161013d565b6108eb61153e565b8060601b1561095257638b78c6d81980546001600160a01b039283169182905560405161001893909261077b9284926102d2929190829082165f516020611d485f395f51905f525f80a36001600160a01b0390811660208501521660408301526060820190565b637448fbae5f526004601cfd5b356109698161013d565b90565b35801515810361014e5790565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff8211176109af57604052565b610979565b604051906040820182811067ffffffffffffffff8211176109af576040525f6020838281520152565b903590601e198136030182121561014e570180359067ffffffffffffffff821161014e5760200191813603831361014e57565b92919267ffffffffffffffff82116109af5760405191610a3a601f8201601f19166020018461098d565b82948184528183011161014e578281602093845f960137010152565b60405190602082019060ff60f81b82523060601b602184015260358301527f0000000000000000000000000000000000000000000000000000000000000000605583015260558252610aa960758361098d565b905190206001600160a01b031690565b906001600160a01b03610acb83610a56565b1691823b15610ad75750565b7f000000000000000000000000000000000000000000000000000000000000000090806037604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528460601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201525ff5918215610baf576040516001600160a01b03918216808252610bad9490921690819084907f488f06a9ca9e19e1dd90c764cc79b765e8a3a089ef27d9a0e39dee21c764318890602090a36040519260208401526040830152606082015260608152610ba860808261098d565b61171b565b565b3d5f803e3d5ffd5b999484848484610bad9f9a95968f97610cd99f9a9860209f9a6102d29f9a8f918f928f938f948f958f968f977f7391f14355eff1e559e381f5bf49886a77da7c4fdd33c6fc2e0142269c561c599861012098604051988952602089015260018060a01b0316604088015215156060870152608086015260018060a01b031660a085015260018060a01b031660c084015260018060a01b031660e083015260018060a01b0316610100820152a46040519e8f9d8e0190815260208101919091526040810191909152606081019190915260808101919091526001600160a01b0391821660a082015291151560c083015260e08201929092529181166101008301529182166101208201529181166101408301529091166101608201526101800190565b6117d1565b6040519060e0820182811067ffffffffffffffff8211176109af576040525f60c0838281528260208201528260408201528260608201528260808201528260a08201520152565b6040513d5f823e3d90fd5b634e487b7160e01b5f52601160045260245ffd5b90600a8201809211610d5257565b610d30565b91908201809211610d5257565b9081602091031261014e575190565b903590601e198136030182121561014e570180359067ffffffffffffffff821161014e57602001918160051b3603831361014e57565b908060209392818452848401375f828201840152601f01601f1916010190565b9295949391908160808501608086525260a084019160a08160051b86010192825f90605e19813603015b848310610e2f57505050506001600160a01b03979097166020850152509450610bad929160609160408201526001600160a01b03909216910152565b909192939495609f1989820301855286358281121561014e5783018035610e558161013d565b6001600160a01b0316825260208181013590830152604081013536829003601e190181121561014e57016020813591019067ffffffffffffffff811161014e57803603821361014e57610eb8602092839260608681604060019901520191610da9565b980196950193019190610df3565b91908203918211610d5257565b6001600160a01b03918216815260208101929092529091166040820152606081019190915260a06080820181905261096993910191610da9565b949390610f18610cde565b9560a08301359485610f2c60c0860161095f565b90610f42610f3c60e0880161095f565b97610ab9565b948315611454575084905b15611439575b6001600160a01b0316803b1561014e5760405163f2d5d56b60e01b81526001600160a01b038316600482015260248101899052905f908290604490829084905af1801561118a5761141f575b508689526001600160a01b0386811692908216839003611281575b505083359146830361102d5750505050610fd66040820161096c565b80611015575b61100657610ff791610ff1602085930161095f565b90611a5e565b600160808401525b6020830152565b6336b507fb60e01b5f5260045ffd5b506110256104356020830161095f565b331415610fdc565b929491937f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031682149391841561123257506002546001600160a01b03165b6001600160a01b031660a08a01818152949091901561118f57856110da9260209247996110af6110a3308a6119cd565b926101208101906109dd565b60405163b14d361d60e01b8152978896879586959294926001600160a01b0316908d60048801610ed3565b039134905af1801561118a57611102915f9161115b575b50956110fd3447610d57565b610ec6565b8060608a01528061114b575b505b85850361113c5761113186936111379660c08b01525160018060a01b031690565b90611c34565b610fff565b6342301c2360e01b5f5260045ffd5b6111559033611a37565b5f61110e565b61117d915060203d602011611183575b611175818361098d565b810190610d64565b5f6110f1565b503d61116b565b610d25565b60209186915f6111eb95998d60603491015234611223575b6111c06111b4308a6119cd565b936101208101906109dd565b60405163b14d361d60e01b8152988997889687959294926001600160a01b0316908d60048801610ed3565b03925af190811561118a575f91611204575b5093611110565b61121d915060203d60201161118357611175818361098d565b5f6111fd565b61122d3433611a37565b6111a7565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031603611272576003546001600160a01b0316611073565b63b2ae855560e01b5f5260045ffd5b611410576113059660206112b86104356112ab8560018060a01b03165f52600460205260405f2090565b546001600160a01b031690565b6112c142610d44565b60405163520b935560e01b81526001600160a01b0380871660048301528b166024820152604481018590526064810191909152998a919082905f9082906084820190565b03925af190811561118a575f9889926113ee575b5060209082907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690611355908287611a5e565b896113646101008b018b610d73565b61138960409e929e519e8f9687958694638bccc18760e01b8652309360048701610dc9565b03925af190811561118a57876113c6938c9a5f946113cd575b506113c06040849c6113b48688610ec6565b91829101523384611a5e565b86611ae5565b5f80610fba565b6113e791945060203d60201161118357611175818361098d565b925f6113a2565b602091925061140990823d841161118357611175818361098d565b9190611319565b638fb4d10f60e01b5f5260045ffd5b8061142d5f6114339361098d565b80610195565b5f610f9f565b965061144e6001600160a01b038816826119cd565b96610f53565b61145d90610ab9565b90610f4d565b9590979294610bad99946102d2966115399994897f2e659081f44c4f56a18b00f3f9d136d7ee8396bc79163c4d61363ddcf4a4cb276101208e604051901515815284602082015285604082015286606082015287608082015288151560a082015260018060a01b038a1660c08201528a60e08201528b610100820152a26040519b8c9a60208c019693909a9998959261012098959261014089019c89521515602089015260408801526060870152608086015260a0850152151560c084015260018060a01b031660e08301526101008201520152565b611887565b638b78c6d81954330361154d57565b6382b429005f526004601cfd5b805191908290602001825e015f815290565b9060609260209183526040828401528051918291826040860152018484015e5f828201840152601f01601f1916010190565b60018054018060015560205f61160d81549360405190858583015260408201524360608201524260808201527f14c028d3d668eb3454bce44d123ceeeb9fb4e74bee073c41f4001e63f061309460a0820152611601816102d260c082018961155a565b6040519182809261155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f14c028d3d668eb3454bce44d123ceeeb9fb4e74bee073c41f4001e63f06130948361156c565b0390a4565b60018054018060015560205f6116c881549360405190858583015260408201524360608201524260808201527f2e3d7d02ba3c4bd8b1f8995cd3a23ef0193922ebc4ee23249ead4d0ca2e34c6860a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f2e3d7d02ba3c4bd8b1f8995cd3a23ef0193922ebc4ee23249ead4d0ca2e34c688361156c565b60018054018060015560205f61177e81549360405190858583015260408201524360608201524260808201527f488f06a9ca9e19e1dd90c764cc79b765e8a3a089ef27d9a0e39dee21c764318860a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f488f06a9ca9e19e1dd90c764cc79b765e8a3a089ef27d9a0e39dee21c76431888361156c565b60018054018060015560205f61183481549360405190858583015260408201524360608201524260808201527f7391f14355eff1e559e381f5bf49886a77da7c4fdd33c6fc2e0142269c561c5960a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f7391f14355eff1e559e381f5bf49886a77da7c4fdd33c6fc2e0142269c561c598361156c565b60018054018060015560205f6118ea81549360405190858583015260408201524360608201524260808201527f2e659081f44c4f56a18b00f3f9d136d7ee8396bc79163c4d61363ddcf4a4cb2760a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f2e659081f44c4f56a18b00f3f9d136d7ee8396bc79163c4d61363ddcf4a4cb278361156c565b60018054018060015560205f61198d81549360405190858583015260408201524360608201524260808201525f516020611d485f395f51905f5260a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182915f516020611d485f395f51905f528361156c565b6001600160a01b0316908115611a31576040516370a0823160e01b81526001600160a01b03909116600482015290602090829060249082905afa90811561118a575f91611a18575090565b610969915060203d60201161118357611175818361098d565b90503190565b5f913891839182916001600160a01b03165af115611a5157565b63b12d13eb5f526004601cfd5b91906001600160a01b03831615611ac9576001600160a01b031660145260345263a9059cbb60601b5f9081526020906044601082855af1908160015f51141615611aab575b50505f603452565b3b153d171015611abc575f80611aa3565b6390b8ec185f526004601cfd5b5f9250389183918291906001600160a01b03165af115611a5157565b60408051858152602081018790529295611b7e9592946102d29491939290916001600160a01b0380841692908a169188917f2f4c76c8d18f45069b0941499205a7fceaaa3caf9e2e6328f6a544cd339120f39190819081015b0390a46040805160208101969096526001600160a01b03978816908601529095166060840152608083019490945260a082019390935291829060c0820190565b60018054018060015560205f611be181549360405190858583015260408201524360608201524260808201527f2f4c76c8d18f45069b0941499205a7fceaaa3caf9e2e6328f6a544cd339120f360a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f2f4c76c8d18f45069b0941499205a7fceaaa3caf9e2e6328f6a544cd339120f38361156c565b60408051858152602081018790529295611c919592946102d29491939290916001600160a01b0380841692908a169188917f2dfcf646f953b41d2cd9d30bcf3f6cda5248efcd7733adff3a25e88f35b8afcb919081908101611b3e565b60018054018060015560205f611cf481549360405190858583015260408201524360608201524260808201527f2dfcf646f953b41d2cd9d30bcf3f6cda5248efcd7733adff3a25e88f35b8afcb60a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f2dfcf646f953b41d2cd9d30bcf3f6cda5248efcd7733adff3a25e88f35b8afcb8361156c56fe8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e078160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a127a164736f6c634300081b000a60a0806040523460285733608052610172908161002d8239608051818181606901526101360152f35b5f80fdfe608080604052600436101561001c575b50361561001a575f80fd5b005b5f3560e01c908163117803e314610124575063f2d5d56b1461003e575f61000f565b34610120576040366003190112610120576004356001600160a01b03811680820361012057602435907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316903382900361011157826100a157005b156100f55760145260345263a9059cbb60601b5f5260205f6044601082855af1908160015f511416156100d7575b50505f603452005b3b153d1710156100e8575f806100cf565b6390b8ec185f526004601cfd5b905f809350809138935af161001a5763b12d13eb5f526004601cfd5b6330cd747160e01b5f5260045ffd5b5f80fd5b34610120575f366003190112610120577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f3fea164736f6c634300081b000a60a08060405234602857336080526103ea908161002d823960805181818160d901526103010152f35b5f80fdfe608080604052600436101561001c575b50361561001a575f80fd5b005b5f3560e01c908163117803e3146102ef5750638bccc1871461003e575f61000f565b3461020b57608036600319011261020b5760043567ffffffffffffffff811161020b573660238201121561020b57806004013567ffffffffffffffff811161020b573660248260051b8401011161020b57602435916001600160a01b03831680840361020b576064356001600160a01b038116949085900361020b573068929eee149b4bd2126854146102e2573068929eee149b4bd21268557f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031633036102d3579293368390036082190193905f5b8681101561020f5760248160051b860101358681121561020b5785016024810135906001600160a01b038216820361020b576064810135604219368390030181121561020b5781016024018035919067ffffffffffffffff831161020b5760200191803603831361020b575f9360448594836040519485928337810186815203930135905af13d15610206573d67ffffffffffffffff81116101f257604051906101c9601f8201601f191660200183610330565b81525f60203d92013e5b156101e057600101610115565b6307f3476960e31b5f5260045260245ffd5b634e487b7160e01b5f52604160045260245ffd5b6101d3565b5f80fd5b5061021a3083610352565b9260443584106102c45783610241575b6020843868929eee149b4bd2126855604051908152f35b156102a0576014528160345263a9059cbb60601b5f5260205f6044601082855af1908160015f51141615610282575b50506020905f6034525b90828061022a565b3b153d171015610293578180610270565b6390b8ec185f526004601cfd5b5f808093508438935af1156102b75760209061027a565b63b12d13eb5f526004601cfd5b63bb2875c360e01b5f5260045ffd5b6330cd747160e01b5f5260045ffd5b63ab143c065f526004601cfd5b3461020b575f36600319011261020b577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b90601f8019910116810190811067ffffffffffffffff8211176101f257604052565b6001600160a01b03169081156103d7576040516370a0823160e01b81526001600160a01b03909116600482015290602090829060249082905afa9081156103cc575f9161039d575090565b90506020813d6020116103c4575b816103b860209383610330565b8101031261020b575190565b3d91506103ab565b6040513d5f823e3d90fd5b9050319056fea164736f6c634300081b000a8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"a\x01 \x80`@R4a\x05\x14W``\x81a(\xBA\x808\x03\x80\x91a\0 \x82\x85a\x05\x18V[\x839\x81\x01\x03\x12a\x05\x14Wa\x003\x81a\x05;V[a\0K`@a\0D` \x85\x01a\x05;V[\x93\x01a\x05;V[`@Qa\x01\xA0\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17a\x05\0W` \x91_\x91`@Ra\x01b\x81R\x82\x81\x01\x7FJustin Sun is responsible for se\x81R\x7Ftting back the inevitable global`@\x83\x01R\x7F stablecoin revolution by years ``\x83\x01R\x7Fthrough exploiting Tron USDT's n`\x80\x83\x01R\x7Fetwork effects and imposing vend`\xA0\x83\x01R\x7For lock-in on hundreds of millio`\xC0\x83\x01R\x7Fns of people in the Third World,`\xE0\x83\x01R\x7F who rely on stablecoins for rema\x01\0\x83\x01R\x7Fittances and to store their savia\x01 \x83\x01R\x7Fngs in unstable, overregulated ea\x01@\x83\x01R\x7Fconomies. Let's Untron the Peopla\x01`\x83\x01Ra2\x97`\xF1\x1Ba\x01\x80\x83\x01Ra\x02r`6`@Q\x80\x93\x87\x82\x01\x95\x7FIntentsForwarderIndex\n\0\0\0\0\0\0\0\0\0\0\x87RQ\x80\x91\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x05\x18V[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x04\xF5W_Q_U`\x01\x80`\xA0\x1B\x03\x16\x80c\x8Bx\xC6\xD8\x19U`@Q\x90\x80__Q` a(\x9A_9_Q\x90_R\x81\x80\xA3` \x82\x01\x90_\x82R`@\x83\x01R`@\x82Ra\x02\xD4``\x83a\x05\x18V[`\x01\x80T\x01\x80`\x01U_T\x91` _`@Q\x82\x81\x01\x90\x86\x82R\x85`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R_Q` a(\x9A_9_Q\x90_R`\xA0\x82\x01Ra\x036`\xC0\x82\x8AQ\x80\x89\x84\x84\x01^\x81\x01\x86\x83\x82\x01R\x03\x01`\x1F\x19\x81\x01\x83R\x82a\x05\x18V[`@Q\x91\x82\x91Q\x80\x91\x83^\x81\x01\x83\x81R\x03\x90`\x02Z\xFA\x15a\x04\xF5W\x7Fx\x16\x0F\x0B\x1B+2\xB5*\0v\xD8\xF0\xF7\x08\x88h{\xA7\x02\xA4\xD9\x93\xD5Z\xC8\xD92}W\xA1'\x90``_Q\x95\x86_U`@Q\x92\x83\x91_Q` a(\x9A_9_Q\x90_R\x83R`@` \x84\x01RQ\x80\x91\x81`@\x85\x01R\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x81\x01\x03\x01\x90\xA4`@Qa\x01\x9F\x80\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x05\0W\x82\x91a\"\xE4\x839\x03\x90_\xF0\x80\x15a\x04\xF5W`\x01`\x01`\xA0\x1B\x03\x81\x16`\xC0R`@Q\x7F=`-\x80`\n=9\x81\xF36==7===6=s\0\0\0\0\0\0\0\0\0\0\0\0` \x82\x01\x90\x81R``\x92\x90\x92\x1B`\x01`\x01``\x1B\x03\x19\x16`4\x82\x01RnZ\xF4=\x82\x80>\x90=\x91`+W\xFD[\xF3`\x88\x1B`H\x82\x01R`7\x81Ra\x04Y`W\x82a\x05\x18V[Q\x90 `\xA0R`@Qa\x04\x17\x80\x82\x01`\x01`\x01`@\x1B\x03\x81\x11\x83\x82\x10\x17a\x05\0W\x82\x91a$\x83\x839\x03\x90_\xF0\x80\x15a\x04\xF5W`\x80R`\xE0Ra\x01\0R`@Qa\x1D\x94\x90\x81a\x05P\x829`\x80Q\x81\x81\x81a\x01\xF8\x01Ra\x13!\x01R`\xA0Q\x81\x81\x81a\x08\x90\x01Ra\nv\x01R`\xC0Q\x81\x81\x81a\x01\xB4\x01Ra\n\xD9\x01R`\xE0Q\x81\x81\x81a\x08\x05\x01Ra\x103\x01Ra\x01\0Q\x81\x81\x81a\x07\x95\x01Ra\x124\x01R\xF3[`@Q=_\x82>=\x90\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[_\x80\xFD[`\x1F\x90\x91\x01`\x1F\x19\x16\x81\x01\x90`\x01`\x01`@\x1B\x03\x82\x11\x90\x82\x10\x17a\x05\0W`@RV[Q\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x05\x14WV\xFE`\x80`@R`\x046\x10\x15a\0\x1AW[6\x15a\0\x18W_\x80\xFD[\0[_5`\xE0\x1C\x80b\x7F+f\x14a\x018W\x80c\x04\x96\xC2\xF1\x14a\x013W\x80c\x0B4Xy\x14a\x01.W\x80c\x1A\xD1\x08{\x14a\x01)W\x80c+\x0F>\xE4\x14a\x01$W\x80c?\xEA4\x88\x14a\x01\x1FW\x80cMS\xE91\x14a\x01\x1AW\x80cR\xD6/\x80\x14a\x01\x15W\x80cbd%z\x14a\x01\x10W\x80cqP\x18\xA6\x14a\x01\x0BW\x80c\x89\xA3\x02q\x14a\x01\x06W\x80c\x8D\xA5\xCB[\x14a\x01\x01W\x80c\xC5ND\xEB\x14a\0\xFCW\x80c\xD0\x8B\xD8\x9F\x14a\0\xF7W\x80c\xE2M\\5\x14a\0\xF2W\x80c\xE8\xE3\xCC\x1C\x14a\0\xEDW\x80c\xEDa\xA9\x11\x14a\0\xE8Wc\xF2\xFD\xE3\x8B\x03a\0\x0EWa\x08\xCBV[a\x08\xB3V[a\x08yV[a\x08\\V[a\x084V[a\x07\xF0V[a\x07\xC4V[a\x07\x80V[a\x07\x14V[a\x06[V[a\x063V[a\x06\x17V[a\x05\xEDV[a\x05\x18V[a\x02'V[a\x01\xE3V[a\x01\x9FV[a\x01RV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x03a\x01NWV[_\x80\xFD[4a\x01NW` 6`\x03\x19\x01\x12a\x01NW`\x045a\x01o\x81a\x01=V[`\x01\x80`\xA0\x1B\x03\x16_R`\x04` R` `\x01\x80`\xA0\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[_\x91\x03\x12a\x01NWV[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[` 6`\x03\x19\x01\x12a\x01NWg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x045\x11a\x01NWa\x01@`\x0456\x03`\x03\x19\x01\x12a\x01NWa\x05\x08a\x02\xE0a\x04\xF7`\xA4`\x045\x015`\x045`\x04\x015a\x04\xAEa\x02}`$`\x045\x01a\t_V[a\x02\x8B`D`\x045\x01a\tlV[`@\x80Q` \x81\x01\x86\x81R``\x94\x90\x94\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x91\x81\x01\x91\x90\x91R\x90\x15\x15`\xF8\x1B`T\x82\x01R`\x045`d\x015`U\x82\x01\x81\x90R\x96\x81`u\x81\x01[\x03`\x1F\x19\x81\x01\x83R\x82a\t\x8DV[Q\x90 \x94`\x84`\x045\x015\x95a\x04\x9D\x87\x86a\x03<a\x03\x02`\xE4`\x045\x01a\t_V[a\x02\xD2`@Q\x93\x84\x92` \x84\x01\x96\x89\x88\x92\x90\x91`t\x94\x92\x84R` \x84\x01R`\x01`\x01``\x1B\x03\x19\x90``\x1B\x16`@\x83\x01R`T\x82\x01R\x01\x90V[Q\x90 \x92\x82a\x03O`\xC4`\x045\x01a\t_V[a\x03\xE8\x8Ba\x02\xD2a\x03d`\xE4`\x045\x01a\t_V[\x8C\x8Ca\x03t`$`\x045\x01a\t_V[\x91a\x03\x83`D`\x045\x01a\tlV[`@\x80Q0` \x82\x01\x90\x81RF\x92\x82\x01\x92\x90\x92R``\x81\x01\x9B\x90\x9BR`\x80\x8B\x01\x97\x90\x97R`\x01`\x01`\xA0\x1B\x03\x98\x89\x16`\xA0\x8B\x01R\x93\x88\x16`\xC0\x8A\x01R`\xE0\x89\x01Ra\x01\0\x88\x01R\x90\x94\x16a\x01 \x86\x01R\x92\x15\x15a\x01@\x85\x01R\x92\x91\x82\x90a\x01`\x82\x01\x90V[Q\x90 \x98a\x03\xF4a\t\xB4V[\x96\x8A\x88Ra\x04\x17a\x04\x10a\x01$`\x045\x01`\x045`\x04\x01a\t\xDDV[6\x91a\n\x10V[\x80Q` \x91\x82\x01 \x90\x89\x01R\x88\x15a\x05\x0CWa\x04Aa\x045\x87a\nVV[`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x91\x89a\x04Oa\x045\x89a\nVV[\x94\x8Da\x04_`$`\x045\x01a\t_V[\x94a\x04n`D`\x045\x01a\tlV[\x92a\x04}`\xC4`\x045\x01a\t_V[\x95\x8Ba\x04\x8D`\xE4`\x045\x01a\t_V[\x98`\x01`\x01`\xA0\x1B\x03\x16\x94a\x0B\xB7V[`\x045`\x04\x01\x91\x85\x15\x15\x91\x88a\x0F\rV[\x80Q\x94` \x82\x01\x95\x86Q`@\x84\x01Q\x90``\x85\x01Q\x92a\x04\xD1`\x80\x87\x01Q\x15\x15\x90V[`\xA0\x87\x01Q\x90\x95\x90` \x90`\xC0\x90`\x01`\x01`\xA0\x1B\x03\x16\x98\x01Q\x98\x01Q\x98\x15\x15\x90a\x14cV[Q`@Q\x90\x81R\x90\x81\x90` \x82\x01\x90V[\x03\x90\xF3[a\x04Aa\x045\x86a\nVV[4a\x01NW`@6`\x03\x19\x01\x12a\x01NWa\0\x18`\x045a\x058\x81a\x01=V[a\x05\xD6`$5\x91a\x05H\x83a\x01=V[a\x05Pa\x15>V[`\x01\x80`\xA0\x1B\x03\x16\x91\x82`\x01`\x01``\x1B\x03`\xA0\x1B`\x02T\x16\x17`\x02U`\x01\x80`\xA0\x1B\x03\x16\x91\x82`\x01`\x01``\x1B\x03`\xA0\x1B`\x03T\x16\x17`\x03Ua\x02\xD2`@Q\x93\x82\x81\x86\x94\x7F\x14\xC0(\xD3\xD6h\xEB4T\xBC\xE4M\x12<\xEE\xEB\x9F\xB4\xE7K\xEE\x07<A\xF4\0\x1Ec\xF0a0\x94_\x80\xA3`\x01`\x01`\xA0\x1B\x03\x90\x81\x16` \x85\x01R\x16`@\x83\x01R``\x82\x01\x90V[a\x15\x9EV[` \x90`\x03\x19\x01\x12a\x01NW`\x045\x90V[4a\x01NW` a\x06\x05a\x06\x006a\x05\xDBV[a\nVV[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW` _T`@Q\x90\x81R\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`\x02T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x01NW`@6`\x03\x19\x01\x12a\x01NWa\0\x18`\x045a\x06{\x81a\x01=V[a\x07\x0F`$5a\x06\x8A\x81a\x01=V[a\x06\x92a\x15>V[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x95\x90\x94\x16\x94\x85\x17\x90\x93U\x91Q\x94\x85\x93a\x02\xD2\x93\x90\x92\x83\x91\x7F.=}\x02\xBA<K\xD8\xB1\xF8\x99\\\xD3\xA2>\xF0\x199\"\xEB\xC4\xEE#$\x9E\xADM\x0C\xA2\xE3Lh\x90\x80\xA3`\x01`\x01`\xA0\x1B\x03\x90\x81\x16` \x85\x01R\x16`@\x83\x01R``\x82\x01\x90V[a\x16eV[_6`\x03\x19\x01\x12a\x01NWa\x07'a\x15>V[a\0\x18c\x8Bx\xC6\xD8\x19T_c\x8Bx\xC6\xD8\x19Ua\x07{`@Q\x80\x92_`\x01\x80`\xA0\x1B\x03\x82\x16_Q` a\x1DH_9_Q\x90_R\x82\x80\xA3`\x01`\x01`\xA0\x1B\x03\x16` \x82\x01R_`@\x91\x82\x01R\x82R``\x82a\t\x8DV[a\x19=V[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NWc\x8Bx\xC6\xD8\x19T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`\x03T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW` `\x01T`@Q\x90\x81R\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW` `@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xF3[4a\x01NW` a\x06\x05a\x08\xC66a\x05\xDBV[a\n\xB9V[` 6`\x03\x19\x01\x12a\x01NW`\x045a\x08\xE3\x81a\x01=V[a\x08\xEBa\x15>V[\x80``\x1B\x15a\tRWc\x8Bx\xC6\xD8\x19\x80T`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x91\x82\x90U`@Qa\0\x18\x93\x90\x92a\x07{\x92\x84\x92a\x02\xD2\x92\x91\x90\x82\x90\x82\x16_Q` a\x1DH_9_Q\x90_R_\x80\xA3`\x01`\x01`\xA0\x1B\x03\x90\x81\x16` \x85\x01R\x16`@\x83\x01R``\x82\x01\x90V[ctH\xFB\xAE_R`\x04`\x1C\xFD[5a\ti\x81a\x01=V[\x90V[5\x80\x15\x15\x81\x03a\x01NW\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\t\xAFW`@RV[a\tyV[`@Q\x90`@\x82\x01\x82\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\t\xAFW`@R_` \x83\x82\x81R\x01RV[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x01NW\x01\x805\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01NW` \x01\x91\x816\x03\x83\x13a\x01NWV[\x92\x91\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\t\xAFW`@Q\x91a\n:`\x1F\x82\x01`\x1F\x19\x16` \x01\x84a\t\x8DV[\x82\x94\x81\x84R\x81\x83\x01\x11a\x01NW\x82\x81` \x93\x84_\x96\x017\x01\x01RV[`@Q\x90` \x82\x01\x90`\xFF`\xF8\x1B\x82R0``\x1B`!\x84\x01R`5\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`U\x83\x01R`U\x82Ra\n\xA9`u\x83a\t\x8DV[\x90Q\x90 `\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03a\n\xCB\x83a\nVV[\x16\x91\x82;\x15a\n\xD7WPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x80`7`@Qs=`-\x80`\n=9\x81\xF36==7===6=s``\x1B\x81R\x84``\x1B`\x14\x82\x01RnZ\xF4=\x82\x80>\x90=\x91`+W\xFD[\xF3`\x88\x1B`(\x82\x01R_\xF5\x91\x82\x15a\x0B\xAFW`@Q`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x80\x82Ra\x0B\xAD\x94\x90\x92\x16\x90\x81\x90\x84\x90\x7FH\x8F\x06\xA9\xCA\x9E\x19\xE1\xDD\x90\xC7d\xCCy\xB7e\xE8\xA3\xA0\x89\xEF'\xD9\xA0\xE3\x9D\xEE!\xC7d1\x88\x90` \x90\xA3`@Q\x92` \x84\x01R`@\x83\x01R``\x82\x01R``\x81Ra\x0B\xA8`\x80\x82a\t\x8DV[a\x17\x1BV[V[=_\x80>=_\xFD[\x99\x94\x84\x84\x84\x84a\x0B\xAD\x9F\x9A\x95\x96\x8F\x97a\x0C\xD9\x9F\x9A\x98` \x9F\x9Aa\x02\xD2\x9F\x9A\x8F\x91\x8F\x92\x8F\x93\x8F\x94\x8F\x95\x8F\x96\x8F\x97\x7Fs\x91\xF1CU\xEF\xF1\xE5Y\xE3\x81\xF5\xBFI\x88jw\xDA|O\xDD3\xC6\xFC.\x01B&\x9CV\x1CY\x98a\x01 \x98`@Q\x98\x89R` \x89\x01R`\x01\x80`\xA0\x1B\x03\x16`@\x88\x01R\x15\x15``\x87\x01R`\x80\x86\x01R`\x01\x80`\xA0\x1B\x03\x16`\xA0\x85\x01R`\x01\x80`\xA0\x1B\x03\x16`\xC0\x84\x01R`\x01\x80`\xA0\x1B\x03\x16`\xE0\x83\x01R`\x01\x80`\xA0\x1B\x03\x16a\x01\0\x82\x01R\xA4`@Q\x9E\x8F\x9D\x8E\x01\x90\x81R` \x81\x01\x91\x90\x91R`@\x81\x01\x91\x90\x91R``\x81\x01\x91\x90\x91R`\x80\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x91\x82\x16`\xA0\x82\x01R\x91\x15\x15`\xC0\x83\x01R`\xE0\x82\x01\x92\x90\x92R\x91\x81\x16a\x01\0\x83\x01R\x91\x82\x16a\x01 \x82\x01R\x91\x81\x16a\x01@\x83\x01R\x90\x91\x16a\x01`\x82\x01Ra\x01\x80\x01\x90V[a\x17\xD1V[`@Q\x90`\xE0\x82\x01\x82\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\t\xAFW`@R_`\xC0\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x01RV[`@Q=_\x82>=\x90\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x90`\n\x82\x01\x80\x92\x11a\rRWV[a\r0V[\x91\x90\x82\x01\x80\x92\x11a\rRWV[\x90\x81` \x91\x03\x12a\x01NWQ\x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x01NW\x01\x805\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01NW` \x01\x91\x81`\x05\x1B6\x03\x83\x13a\x01NWV[\x90\x80` \x93\x92\x81\x84R\x84\x84\x017_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[\x92\x95\x94\x93\x91\x90\x81`\x80\x85\x01`\x80\x86RR`\xA0\x84\x01\x91`\xA0\x81`\x05\x1B\x86\x01\x01\x92\x82_\x90`^\x19\x816\x03\x01[\x84\x83\x10a\x0E/WPPPP`\x01`\x01`\xA0\x1B\x03\x97\x90\x97\x16` \x85\x01RP\x94Pa\x0B\xAD\x92\x91``\x91`@\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x01RV[\x90\x91\x92\x93\x94\x95`\x9F\x19\x89\x82\x03\x01\x85R\x865\x82\x81\x12\x15a\x01NW\x83\x01\x805a\x0EU\x81a\x01=V[`\x01`\x01`\xA0\x1B\x03\x16\x82R` \x81\x81\x015\x90\x83\x01R`@\x81\x0156\x82\x90\x03`\x1E\x19\x01\x81\x12\x15a\x01NW\x01` \x815\x91\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01NW\x806\x03\x82\x13a\x01NWa\x0E\xB8` \x92\x83\x92``\x86\x81`@`\x01\x99\x01R\x01\x91a\r\xA9V[\x98\x01\x96\x95\x01\x93\x01\x91\x90a\r\xF3V[\x91\x90\x82\x03\x91\x82\x11a\rRWV[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x81R` \x81\x01\x92\x90\x92R\x90\x91\x16`@\x82\x01R``\x81\x01\x91\x90\x91R`\xA0`\x80\x82\x01\x81\x90Ra\ti\x93\x91\x01\x91a\r\xA9V[\x94\x93\x90a\x0F\x18a\x0C\xDEV[\x95`\xA0\x83\x015\x94\x85a\x0F,`\xC0\x86\x01a\t_V[\x90a\x0FBa\x0F<`\xE0\x88\x01a\t_V[\x97a\n\xB9V[\x94\x83\x15a\x14TWP\x84\x90[\x15a\x149W[`\x01`\x01`\xA0\x1B\x03\x16\x80;\x15a\x01NW`@Qc\xF2\xD5\xD5k`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x81\x01\x89\x90R\x90_\x90\x82\x90`D\x90\x82\x90\x84\x90Z\xF1\x80\x15a\x11\x8AWa\x14\x1FW[P\x86\x89R`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x92\x90\x82\x16\x83\x90\x03a\x12\x81W[PP\x835\x91F\x83\x03a\x10-WPPPPa\x0F\xD6`@\x82\x01a\tlV[\x80a\x10\x15W[a\x10\x06Wa\x0F\xF7\x91a\x0F\xF1` \x85\x93\x01a\t_V[\x90a\x1A^V[`\x01`\x80\x84\x01R[` \x83\x01RV[c6\xB5\x07\xFB`\xE0\x1B_R`\x04_\xFD[Pa\x10%a\x045` \x83\x01a\t_V[3\x14\x15a\x0F\xDCV[\x92\x94\x91\x93\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x82\x14\x93\x91\x84\x15a\x122WP`\x02T`\x01`\x01`\xA0\x1B\x03\x16[`\x01`\x01`\xA0\x1B\x03\x16`\xA0\x8A\x01\x81\x81R\x94\x90\x91\x90\x15a\x11\x8FW\x85a\x10\xDA\x92` \x92G\x99a\x10\xAFa\x10\xA30\x8Aa\x19\xCDV[\x92a\x01 \x81\x01\x90a\t\xDDV[`@Qc\xB1M6\x1D`\xE0\x1B\x81R\x97\x88\x96\x87\x95\x86\x95\x92\x94\x92`\x01`\x01`\xA0\x1B\x03\x16\x90\x8D`\x04\x88\x01a\x0E\xD3V[\x03\x914\x90Z\xF1\x80\x15a\x11\x8AWa\x11\x02\x91_\x91a\x11[W[P\x95a\x10\xFD4Ga\rWV[a\x0E\xC6V[\x80``\x8A\x01R\x80a\x11KW[P[\x85\x85\x03a\x11<Wa\x111\x86\x93a\x117\x96`\xC0\x8B\x01RQ`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90a\x1C4V[a\x0F\xFFV[cB0\x1C#`\xE0\x1B_R`\x04_\xFD[a\x11U\x903a\x1A7V[_a\x11\x0EV[a\x11}\x91P` =` \x11a\x11\x83W[a\x11u\x81\x83a\t\x8DV[\x81\x01\x90a\rdV[_a\x10\xF1V[P=a\x11kV[a\r%V[` \x91\x86\x91_a\x11\xEB\x95\x99\x8D``4\x91\x01R4a\x12#W[a\x11\xC0a\x11\xB40\x8Aa\x19\xCDV[\x93a\x01 \x81\x01\x90a\t\xDDV[`@Qc\xB1M6\x1D`\xE0\x1B\x81R\x98\x89\x97\x88\x96\x87\x95\x92\x94\x92`\x01`\x01`\xA0\x1B\x03\x16\x90\x8D`\x04\x88\x01a\x0E\xD3V[\x03\x92Z\xF1\x90\x81\x15a\x11\x8AW_\x91a\x12\x04W[P\x93a\x11\x10V[a\x12\x1D\x91P` =` \x11a\x11\x83Wa\x11u\x81\x83a\t\x8DV[_a\x11\xFDV[a\x12-43a\x1A7V[a\x11\xA7V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x03a\x12rW`\x03T`\x01`\x01`\xA0\x1B\x03\x16a\x10sV[c\xB2\xAE\x85U`\xE0\x1B_R`\x04_\xFD[a\x14\x10Wa\x13\x05\x96` a\x12\xB8a\x045a\x12\xAB\x85`\x01\x80`\xA0\x1B\x03\x16_R`\x04` R`@_ \x90V[T`\x01`\x01`\xA0\x1B\x03\x16\x90V[a\x12\xC1Ba\rDV[`@QcR\x0B\x93U`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x80\x87\x16`\x04\x83\x01R\x8B\x16`$\x82\x01R`D\x81\x01\x85\x90R`d\x81\x01\x91\x90\x91R\x99\x8A\x91\x90\x82\x90_\x90\x82\x90`\x84\x82\x01\x90V[\x03\x92Z\xF1\x90\x81\x15a\x11\x8AW_\x98\x89\x92a\x13\xEEW[P` \x90\x82\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90a\x13U\x90\x82\x87a\x1A^V[\x89a\x13da\x01\0\x8B\x01\x8Ba\rsV[a\x13\x89`@\x9E\x92\x9EQ\x9E\x8F\x96\x87\x95\x86\x94c\x8B\xCC\xC1\x87`\xE0\x1B\x86R0\x93`\x04\x87\x01a\r\xC9V[\x03\x92Z\xF1\x90\x81\x15a\x11\x8AW\x87a\x13\xC6\x93\x8C\x9A_\x94a\x13\xCDW[Pa\x13\xC0`@\x84\x9Ca\x13\xB4\x86\x88a\x0E\xC6V[\x91\x82\x91\x01R3\x84a\x1A^V[\x86a\x1A\xE5V[_\x80a\x0F\xBAV[a\x13\xE7\x91\x94P` =` \x11a\x11\x83Wa\x11u\x81\x83a\t\x8DV[\x92_a\x13\xA2V[` \x91\x92Pa\x14\t\x90\x82=\x84\x11a\x11\x83Wa\x11u\x81\x83a\t\x8DV[\x91\x90a\x13\x19V[c\x8F\xB4\xD1\x0F`\xE0\x1B_R`\x04_\xFD[\x80a\x14-_a\x143\x93a\t\x8DV[\x80a\x01\x95V[_a\x0F\x9FV[\x96Pa\x14N`\x01`\x01`\xA0\x1B\x03\x88\x16\x82a\x19\xCDV[\x96a\x0FSV[a\x14]\x90a\n\xB9V[\x90a\x0FMV[\x95\x90\x97\x92\x94a\x0B\xAD\x99\x94a\x02\xD2\x96a\x159\x99\x94\x89\x7F.e\x90\x81\xF4LOV\xA1\x8B\0\xF3\xF9\xD16\xD7\xEE\x83\x96\xBCy\x16<Ma6=\xDC\xF4\xA4\xCB'a\x01 \x8E`@Q\x90\x15\x15\x81R\x84` \x82\x01R\x85`@\x82\x01R\x86``\x82\x01R\x87`\x80\x82\x01R\x88\x15\x15`\xA0\x82\x01R`\x01\x80`\xA0\x1B\x03\x8A\x16`\xC0\x82\x01R\x8A`\xE0\x82\x01R\x8Ba\x01\0\x82\x01R\xA2`@Q\x9B\x8C\x9A` \x8C\x01\x96\x93\x90\x9A\x99\x98\x95\x92a\x01 \x98\x95\x92a\x01@\x89\x01\x9C\x89R\x15\x15` \x89\x01R`@\x88\x01R``\x87\x01R`\x80\x86\x01R`\xA0\x85\x01R\x15\x15`\xC0\x84\x01R`\x01\x80`\xA0\x1B\x03\x16`\xE0\x83\x01Ra\x01\0\x82\x01R\x01RV[a\x18\x87V[c\x8Bx\xC6\xD8\x19T3\x03a\x15MWV[c\x82\xB4)\0_R`\x04`\x1C\xFD[\x80Q\x91\x90\x82\x90` \x01\x82^\x01_\x81R\x90V[\x90``\x92` \x91\x83R`@\x82\x84\x01R\x80Q\x91\x82\x91\x82`@\x86\x01R\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[`\x01\x80T\x01\x80`\x01U` _a\x16\r\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F\x14\xC0(\xD3\xD6h\xEB4T\xBC\xE4M\x12<\xEE\xEB\x9F\xB4\xE7K\xEE\x07<A\xF4\0\x1Ec\xF0a0\x94`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[`@Q\x91\x82\x80\x92a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F\x14\xC0(\xD3\xD6h\xEB4T\xBC\xE4M\x12<\xEE\xEB\x9F\xB4\xE7K\xEE\x07<A\xF4\0\x1Ec\xF0a0\x94\x83a\x15lV[\x03\x90\xA4V[`\x01\x80T\x01\x80`\x01U` _a\x16\xC8\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F.=}\x02\xBA<K\xD8\xB1\xF8\x99\\\xD3\xA2>\xF0\x199\"\xEB\xC4\xEE#$\x9E\xADM\x0C\xA2\xE3Lh`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F.=}\x02\xBA<K\xD8\xB1\xF8\x99\\\xD3\xA2>\xF0\x199\"\xEB\xC4\xEE#$\x9E\xADM\x0C\xA2\xE3Lh\x83a\x15lV[`\x01\x80T\x01\x80`\x01U` _a\x17~\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7FH\x8F\x06\xA9\xCA\x9E\x19\xE1\xDD\x90\xC7d\xCCy\xB7e\xE8\xA3\xA0\x89\xEF'\xD9\xA0\xE3\x9D\xEE!\xC7d1\x88`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7FH\x8F\x06\xA9\xCA\x9E\x19\xE1\xDD\x90\xC7d\xCCy\xB7e\xE8\xA3\xA0\x89\xEF'\xD9\xA0\xE3\x9D\xEE!\xC7d1\x88\x83a\x15lV[`\x01\x80T\x01\x80`\x01U` _a\x184\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7Fs\x91\xF1CU\xEF\xF1\xE5Y\xE3\x81\xF5\xBFI\x88jw\xDA|O\xDD3\xC6\xFC.\x01B&\x9CV\x1CY`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7Fs\x91\xF1CU\xEF\xF1\xE5Y\xE3\x81\xF5\xBFI\x88jw\xDA|O\xDD3\xC6\xFC.\x01B&\x9CV\x1CY\x83a\x15lV[`\x01\x80T\x01\x80`\x01U` _a\x18\xEA\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F.e\x90\x81\xF4LOV\xA1\x8B\0\xF3\xF9\xD16\xD7\xEE\x83\x96\xBCy\x16<Ma6=\xDC\xF4\xA4\xCB'`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F.e\x90\x81\xF4LOV\xA1\x8B\0\xF3\xF9\xD16\xD7\xEE\x83\x96\xBCy\x16<Ma6=\xDC\xF4\xA4\xCB'\x83a\x15lV[`\x01\x80T\x01\x80`\x01U` _a\x19\x8D\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R_Q` a\x1DH_9_Q\x90_R`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91_Q` a\x1DH_9_Q\x90_R\x83a\x15lV[`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15a\x1A1W`@Qcp\xA0\x821`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA\x90\x81\x15a\x11\x8AW_\x91a\x1A\x18WP\x90V[a\ti\x91P` =` \x11a\x11\x83Wa\x11u\x81\x83a\t\x8DV[\x90P1\x90V[_\x918\x91\x83\x91\x82\x91`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a\x1AQWV[c\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x91\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\x1A\xC9W`\x01`\x01`\xA0\x1B\x03\x16`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B_\x90\x81R` \x90`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a\x1A\xABW[PP_`4RV[;\x15=\x17\x10\x15a\x1A\xBCW_\x80a\x1A\xA3V[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[_\x92P8\x91\x83\x91\x82\x91\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a\x1AQWV[`@\x80Q\x85\x81R` \x81\x01\x87\x90R\x92\x95a\x1B~\x95\x92\x94a\x02\xD2\x94\x91\x93\x92\x90\x91`\x01`\x01`\xA0\x1B\x03\x80\x84\x16\x92\x90\x8A\x16\x91\x88\x91\x7F/Lv\xC8\xD1\x8FE\x06\x9B\tAI\x92\x05\xA7\xFC\xEA\xAA<\xAF\x9E.c(\xF6\xA5D\xCD3\x91 \xF3\x91\x90\x81\x90\x81\x01[\x03\x90\xA4`@\x80Q` \x81\x01\x96\x90\x96R`\x01`\x01`\xA0\x1B\x03\x97\x88\x16\x90\x86\x01R\x90\x95\x16``\x84\x01R`\x80\x83\x01\x94\x90\x94R`\xA0\x82\x01\x93\x90\x93R\x91\x82\x90`\xC0\x82\x01\x90V[`\x01\x80T\x01\x80`\x01U` _a\x1B\xE1\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F/Lv\xC8\xD1\x8FE\x06\x9B\tAI\x92\x05\xA7\xFC\xEA\xAA<\xAF\x9E.c(\xF6\xA5D\xCD3\x91 \xF3`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F/Lv\xC8\xD1\x8FE\x06\x9B\tAI\x92\x05\xA7\xFC\xEA\xAA<\xAF\x9E.c(\xF6\xA5D\xCD3\x91 \xF3\x83a\x15lV[`@\x80Q\x85\x81R` \x81\x01\x87\x90R\x92\x95a\x1C\x91\x95\x92\x94a\x02\xD2\x94\x91\x93\x92\x90\x91`\x01`\x01`\xA0\x1B\x03\x80\x84\x16\x92\x90\x8A\x16\x91\x88\x91\x7F-\xFC\xF6F\xF9S\xB4\x1D,\xD9\xD3\x0B\xCF?l\xDARH\xEF\xCDw3\xAD\xFF:%\xE8\x8F5\xB8\xAF\xCB\x91\x90\x81\x90\x81\x01a\x1B>V[`\x01\x80T\x01\x80`\x01U` _a\x1C\xF4\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F-\xFC\xF6F\xF9S\xB4\x1D,\xD9\xD3\x0B\xCF?l\xDARH\xEF\xCDw3\xAD\xFF:%\xE8\x8F5\xB8\xAF\xCB`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F-\xFC\xF6F\xF9S\xB4\x1D,\xD9\xD3\x0B\xCF?l\xDARH\xEF\xCDw3\xAD\xFF:%\xE8\x8F5\xB8\xAF\xCB\x83a\x15lV\xFE\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0x\x16\x0F\x0B\x1B+2\xB5*\0v\xD8\xF0\xF7\x08\x88h{\xA7\x02\xA4\xD9\x93\xD5Z\xC8\xD92}W\xA1'\xA1dsolcC\0\x08\x1B\0\n`\xA0\x80`@R4`(W3`\x80Ra\x01r\x90\x81a\0-\x829`\x80Q\x81\x81\x81`i\x01Ra\x016\x01R\xF3[_\x80\xFD\xFE`\x80\x80`@R`\x046\x10\x15a\0\x1CW[P6\x15a\0\x1AW_\x80\xFD[\0[_5`\xE0\x1C\x90\x81c\x11x\x03\xE3\x14a\x01$WPc\xF2\xD5\xD5k\x14a\0>W_a\0\x0FV[4a\x01 W`@6`\x03\x19\x01\x12a\x01 W`\x045`\x01`\x01`\xA0\x1B\x03\x81\x16\x80\x82\x03a\x01 W`$5\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x903\x82\x90\x03a\x01\x11W\x82a\0\xA1W\0[\x15a\0\xF5W`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B_R` _`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a\0\xD7W[PP_`4R\0[;\x15=\x17\x10\x15a\0\xE8W_\x80a\0\xCFV[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[\x90_\x80\x93P\x80\x918\x93Z\xF1a\0\x1AWc\xB1-\x13\xEB_R`\x04`\x1C\xFD[c0\xCDtq`\xE0\x1B_R`\x04_\xFD[_\x80\xFD[4a\x01 W_6`\x03\x19\x01\x12a\x01 W\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3\xFE\xA1dsolcC\0\x08\x1B\0\n`\xA0\x80`@R4`(W3`\x80Ra\x03\xEA\x90\x81a\0-\x829`\x80Q\x81\x81\x81`\xD9\x01Ra\x03\x01\x01R\xF3[_\x80\xFD\xFE`\x80\x80`@R`\x046\x10\x15a\0\x1CW[P6\x15a\0\x1AW_\x80\xFD[\0[_5`\xE0\x1C\x90\x81c\x11x\x03\xE3\x14a\x02\xEFWPc\x8B\xCC\xC1\x87\x14a\0>W_a\0\x0FV[4a\x02\x0BW`\x806`\x03\x19\x01\x12a\x02\x0BW`\x045g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x0BW6`#\x82\x01\x12\x15a\x02\x0BW\x80`\x04\x015g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x02\x0BW6`$\x82`\x05\x1B\x84\x01\x01\x11a\x02\x0BW`$5\x91`\x01`\x01`\xA0\x1B\x03\x83\x16\x80\x84\x03a\x02\x0BW`d5`\x01`\x01`\xA0\x1B\x03\x81\x16\x94\x90\x85\x90\x03a\x02\x0BW0h\x92\x9E\xEE\x14\x9BK\xD2\x12hT\x14a\x02\xE2W0h\x92\x9E\xEE\x14\x9BK\xD2\x12hU\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x163\x03a\x02\xD3W\x92\x936\x83\x90\x03`\x82\x19\x01\x93\x90_[\x86\x81\x10\x15a\x02\x0FW`$\x81`\x05\x1B\x86\x01\x015\x86\x81\x12\x15a\x02\x0BW\x85\x01`$\x81\x015\x90`\x01`\x01`\xA0\x1B\x03\x82\x16\x82\x03a\x02\x0BW`d\x81\x015`B\x196\x83\x90\x03\x01\x81\x12\x15a\x02\x0BW\x81\x01`$\x01\x805\x91\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x83\x11a\x02\x0BW` \x01\x91\x806\x03\x83\x13a\x02\x0BW_\x93`D\x85\x94\x83`@Q\x94\x85\x92\x837\x81\x01\x86\x81R\x03\x93\x015\x90Z\xF1=\x15a\x02\x06W=g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01\xF2W`@Q\x90a\x01\xC9`\x1F\x82\x01`\x1F\x19\x16` \x01\x83a\x030V[\x81R_` =\x92\x01>[\x15a\x01\xE0W`\x01\x01a\x01\x15V[c\x07\xF3Gi`\xE3\x1B_R`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[a\x01\xD3V[_\x80\xFD[Pa\x02\x1A0\x83a\x03RV[\x92`D5\x84\x10a\x02\xC4W\x83a\x02AW[` \x848h\x92\x9E\xEE\x14\x9BK\xD2\x12hU`@Q\x90\x81R\xF3[\x15a\x02\xA0W`\x14R\x81`4Rc\xA9\x05\x9C\xBB``\x1B_R` _`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a\x02\x82W[PP` \x90_`4R[\x90\x82\x80a\x02*V[;\x15=\x17\x10\x15a\x02\x93W\x81\x80a\x02pV[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[_\x80\x80\x93P\x848\x93Z\xF1\x15a\x02\xB7W` \x90a\x02zV[c\xB1-\x13\xEB_R`\x04`\x1C\xFD[c\xBB(u\xC3`\xE0\x1B_R`\x04_\xFD[c0\xCDtq`\xE0\x1B_R`\x04_\xFD[c\xAB\x14<\x06_R`\x04`\x1C\xFD[4a\x02\x0BW_6`\x03\x19\x01\x12a\x02\x0BW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\x01\xF2W`@RV[`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15a\x03\xD7W`@Qcp\xA0\x821`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA\x90\x81\x15a\x03\xCCW_\x91a\x03\x9DWP\x90V[\x90P` \x81=` \x11a\x03\xC4W[\x81a\x03\xB8` \x93\x83a\x030V[\x81\x01\x03\x12a\x02\x0BWQ\x90V[=\x91Pa\x03\xABV[`@Q=_\x82>=\x90\xFD[\x90P1\x90V\xFE\xA1dsolcC\0\x08\x1B\0\n\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c80627f2b66146101385780630496c2f1146101335780630b3458791461012e5780631ad1087b146101295780632b0f3ee4146101245780633fea34881461011f5780634d53e9311461011a57806352d62f80146101155780636264257a14610110578063715018a61461010b57806389a30271146101065780638da5cb5b14610101578063c54e44eb146100fc578063d08bd89f146100f7578063e24d5c35146100f2578063e8e3cc1c146100ed578063ed61a911146100e85763f2fde38b0361000e576108cb565b6108b3565b610879565b61085c565b610834565b6107f0565b6107c4565b610780565b610714565b61065b565b610633565b610617565b6105ed565b610518565b610227565b6101e3565b61019f565b610152565b6001600160a01b0381160361014e57565b5f80fd5b3461014e57602036600319011261014e5760043561016f8161013d565b60018060a01b03165f526004602052602060018060a01b0360405f205416604051908152f35b5f91031261014e57565b3461014e575f36600319011261014e576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461014e575f36600319011261014e576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b602036600319011261014e5767ffffffffffffffff6004351161014e576101406004353603600319011261014e576105086102e06104f760a46004350135600435600401356104ae61027d60246004350161095f565b61028b60446004350161096c565b604080516020810186815260609490941b6bffffffffffffffffffffffff19169181019190915290151560f81b605482015260043560640135605582018190529681607581015b03601f19810183528261098d565b51902094608460043501359561049d878661033c61030260e46004350161095f565b6102d26040519384926020840196898892909160749492845260208401526001600160601b03199060601b16604083015260548201520190565b519020928261034f60c46004350161095f565b6103e88b6102d261036460e46004350161095f565b8c8c61037460246004350161095f565b9161038360446004350161096c565b6040805130602082019081524692820192909252606081019b909b5260808b01979097526001600160a01b0398891660a08b015293881660c08a015260e089015261010088015290941661012086015292151561014085015292918290610160820190565b519020986103f46109b4565b968a8852610417610410610124600435016004356004016109dd565b3691610a10565b805160209182012090890152881561050c5761044161043587610a56565b6001600160a01b031690565b918961044f61043589610a56565b948d61045f60246004350161095f565b9461046e60446004350161096c565b9261047d60c46004350161095f565b958b61048d60e46004350161095f565b986001600160a01b031694610bb7565b600435600401918515159188610f0d565b805194602082019586516040840151906060850151926104d16080870151151590565b60a087015190959060209060c0906001600160a01b031698015198015198151590611463565b516040519081529081906020820190565b0390f35b61044161043586610a56565b3461014e57604036600319011261014e576100186004356105388161013d565b6105d6602435916105488361013d565b61055061153e565b60018060a01b031691826001600160601b0360a01b600254161760025560018060a01b031691826001600160601b0360a01b60035416176003556102d260405193828186947f14c028d3d668eb3454bce44d123ceeeb9fb4e74bee073c41f4001e63f06130945f80a36001600160a01b0390811660208501521660408301526060820190565b61159e565b602090600319011261014e5760043590565b3461014e576020610605610600366105db565b610a56565b6040516001600160a01b039091168152f35b3461014e575f36600319011261014e5760205f54604051908152f35b3461014e575f36600319011261014e576002546040516001600160a01b039091168152602090f35b3461014e57604036600319011261014e5761001860043561067b8161013d565b61070f60243561068a8161013d565b61069261153e565b6001600160a01b038381165f8181526004602052604080822080546001600160a01b0319169590941694851790935591519485936102d293909283917f2e3d7d02ba3c4bd8b1f8995cd3a23ef0193922ebc4ee23249ead4d0ca2e34c689080a36001600160a01b0390811660208501521660408301526060820190565b611665565b5f36600319011261014e5761072761153e565b610018638b78c6d819545f638b78c6d8195561077b60405180925f60018060a01b0382165f516020611d485f395f51905f528280a36001600160a01b031660208201525f604091820152825260608261098d565b61193d565b3461014e575f36600319011261014e576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461014e575f36600319011261014e57638b78c6d819546040516001600160a01b039091168152602090f35b3461014e575f36600319011261014e576040517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b3461014e575f36600319011261014e576003546040516001600160a01b039091168152602090f35b3461014e575f36600319011261014e576020600154604051908152f35b3461014e575f36600319011261014e5760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b3461014e5760206106056108c6366105db565b610ab9565b602036600319011261014e576004356108e38161013d565b6108eb61153e565b8060601b1561095257638b78c6d81980546001600160a01b039283169182905560405161001893909261077b9284926102d2929190829082165f516020611d485f395f51905f525f80a36001600160a01b0390811660208501521660408301526060820190565b637448fbae5f526004601cfd5b356109698161013d565b90565b35801515810361014e5790565b634e487b7160e01b5f52604160045260245ffd5b90601f8019910116810190811067ffffffffffffffff8211176109af57604052565b610979565b604051906040820182811067ffffffffffffffff8211176109af576040525f6020838281520152565b903590601e198136030182121561014e570180359067ffffffffffffffff821161014e5760200191813603831361014e57565b92919267ffffffffffffffff82116109af5760405191610a3a601f8201601f19166020018461098d565b82948184528183011161014e578281602093845f960137010152565b60405190602082019060ff60f81b82523060601b602184015260358301527f0000000000000000000000000000000000000000000000000000000000000000605583015260558252610aa960758361098d565b905190206001600160a01b031690565b906001600160a01b03610acb83610a56565b1691823b15610ad75750565b7f000000000000000000000000000000000000000000000000000000000000000090806037604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528460601b60148201526e5af43d82803e903d91602b57fd5bf360881b60288201525ff5918215610baf576040516001600160a01b03918216808252610bad9490921690819084907f488f06a9ca9e19e1dd90c764cc79b765e8a3a089ef27d9a0e39dee21c764318890602090a36040519260208401526040830152606082015260608152610ba860808261098d565b61171b565b565b3d5f803e3d5ffd5b999484848484610bad9f9a95968f97610cd99f9a9860209f9a6102d29f9a8f918f928f938f948f958f968f977f7391f14355eff1e559e381f5bf49886a77da7c4fdd33c6fc2e0142269c561c599861012098604051988952602089015260018060a01b0316604088015215156060870152608086015260018060a01b031660a085015260018060a01b031660c084015260018060a01b031660e083015260018060a01b0316610100820152a46040519e8f9d8e0190815260208101919091526040810191909152606081019190915260808101919091526001600160a01b0391821660a082015291151560c083015260e08201929092529181166101008301529182166101208201529181166101408301529091166101608201526101800190565b6117d1565b6040519060e0820182811067ffffffffffffffff8211176109af576040525f60c0838281528260208201528260408201528260608201528260808201528260a08201520152565b6040513d5f823e3d90fd5b634e487b7160e01b5f52601160045260245ffd5b90600a8201809211610d5257565b610d30565b91908201809211610d5257565b9081602091031261014e575190565b903590601e198136030182121561014e570180359067ffffffffffffffff821161014e57602001918160051b3603831361014e57565b908060209392818452848401375f828201840152601f01601f1916010190565b9295949391908160808501608086525260a084019160a08160051b86010192825f90605e19813603015b848310610e2f57505050506001600160a01b03979097166020850152509450610bad929160609160408201526001600160a01b03909216910152565b909192939495609f1989820301855286358281121561014e5783018035610e558161013d565b6001600160a01b0316825260208181013590830152604081013536829003601e190181121561014e57016020813591019067ffffffffffffffff811161014e57803603821361014e57610eb8602092839260608681604060019901520191610da9565b980196950193019190610df3565b91908203918211610d5257565b6001600160a01b03918216815260208101929092529091166040820152606081019190915260a06080820181905261096993910191610da9565b949390610f18610cde565b9560a08301359485610f2c60c0860161095f565b90610f42610f3c60e0880161095f565b97610ab9565b948315611454575084905b15611439575b6001600160a01b0316803b1561014e5760405163f2d5d56b60e01b81526001600160a01b038316600482015260248101899052905f908290604490829084905af1801561118a5761141f575b508689526001600160a01b0386811692908216839003611281575b505083359146830361102d5750505050610fd66040820161096c565b80611015575b61100657610ff791610ff1602085930161095f565b90611a5e565b600160808401525b6020830152565b6336b507fb60e01b5f5260045ffd5b506110256104356020830161095f565b331415610fdc565b929491937f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031682149391841561123257506002546001600160a01b03165b6001600160a01b031660a08a01818152949091901561118f57856110da9260209247996110af6110a3308a6119cd565b926101208101906109dd565b60405163b14d361d60e01b8152978896879586959294926001600160a01b0316908d60048801610ed3565b039134905af1801561118a57611102915f9161115b575b50956110fd3447610d57565b610ec6565b8060608a01528061114b575b505b85850361113c5761113186936111379660c08b01525160018060a01b031690565b90611c34565b610fff565b6342301c2360e01b5f5260045ffd5b6111559033611a37565b5f61110e565b61117d915060203d602011611183575b611175818361098d565b810190610d64565b5f6110f1565b503d61116b565b610d25565b60209186915f6111eb95998d60603491015234611223575b6111c06111b4308a6119cd565b936101208101906109dd565b60405163b14d361d60e01b8152988997889687959294926001600160a01b0316908d60048801610ed3565b03925af190811561118a575f91611204575b5093611110565b61121d915060203d60201161118357611175818361098d565b5f6111fd565b61122d3433611a37565b6111a7565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031603611272576003546001600160a01b0316611073565b63b2ae855560e01b5f5260045ffd5b611410576113059660206112b86104356112ab8560018060a01b03165f52600460205260405f2090565b546001600160a01b031690565b6112c142610d44565b60405163520b935560e01b81526001600160a01b0380871660048301528b166024820152604481018590526064810191909152998a919082905f9082906084820190565b03925af190811561118a575f9889926113ee575b5060209082907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690611355908287611a5e565b896113646101008b018b610d73565b61138960409e929e519e8f9687958694638bccc18760e01b8652309360048701610dc9565b03925af190811561118a57876113c6938c9a5f946113cd575b506113c06040849c6113b48688610ec6565b91829101523384611a5e565b86611ae5565b5f80610fba565b6113e791945060203d60201161118357611175818361098d565b925f6113a2565b602091925061140990823d841161118357611175818361098d565b9190611319565b638fb4d10f60e01b5f5260045ffd5b8061142d5f6114339361098d565b80610195565b5f610f9f565b965061144e6001600160a01b038816826119cd565b96610f53565b61145d90610ab9565b90610f4d565b9590979294610bad99946102d2966115399994897f2e659081f44c4f56a18b00f3f9d136d7ee8396bc79163c4d61363ddcf4a4cb276101208e604051901515815284602082015285604082015286606082015287608082015288151560a082015260018060a01b038a1660c08201528a60e08201528b610100820152a26040519b8c9a60208c019693909a9998959261012098959261014089019c89521515602089015260408801526060870152608086015260a0850152151560c084015260018060a01b031660e08301526101008201520152565b611887565b638b78c6d81954330361154d57565b6382b429005f526004601cfd5b805191908290602001825e015f815290565b9060609260209183526040828401528051918291826040860152018484015e5f828201840152601f01601f1916010190565b60018054018060015560205f61160d81549360405190858583015260408201524360608201524260808201527f14c028d3d668eb3454bce44d123ceeeb9fb4e74bee073c41f4001e63f061309460a0820152611601816102d260c082018961155a565b6040519182809261155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f14c028d3d668eb3454bce44d123ceeeb9fb4e74bee073c41f4001e63f06130948361156c565b0390a4565b60018054018060015560205f6116c881549360405190858583015260408201524360608201524260808201527f2e3d7d02ba3c4bd8b1f8995cd3a23ef0193922ebc4ee23249ead4d0ca2e34c6860a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f2e3d7d02ba3c4bd8b1f8995cd3a23ef0193922ebc4ee23249ead4d0ca2e34c688361156c565b60018054018060015560205f61177e81549360405190858583015260408201524360608201524260808201527f488f06a9ca9e19e1dd90c764cc79b765e8a3a089ef27d9a0e39dee21c764318860a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f488f06a9ca9e19e1dd90c764cc79b765e8a3a089ef27d9a0e39dee21c76431888361156c565b60018054018060015560205f61183481549360405190858583015260408201524360608201524260808201527f7391f14355eff1e559e381f5bf49886a77da7c4fdd33c6fc2e0142269c561c5960a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f7391f14355eff1e559e381f5bf49886a77da7c4fdd33c6fc2e0142269c561c598361156c565b60018054018060015560205f6118ea81549360405190858583015260408201524360608201524260808201527f2e659081f44c4f56a18b00f3f9d136d7ee8396bc79163c4d61363ddcf4a4cb2760a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f2e659081f44c4f56a18b00f3f9d136d7ee8396bc79163c4d61363ddcf4a4cb278361156c565b60018054018060015560205f61198d81549360405190858583015260408201524360608201524260808201525f516020611d485f395f51905f5260a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182915f516020611d485f395f51905f528361156c565b6001600160a01b0316908115611a31576040516370a0823160e01b81526001600160a01b03909116600482015290602090829060249082905afa90811561118a575f91611a18575090565b610969915060203d60201161118357611175818361098d565b90503190565b5f913891839182916001600160a01b03165af115611a5157565b63b12d13eb5f526004601cfd5b91906001600160a01b03831615611ac9576001600160a01b031660145260345263a9059cbb60601b5f9081526020906044601082855af1908160015f51141615611aab575b50505f603452565b3b153d171015611abc575f80611aa3565b6390b8ec185f526004601cfd5b5f9250389183918291906001600160a01b03165af115611a5157565b60408051858152602081018790529295611b7e9592946102d29491939290916001600160a01b0380841692908a169188917f2f4c76c8d18f45069b0941499205a7fceaaa3caf9e2e6328f6a544cd339120f39190819081015b0390a46040805160208101969096526001600160a01b03978816908601529095166060840152608083019490945260a082019390935291829060c0820190565b60018054018060015560205f611be181549360405190858583015260408201524360608201524260808201527f2f4c76c8d18f45069b0941499205a7fceaaa3caf9e2e6328f6a544cd339120f360a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f2f4c76c8d18f45069b0941499205a7fceaaa3caf9e2e6328f6a544cd339120f38361156c565b60408051858152602081018790529295611c919592946102d29491939290916001600160a01b0380841692908a169188917f2dfcf646f953b41d2cd9d30bcf3f6cda5248efcd7733adff3a25e88f35b8afcb919081908101611b3e565b60018054018060015560205f611cf481549360405190858583015260408201524360608201524260808201527f2dfcf646f953b41d2cd9d30bcf3f6cda5248efcd7733adff3a25e88f35b8afcb60a0820152611601816102d260c082018961155a565b039060025afa1561118a575f515f556001545f516020611d685f395f51905f526116605f54946040519182917f2dfcf646f953b41d2cd9d30bcf3f6cda5248efcd7733adff3a25e88f35b8afcb8361156c56fe8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e078160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a127a164736f6c634300081b000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x1AW[6\x15a\0\x18W_\x80\xFD[\0[_5`\xE0\x1C\x80b\x7F+f\x14a\x018W\x80c\x04\x96\xC2\xF1\x14a\x013W\x80c\x0B4Xy\x14a\x01.W\x80c\x1A\xD1\x08{\x14a\x01)W\x80c+\x0F>\xE4\x14a\x01$W\x80c?\xEA4\x88\x14a\x01\x1FW\x80cMS\xE91\x14a\x01\x1AW\x80cR\xD6/\x80\x14a\x01\x15W\x80cbd%z\x14a\x01\x10W\x80cqP\x18\xA6\x14a\x01\x0BW\x80c\x89\xA3\x02q\x14a\x01\x06W\x80c\x8D\xA5\xCB[\x14a\x01\x01W\x80c\xC5ND\xEB\x14a\0\xFCW\x80c\xD0\x8B\xD8\x9F\x14a\0\xF7W\x80c\xE2M\\5\x14a\0\xF2W\x80c\xE8\xE3\xCC\x1C\x14a\0\xEDW\x80c\xEDa\xA9\x11\x14a\0\xE8Wc\xF2\xFD\xE3\x8B\x03a\0\x0EWa\x08\xCBV[a\x08\xB3V[a\x08yV[a\x08\\V[a\x084V[a\x07\xF0V[a\x07\xC4V[a\x07\x80V[a\x07\x14V[a\x06[V[a\x063V[a\x06\x17V[a\x05\xEDV[a\x05\x18V[a\x02'V[a\x01\xE3V[a\x01\x9FV[a\x01RV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x03a\x01NWV[_\x80\xFD[4a\x01NW` 6`\x03\x19\x01\x12a\x01NW`\x045a\x01o\x81a\x01=V[`\x01\x80`\xA0\x1B\x03\x16_R`\x04` R` `\x01\x80`\xA0\x1B\x03`@_ T\x16`@Q\x90\x81R\xF3[_\x91\x03\x12a\x01NWV[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[` 6`\x03\x19\x01\x12a\x01NWg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x045\x11a\x01NWa\x01@`\x0456\x03`\x03\x19\x01\x12a\x01NWa\x05\x08a\x02\xE0a\x04\xF7`\xA4`\x045\x015`\x045`\x04\x015a\x04\xAEa\x02}`$`\x045\x01a\t_V[a\x02\x8B`D`\x045\x01a\tlV[`@\x80Q` \x81\x01\x86\x81R``\x94\x90\x94\x1Bk\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x91\x81\x01\x91\x90\x91R\x90\x15\x15`\xF8\x1B`T\x82\x01R`\x045`d\x015`U\x82\x01\x81\x90R\x96\x81`u\x81\x01[\x03`\x1F\x19\x81\x01\x83R\x82a\t\x8DV[Q\x90 \x94`\x84`\x045\x015\x95a\x04\x9D\x87\x86a\x03<a\x03\x02`\xE4`\x045\x01a\t_V[a\x02\xD2`@Q\x93\x84\x92` \x84\x01\x96\x89\x88\x92\x90\x91`t\x94\x92\x84R` \x84\x01R`\x01`\x01``\x1B\x03\x19\x90``\x1B\x16`@\x83\x01R`T\x82\x01R\x01\x90V[Q\x90 \x92\x82a\x03O`\xC4`\x045\x01a\t_V[a\x03\xE8\x8Ba\x02\xD2a\x03d`\xE4`\x045\x01a\t_V[\x8C\x8Ca\x03t`$`\x045\x01a\t_V[\x91a\x03\x83`D`\x045\x01a\tlV[`@\x80Q0` \x82\x01\x90\x81RF\x92\x82\x01\x92\x90\x92R``\x81\x01\x9B\x90\x9BR`\x80\x8B\x01\x97\x90\x97R`\x01`\x01`\xA0\x1B\x03\x98\x89\x16`\xA0\x8B\x01R\x93\x88\x16`\xC0\x8A\x01R`\xE0\x89\x01Ra\x01\0\x88\x01R\x90\x94\x16a\x01 \x86\x01R\x92\x15\x15a\x01@\x85\x01R\x92\x91\x82\x90a\x01`\x82\x01\x90V[Q\x90 \x98a\x03\xF4a\t\xB4V[\x96\x8A\x88Ra\x04\x17a\x04\x10a\x01$`\x045\x01`\x045`\x04\x01a\t\xDDV[6\x91a\n\x10V[\x80Q` \x91\x82\x01 \x90\x89\x01R\x88\x15a\x05\x0CWa\x04Aa\x045\x87a\nVV[`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x91\x89a\x04Oa\x045\x89a\nVV[\x94\x8Da\x04_`$`\x045\x01a\t_V[\x94a\x04n`D`\x045\x01a\tlV[\x92a\x04}`\xC4`\x045\x01a\t_V[\x95\x8Ba\x04\x8D`\xE4`\x045\x01a\t_V[\x98`\x01`\x01`\xA0\x1B\x03\x16\x94a\x0B\xB7V[`\x045`\x04\x01\x91\x85\x15\x15\x91\x88a\x0F\rV[\x80Q\x94` \x82\x01\x95\x86Q`@\x84\x01Q\x90``\x85\x01Q\x92a\x04\xD1`\x80\x87\x01Q\x15\x15\x90V[`\xA0\x87\x01Q\x90\x95\x90` \x90`\xC0\x90`\x01`\x01`\xA0\x1B\x03\x16\x98\x01Q\x98\x01Q\x98\x15\x15\x90a\x14cV[Q`@Q\x90\x81R\x90\x81\x90` \x82\x01\x90V[\x03\x90\xF3[a\x04Aa\x045\x86a\nVV[4a\x01NW`@6`\x03\x19\x01\x12a\x01NWa\0\x18`\x045a\x058\x81a\x01=V[a\x05\xD6`$5\x91a\x05H\x83a\x01=V[a\x05Pa\x15>V[`\x01\x80`\xA0\x1B\x03\x16\x91\x82`\x01`\x01``\x1B\x03`\xA0\x1B`\x02T\x16\x17`\x02U`\x01\x80`\xA0\x1B\x03\x16\x91\x82`\x01`\x01``\x1B\x03`\xA0\x1B`\x03T\x16\x17`\x03Ua\x02\xD2`@Q\x93\x82\x81\x86\x94\x7F\x14\xC0(\xD3\xD6h\xEB4T\xBC\xE4M\x12<\xEE\xEB\x9F\xB4\xE7K\xEE\x07<A\xF4\0\x1Ec\xF0a0\x94_\x80\xA3`\x01`\x01`\xA0\x1B\x03\x90\x81\x16` \x85\x01R\x16`@\x83\x01R``\x82\x01\x90V[a\x15\x9EV[` \x90`\x03\x19\x01\x12a\x01NW`\x045\x90V[4a\x01NW` a\x06\x05a\x06\x006a\x05\xDBV[a\nVV[`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW` _T`@Q\x90\x81R\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`\x02T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x01NW`@6`\x03\x19\x01\x12a\x01NWa\0\x18`\x045a\x06{\x81a\x01=V[a\x07\x0F`$5a\x06\x8A\x81a\x01=V[a\x06\x92a\x15>V[`\x01`\x01`\xA0\x1B\x03\x83\x81\x16_\x81\x81R`\x04` R`@\x80\x82 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16\x95\x90\x94\x16\x94\x85\x17\x90\x93U\x91Q\x94\x85\x93a\x02\xD2\x93\x90\x92\x83\x91\x7F.=}\x02\xBA<K\xD8\xB1\xF8\x99\\\xD3\xA2>\xF0\x199\"\xEB\xC4\xEE#$\x9E\xADM\x0C\xA2\xE3Lh\x90\x80\xA3`\x01`\x01`\xA0\x1B\x03\x90\x81\x16` \x85\x01R\x16`@\x83\x01R``\x82\x01\x90V[a\x16eV[_6`\x03\x19\x01\x12a\x01NWa\x07'a\x15>V[a\0\x18c\x8Bx\xC6\xD8\x19T_c\x8Bx\xC6\xD8\x19Ua\x07{`@Q\x80\x92_`\x01\x80`\xA0\x1B\x03\x82\x16_Q` a\x1DH_9_Q\x90_R\x82\x80\xA3`\x01`\x01`\xA0\x1B\x03\x16` \x82\x01R_`@\x91\x82\x01R\x82R``\x82a\t\x8DV[a\x19=V[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NWc\x8Bx\xC6\xD8\x19T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW`\x03T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW` `\x01T`@Q\x90\x81R\xF3[4a\x01NW_6`\x03\x19\x01\x12a\x01NW` `@Q\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81R\xF3[4a\x01NW` a\x06\x05a\x08\xC66a\x05\xDBV[a\n\xB9V[` 6`\x03\x19\x01\x12a\x01NW`\x045a\x08\xE3\x81a\x01=V[a\x08\xEBa\x15>V[\x80``\x1B\x15a\tRWc\x8Bx\xC6\xD8\x19\x80T`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x91\x82\x90U`@Qa\0\x18\x93\x90\x92a\x07{\x92\x84\x92a\x02\xD2\x92\x91\x90\x82\x90\x82\x16_Q` a\x1DH_9_Q\x90_R_\x80\xA3`\x01`\x01`\xA0\x1B\x03\x90\x81\x16` \x85\x01R\x16`@\x83\x01R``\x82\x01\x90V[ctH\xFB\xAE_R`\x04`\x1C\xFD[5a\ti\x81a\x01=V[\x90V[5\x80\x15\x15\x81\x03a\x01NW\x90V[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\t\xAFW`@RV[a\tyV[`@Q\x90`@\x82\x01\x82\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\t\xAFW`@R_` \x83\x82\x81R\x01RV[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x01NW\x01\x805\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01NW` \x01\x91\x816\x03\x83\x13a\x01NWV[\x92\x91\x92g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\t\xAFW`@Q\x91a\n:`\x1F\x82\x01`\x1F\x19\x16` \x01\x84a\t\x8DV[\x82\x94\x81\x84R\x81\x83\x01\x11a\x01NW\x82\x81` \x93\x84_\x96\x017\x01\x01RV[`@Q\x90` \x82\x01\x90`\xFF`\xF8\x1B\x82R0``\x1B`!\x84\x01R`5\x83\x01R\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`U\x83\x01R`U\x82Ra\n\xA9`u\x83a\t\x8DV[\x90Q\x90 `\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03a\n\xCB\x83a\nVV[\x16\x91\x82;\x15a\n\xD7WPV[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x80`7`@Qs=`-\x80`\n=9\x81\xF36==7===6=s``\x1B\x81R\x84``\x1B`\x14\x82\x01RnZ\xF4=\x82\x80>\x90=\x91`+W\xFD[\xF3`\x88\x1B`(\x82\x01R_\xF5\x91\x82\x15a\x0B\xAFW`@Q`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x80\x82Ra\x0B\xAD\x94\x90\x92\x16\x90\x81\x90\x84\x90\x7FH\x8F\x06\xA9\xCA\x9E\x19\xE1\xDD\x90\xC7d\xCCy\xB7e\xE8\xA3\xA0\x89\xEF'\xD9\xA0\xE3\x9D\xEE!\xC7d1\x88\x90` \x90\xA3`@Q\x92` \x84\x01R`@\x83\x01R``\x82\x01R``\x81Ra\x0B\xA8`\x80\x82a\t\x8DV[a\x17\x1BV[V[=_\x80>=_\xFD[\x99\x94\x84\x84\x84\x84a\x0B\xAD\x9F\x9A\x95\x96\x8F\x97a\x0C\xD9\x9F\x9A\x98` \x9F\x9Aa\x02\xD2\x9F\x9A\x8F\x91\x8F\x92\x8F\x93\x8F\x94\x8F\x95\x8F\x96\x8F\x97\x7Fs\x91\xF1CU\xEF\xF1\xE5Y\xE3\x81\xF5\xBFI\x88jw\xDA|O\xDD3\xC6\xFC.\x01B&\x9CV\x1CY\x98a\x01 \x98`@Q\x98\x89R` \x89\x01R`\x01\x80`\xA0\x1B\x03\x16`@\x88\x01R\x15\x15``\x87\x01R`\x80\x86\x01R`\x01\x80`\xA0\x1B\x03\x16`\xA0\x85\x01R`\x01\x80`\xA0\x1B\x03\x16`\xC0\x84\x01R`\x01\x80`\xA0\x1B\x03\x16`\xE0\x83\x01R`\x01\x80`\xA0\x1B\x03\x16a\x01\0\x82\x01R\xA4`@Q\x9E\x8F\x9D\x8E\x01\x90\x81R` \x81\x01\x91\x90\x91R`@\x81\x01\x91\x90\x91R``\x81\x01\x91\x90\x91R`\x80\x81\x01\x91\x90\x91R`\x01`\x01`\xA0\x1B\x03\x91\x82\x16`\xA0\x82\x01R\x91\x15\x15`\xC0\x83\x01R`\xE0\x82\x01\x92\x90\x92R\x91\x81\x16a\x01\0\x83\x01R\x91\x82\x16a\x01 \x82\x01R\x91\x81\x16a\x01@\x83\x01R\x90\x91\x16a\x01`\x82\x01Ra\x01\x80\x01\x90V[a\x17\xD1V[`@Q\x90`\xE0\x82\x01\x82\x81\x10g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11\x17a\t\xAFW`@R_`\xC0\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x01RV[`@Q=_\x82>=\x90\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[\x90`\n\x82\x01\x80\x92\x11a\rRWV[a\r0V[\x91\x90\x82\x01\x80\x92\x11a\rRWV[\x90\x81` \x91\x03\x12a\x01NWQ\x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x01NW\x01\x805\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x82\x11a\x01NW` \x01\x91\x81`\x05\x1B6\x03\x83\x13a\x01NWV[\x90\x80` \x93\x92\x81\x84R\x84\x84\x017_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[\x92\x95\x94\x93\x91\x90\x81`\x80\x85\x01`\x80\x86RR`\xA0\x84\x01\x91`\xA0\x81`\x05\x1B\x86\x01\x01\x92\x82_\x90`^\x19\x816\x03\x01[\x84\x83\x10a\x0E/WPPPP`\x01`\x01`\xA0\x1B\x03\x97\x90\x97\x16` \x85\x01RP\x94Pa\x0B\xAD\x92\x91``\x91`@\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x01RV[\x90\x91\x92\x93\x94\x95`\x9F\x19\x89\x82\x03\x01\x85R\x865\x82\x81\x12\x15a\x01NW\x83\x01\x805a\x0EU\x81a\x01=V[`\x01`\x01`\xA0\x1B\x03\x16\x82R` \x81\x81\x015\x90\x83\x01R`@\x81\x0156\x82\x90\x03`\x1E\x19\x01\x81\x12\x15a\x01NW\x01` \x815\x91\x01\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x81\x11a\x01NW\x806\x03\x82\x13a\x01NWa\x0E\xB8` \x92\x83\x92``\x86\x81`@`\x01\x99\x01R\x01\x91a\r\xA9V[\x98\x01\x96\x95\x01\x93\x01\x91\x90a\r\xF3V[\x91\x90\x82\x03\x91\x82\x11a\rRWV[`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x81R` \x81\x01\x92\x90\x92R\x90\x91\x16`@\x82\x01R``\x81\x01\x91\x90\x91R`\xA0`\x80\x82\x01\x81\x90Ra\ti\x93\x91\x01\x91a\r\xA9V[\x94\x93\x90a\x0F\x18a\x0C\xDEV[\x95`\xA0\x83\x015\x94\x85a\x0F,`\xC0\x86\x01a\t_V[\x90a\x0FBa\x0F<`\xE0\x88\x01a\t_V[\x97a\n\xB9V[\x94\x83\x15a\x14TWP\x84\x90[\x15a\x149W[`\x01`\x01`\xA0\x1B\x03\x16\x80;\x15a\x01NW`@Qc\xF2\xD5\xD5k`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16`\x04\x82\x01R`$\x81\x01\x89\x90R\x90_\x90\x82\x90`D\x90\x82\x90\x84\x90Z\xF1\x80\x15a\x11\x8AWa\x14\x1FW[P\x86\x89R`\x01`\x01`\xA0\x1B\x03\x86\x81\x16\x92\x90\x82\x16\x83\x90\x03a\x12\x81W[PP\x835\x91F\x83\x03a\x10-WPPPPa\x0F\xD6`@\x82\x01a\tlV[\x80a\x10\x15W[a\x10\x06Wa\x0F\xF7\x91a\x0F\xF1` \x85\x93\x01a\t_V[\x90a\x1A^V[`\x01`\x80\x84\x01R[` \x83\x01RV[c6\xB5\x07\xFB`\xE0\x1B_R`\x04_\xFD[Pa\x10%a\x045` \x83\x01a\t_V[3\x14\x15a\x0F\xDCV[\x92\x94\x91\x93\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x82\x14\x93\x91\x84\x15a\x122WP`\x02T`\x01`\x01`\xA0\x1B\x03\x16[`\x01`\x01`\xA0\x1B\x03\x16`\xA0\x8A\x01\x81\x81R\x94\x90\x91\x90\x15a\x11\x8FW\x85a\x10\xDA\x92` \x92G\x99a\x10\xAFa\x10\xA30\x8Aa\x19\xCDV[\x92a\x01 \x81\x01\x90a\t\xDDV[`@Qc\xB1M6\x1D`\xE0\x1B\x81R\x97\x88\x96\x87\x95\x86\x95\x92\x94\x92`\x01`\x01`\xA0\x1B\x03\x16\x90\x8D`\x04\x88\x01a\x0E\xD3V[\x03\x914\x90Z\xF1\x80\x15a\x11\x8AWa\x11\x02\x91_\x91a\x11[W[P\x95a\x10\xFD4Ga\rWV[a\x0E\xC6V[\x80``\x8A\x01R\x80a\x11KW[P[\x85\x85\x03a\x11<Wa\x111\x86\x93a\x117\x96`\xC0\x8B\x01RQ`\x01\x80`\xA0\x1B\x03\x16\x90V[\x90a\x1C4V[a\x0F\xFFV[cB0\x1C#`\xE0\x1B_R`\x04_\xFD[a\x11U\x903a\x1A7V[_a\x11\x0EV[a\x11}\x91P` =` \x11a\x11\x83W[a\x11u\x81\x83a\t\x8DV[\x81\x01\x90a\rdV[_a\x10\xF1V[P=a\x11kV[a\r%V[` \x91\x86\x91_a\x11\xEB\x95\x99\x8D``4\x91\x01R4a\x12#W[a\x11\xC0a\x11\xB40\x8Aa\x19\xCDV[\x93a\x01 \x81\x01\x90a\t\xDDV[`@Qc\xB1M6\x1D`\xE0\x1B\x81R\x98\x89\x97\x88\x96\x87\x95\x92\x94\x92`\x01`\x01`\xA0\x1B\x03\x16\x90\x8D`\x04\x88\x01a\x0E\xD3V[\x03\x92Z\xF1\x90\x81\x15a\x11\x8AW_\x91a\x12\x04W[P\x93a\x11\x10V[a\x12\x1D\x91P` =` \x11a\x11\x83Wa\x11u\x81\x83a\t\x8DV[_a\x11\xFDV[a\x12-43a\x1A7V[a\x11\xA7V[\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x03a\x12rW`\x03T`\x01`\x01`\xA0\x1B\x03\x16a\x10sV[c\xB2\xAE\x85U`\xE0\x1B_R`\x04_\xFD[a\x14\x10Wa\x13\x05\x96` a\x12\xB8a\x045a\x12\xAB\x85`\x01\x80`\xA0\x1B\x03\x16_R`\x04` R`@_ \x90V[T`\x01`\x01`\xA0\x1B\x03\x16\x90V[a\x12\xC1Ba\rDV[`@QcR\x0B\x93U`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x80\x87\x16`\x04\x83\x01R\x8B\x16`$\x82\x01R`D\x81\x01\x85\x90R`d\x81\x01\x91\x90\x91R\x99\x8A\x91\x90\x82\x90_\x90\x82\x90`\x84\x82\x01\x90V[\x03\x92Z\xF1\x90\x81\x15a\x11\x8AW_\x98\x89\x92a\x13\xEEW[P` \x90\x82\x90\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x16\x90a\x13U\x90\x82\x87a\x1A^V[\x89a\x13da\x01\0\x8B\x01\x8Ba\rsV[a\x13\x89`@\x9E\x92\x9EQ\x9E\x8F\x96\x87\x95\x86\x94c\x8B\xCC\xC1\x87`\xE0\x1B\x86R0\x93`\x04\x87\x01a\r\xC9V[\x03\x92Z\xF1\x90\x81\x15a\x11\x8AW\x87a\x13\xC6\x93\x8C\x9A_\x94a\x13\xCDW[Pa\x13\xC0`@\x84\x9Ca\x13\xB4\x86\x88a\x0E\xC6V[\x91\x82\x91\x01R3\x84a\x1A^V[\x86a\x1A\xE5V[_\x80a\x0F\xBAV[a\x13\xE7\x91\x94P` =` \x11a\x11\x83Wa\x11u\x81\x83a\t\x8DV[\x92_a\x13\xA2V[` \x91\x92Pa\x14\t\x90\x82=\x84\x11a\x11\x83Wa\x11u\x81\x83a\t\x8DV[\x91\x90a\x13\x19V[c\x8F\xB4\xD1\x0F`\xE0\x1B_R`\x04_\xFD[\x80a\x14-_a\x143\x93a\t\x8DV[\x80a\x01\x95V[_a\x0F\x9FV[\x96Pa\x14N`\x01`\x01`\xA0\x1B\x03\x88\x16\x82a\x19\xCDV[\x96a\x0FSV[a\x14]\x90a\n\xB9V[\x90a\x0FMV[\x95\x90\x97\x92\x94a\x0B\xAD\x99\x94a\x02\xD2\x96a\x159\x99\x94\x89\x7F.e\x90\x81\xF4LOV\xA1\x8B\0\xF3\xF9\xD16\xD7\xEE\x83\x96\xBCy\x16<Ma6=\xDC\xF4\xA4\xCB'a\x01 \x8E`@Q\x90\x15\x15\x81R\x84` \x82\x01R\x85`@\x82\x01R\x86``\x82\x01R\x87`\x80\x82\x01R\x88\x15\x15`\xA0\x82\x01R`\x01\x80`\xA0\x1B\x03\x8A\x16`\xC0\x82\x01R\x8A`\xE0\x82\x01R\x8Ba\x01\0\x82\x01R\xA2`@Q\x9B\x8C\x9A` \x8C\x01\x96\x93\x90\x9A\x99\x98\x95\x92a\x01 \x98\x95\x92a\x01@\x89\x01\x9C\x89R\x15\x15` \x89\x01R`@\x88\x01R``\x87\x01R`\x80\x86\x01R`\xA0\x85\x01R\x15\x15`\xC0\x84\x01R`\x01\x80`\xA0\x1B\x03\x16`\xE0\x83\x01Ra\x01\0\x82\x01R\x01RV[a\x18\x87V[c\x8Bx\xC6\xD8\x19T3\x03a\x15MWV[c\x82\xB4)\0_R`\x04`\x1C\xFD[\x80Q\x91\x90\x82\x90` \x01\x82^\x01_\x81R\x90V[\x90``\x92` \x91\x83R`@\x82\x84\x01R\x80Q\x91\x82\x91\x82`@\x86\x01R\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[`\x01\x80T\x01\x80`\x01U` _a\x16\r\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F\x14\xC0(\xD3\xD6h\xEB4T\xBC\xE4M\x12<\xEE\xEB\x9F\xB4\xE7K\xEE\x07<A\xF4\0\x1Ec\xF0a0\x94`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[`@Q\x91\x82\x80\x92a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F\x14\xC0(\xD3\xD6h\xEB4T\xBC\xE4M\x12<\xEE\xEB\x9F\xB4\xE7K\xEE\x07<A\xF4\0\x1Ec\xF0a0\x94\x83a\x15lV[\x03\x90\xA4V[`\x01\x80T\x01\x80`\x01U` _a\x16\xC8\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F.=}\x02\xBA<K\xD8\xB1\xF8\x99\\\xD3\xA2>\xF0\x199\"\xEB\xC4\xEE#$\x9E\xADM\x0C\xA2\xE3Lh`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F.=}\x02\xBA<K\xD8\xB1\xF8\x99\\\xD3\xA2>\xF0\x199\"\xEB\xC4\xEE#$\x9E\xADM\x0C\xA2\xE3Lh\x83a\x15lV[`\x01\x80T\x01\x80`\x01U` _a\x17~\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7FH\x8F\x06\xA9\xCA\x9E\x19\xE1\xDD\x90\xC7d\xCCy\xB7e\xE8\xA3\xA0\x89\xEF'\xD9\xA0\xE3\x9D\xEE!\xC7d1\x88`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7FH\x8F\x06\xA9\xCA\x9E\x19\xE1\xDD\x90\xC7d\xCCy\xB7e\xE8\xA3\xA0\x89\xEF'\xD9\xA0\xE3\x9D\xEE!\xC7d1\x88\x83a\x15lV[`\x01\x80T\x01\x80`\x01U` _a\x184\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7Fs\x91\xF1CU\xEF\xF1\xE5Y\xE3\x81\xF5\xBFI\x88jw\xDA|O\xDD3\xC6\xFC.\x01B&\x9CV\x1CY`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7Fs\x91\xF1CU\xEF\xF1\xE5Y\xE3\x81\xF5\xBFI\x88jw\xDA|O\xDD3\xC6\xFC.\x01B&\x9CV\x1CY\x83a\x15lV[`\x01\x80T\x01\x80`\x01U` _a\x18\xEA\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F.e\x90\x81\xF4LOV\xA1\x8B\0\xF3\xF9\xD16\xD7\xEE\x83\x96\xBCy\x16<Ma6=\xDC\xF4\xA4\xCB'`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F.e\x90\x81\xF4LOV\xA1\x8B\0\xF3\xF9\xD16\xD7\xEE\x83\x96\xBCy\x16<Ma6=\xDC\xF4\xA4\xCB'\x83a\x15lV[`\x01\x80T\x01\x80`\x01U` _a\x19\x8D\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R_Q` a\x1DH_9_Q\x90_R`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91_Q` a\x1DH_9_Q\x90_R\x83a\x15lV[`\x01`\x01`\xA0\x1B\x03\x16\x90\x81\x15a\x1A1W`@Qcp\xA0\x821`\xE0\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA\x90\x81\x15a\x11\x8AW_\x91a\x1A\x18WP\x90V[a\ti\x91P` =` \x11a\x11\x83Wa\x11u\x81\x83a\t\x8DV[\x90P1\x90V[_\x918\x91\x83\x91\x82\x91`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a\x1AQWV[c\xB1-\x13\xEB_R`\x04`\x1C\xFD[\x91\x90`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\x1A\xC9W`\x01`\x01`\xA0\x1B\x03\x16`\x14R`4Rc\xA9\x05\x9C\xBB``\x1B_\x90\x81R` \x90`D`\x10\x82\x85Z\xF1\x90\x81`\x01_Q\x14\x16\x15a\x1A\xABW[PP_`4RV[;\x15=\x17\x10\x15a\x1A\xBCW_\x80a\x1A\xA3V[c\x90\xB8\xEC\x18_R`\x04`\x1C\xFD[_\x92P8\x91\x83\x91\x82\x91\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xF1\x15a\x1AQWV[`@\x80Q\x85\x81R` \x81\x01\x87\x90R\x92\x95a\x1B~\x95\x92\x94a\x02\xD2\x94\x91\x93\x92\x90\x91`\x01`\x01`\xA0\x1B\x03\x80\x84\x16\x92\x90\x8A\x16\x91\x88\x91\x7F/Lv\xC8\xD1\x8FE\x06\x9B\tAI\x92\x05\xA7\xFC\xEA\xAA<\xAF\x9E.c(\xF6\xA5D\xCD3\x91 \xF3\x91\x90\x81\x90\x81\x01[\x03\x90\xA4`@\x80Q` \x81\x01\x96\x90\x96R`\x01`\x01`\xA0\x1B\x03\x97\x88\x16\x90\x86\x01R\x90\x95\x16``\x84\x01R`\x80\x83\x01\x94\x90\x94R`\xA0\x82\x01\x93\x90\x93R\x91\x82\x90`\xC0\x82\x01\x90V[`\x01\x80T\x01\x80`\x01U` _a\x1B\xE1\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F/Lv\xC8\xD1\x8FE\x06\x9B\tAI\x92\x05\xA7\xFC\xEA\xAA<\xAF\x9E.c(\xF6\xA5D\xCD3\x91 \xF3`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F/Lv\xC8\xD1\x8FE\x06\x9B\tAI\x92\x05\xA7\xFC\xEA\xAA<\xAF\x9E.c(\xF6\xA5D\xCD3\x91 \xF3\x83a\x15lV[`@\x80Q\x85\x81R` \x81\x01\x87\x90R\x92\x95a\x1C\x91\x95\x92\x94a\x02\xD2\x94\x91\x93\x92\x90\x91`\x01`\x01`\xA0\x1B\x03\x80\x84\x16\x92\x90\x8A\x16\x91\x88\x91\x7F-\xFC\xF6F\xF9S\xB4\x1D,\xD9\xD3\x0B\xCF?l\xDARH\xEF\xCDw3\xAD\xFF:%\xE8\x8F5\xB8\xAF\xCB\x91\x90\x81\x90\x81\x01a\x1B>V[`\x01\x80T\x01\x80`\x01U` _a\x1C\xF4\x81T\x93`@Q\x90\x85\x85\x83\x01R`@\x82\x01RC``\x82\x01RB`\x80\x82\x01R\x7F-\xFC\xF6F\xF9S\xB4\x1D,\xD9\xD3\x0B\xCF?l\xDARH\xEF\xCDw3\xAD\xFF:%\xE8\x8F5\xB8\xAF\xCB`\xA0\x82\x01Ra\x16\x01\x81a\x02\xD2`\xC0\x82\x01\x89a\x15ZV[\x03\x90`\x02Z\xFA\x15a\x11\x8AW_Q_U`\x01T_Q` a\x1Dh_9_Q\x90_Ra\x16`_T\x94`@Q\x91\x82\x91\x7F-\xFC\xF6F\xF9S\xB4\x1D,\xD9\xD3\x0B\xCF?l\xDARH\xEF\xCDw3\xAD\xFF:%\xE8\x8F5\xB8\xAF\xCB\x83a\x15lV\xFE\x8B\xE0\x07\x9CS\x16Y\x14\x13D\xCD\x1F\xD0\xA4\xF2\x84\x19I\x7F\x97\"\xA3\xDA\xAF\xE3\xB4\x18okdW\xE0x\x16\x0F\x0B\x1B+2\xB5*\0v\xD8\xF0\xF7\x08\x88h{\xA7\x02\xA4\xD9\x93\xD5Z\xC8\xD92}W\xA1'\xA1dsolcC\0\x08\x1B\0\n",
    );
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct Call { address to; uint256 value; bytes data; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Call {
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub value: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Call> for UnderlyingRustTuple<'_> {
            fn from(value: Call) -> Self {
                (value.to, value.value, value.data)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Call {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    to: tuple.0,
                    value: tuple.1,
                    data: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Call {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Call {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.to,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.value),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Call {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Call {
            const NAME: &'static str = "Call";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Call(address to,uint256 value,bytes data)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.to,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.value)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.data,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Call {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.to,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.value)
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.data,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.to,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.value,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.data,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**```solidity
struct PullRequest { uint256 targetChain; address beneficiary; bool beneficiaryClaimOnly; bytes32 intentHash; bytes32 forwardSalt; uint256 balance; address tokenIn; address tokenOut; Call[] swapData; bytes bridgeData; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PullRequest {
        #[allow(missing_docs)]
        pub targetChain: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub beneficiaryClaimOnly: bool,
        #[allow(missing_docs)]
        pub intentHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub forwardSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub tokenIn: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenOut: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub swapData: alloy::sol_types::private::Vec<
            <Call as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub bridgeData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Array<Call>,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            bool,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Vec<
                <Call as alloy::sol_types::SolType>::RustType,
            >,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PullRequest> for UnderlyingRustTuple<'_> {
            fn from(value: PullRequest) -> Self {
                (
                    value.targetChain,
                    value.beneficiary,
                    value.beneficiaryClaimOnly,
                    value.intentHash,
                    value.forwardSalt,
                    value.balance,
                    value.tokenIn,
                    value.tokenOut,
                    value.swapData,
                    value.bridgeData,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PullRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    targetChain: tuple.0,
                    beneficiary: tuple.1,
                    beneficiaryClaimOnly: tuple.2,
                    intentHash: tuple.3,
                    forwardSalt: tuple.4,
                    balance: tuple.5,
                    tokenIn: tuple.6,
                    tokenOut: tuple.7,
                    swapData: tuple.8,
                    bridgeData: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PullRequest {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PullRequest {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChain),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiaryClaimOnly,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.intentHash),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.forwardSalt),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenIn,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenOut,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        Call,
                    > as alloy_sol_types::SolType>::tokenize(&self.swapData),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.bridgeData,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PullRequest {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PullRequest {
            const NAME: &'static str = "PullRequest";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PullRequest(uint256 targetChain,address beneficiary,bool beneficiaryClaimOnly,bytes32 intentHash,bytes32 forwardSalt,uint256 balance,address tokenIn,address tokenOut,Call[] swapData,bytes bridgeData)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<Call as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<Call as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.targetChain)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.beneficiary,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.beneficiaryClaimOnly,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.intentHash)
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.forwardSalt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.balance)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.tokenIn,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.tokenOut,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        Call,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.swapData)
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.bridgeData,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PullRequest {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.targetChain,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beneficiary,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.beneficiaryClaimOnly,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.intentHash,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.forwardSalt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.balance,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tokenIn,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.tokenOut,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        Call,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.swapData,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.bridgeData,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.targetChain,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beneficiary,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.beneficiaryClaimOnly,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.intentHash,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.forwardSalt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.balance,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tokenIn,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.tokenOut,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    Call,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.swapData,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.bridgeData,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `AlreadyInitialized()` and selector `0x0dc149f0`.
```solidity
error AlreadyInitialized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyInitialized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyInitialized> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyInitialized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyInitialized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyInitialized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyInitialized()";
            const SELECTOR: [u8; 4] = [13u8, 193u8, 73u8, 240u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `InsufficientOutputAmount()` and selector `0x42301c23`.
```solidity
error InsufficientOutputAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientOutputAmount;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientOutputAmount>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientOutputAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientOutputAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientOutputAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientOutputAmount()";
            const SELECTOR: [u8; 4] = [66u8, 48u8, 28u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `NewOwnerIsZeroAddress()` and selector `0x7448fbae`.
```solidity
error NewOwnerIsZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NewOwnerIsZeroAddress;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NewOwnerIsZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: NewOwnerIsZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NewOwnerIsZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NewOwnerIsZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NewOwnerIsZeroAddress()";
            const SELECTOR: [u8; 4] = [116u8, 72u8, 251u8, 174u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `PullerUnauthorized()` and selector `0x36b507fb`.
```solidity
error PullerUnauthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PullerUnauthorized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PullerUnauthorized> for UnderlyingRustTuple<'_> {
            fn from(value: PullerUnauthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PullerUnauthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PullerUnauthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PullerUnauthorized()";
            const SELECTOR: [u8; 4] = [54u8, 181u8, 7u8, 251u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `SwapOnEphemeralReceiversNotAllowed()` and selector `0x8fb4d10f`.
```solidity
error SwapOnEphemeralReceiversNotAllowed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SwapOnEphemeralReceiversNotAllowed;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SwapOnEphemeralReceiversNotAllowed>
        for UnderlyingRustTuple<'_> {
            fn from(value: SwapOnEphemeralReceiversNotAllowed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SwapOnEphemeralReceiversNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SwapOnEphemeralReceiversNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SwapOnEphemeralReceiversNotAllowed()";
            const SELECTOR: [u8; 4] = [143u8, 180u8, 209u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `Unauthorized()` and selector `0x82b42900`.
```solidity
error Unauthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Unauthorized;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Unauthorized> for UnderlyingRustTuple<'_> {
            fn from(value: Unauthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Unauthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Unauthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Unauthorized()";
            const SELECTOR: [u8; 4] = [130u8, 180u8, 41u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Custom error with signature `UnsupportedOutputToken()` and selector `0xb2ae8555`.
```solidity
error UnsupportedOutputToken();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UnsupportedOutputToken;
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        #[allow(dead_code)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnsupportedOutputToken> for UnderlyingRustTuple<'_> {
            fn from(value: UnsupportedOutputToken) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for UnsupportedOutputToken {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UnsupportedOutputToken {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UnsupportedOutputToken()";
            const SELECTOR: [u8; 4] = [178u8, 174u8, 133u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_raw_validate(data: &[u8]) -> alloy_sol_types::Result<Self> {
                <Self::Parameters<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Self::new)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BridgeInitiated(bytes32,address,address,uint256,uint256)` and selector `0x2dfcf646f953b41d2cd9d30bcf3f6cda5248efcd7733adff3a25e88f35b8afcb`.
```solidity
event BridgeInitiated(bytes32 indexed forwardId, address indexed bridger, address indexed tokenOut, uint256 amountIn, uint256 targetChain);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgeInitiated {
        #[allow(missing_docs)]
        pub forwardId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub bridger: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenOut: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amountIn: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub targetChain: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgeInitiated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgeInitiated(bytes32,address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                45u8, 252u8, 246u8, 70u8, 249u8, 83u8, 180u8, 29u8, 44u8, 217u8, 211u8,
                11u8, 207u8, 63u8, 108u8, 218u8, 82u8, 72u8, 239u8, 205u8, 119u8, 51u8,
                173u8, 255u8, 58u8, 37u8, 232u8, 143u8, 53u8, 184u8, 175u8, 203u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    forwardId: topics.1,
                    bridger: topics.2,
                    tokenOut: topics.3,
                    amountIn: data.0,
                    targetChain: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountIn),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChain),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.forwardId.clone(),
                    self.bridger.clone(),
                    self.tokenOut.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.forwardId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.bridger,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.tokenOut,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgeInitiated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgeInitiated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgeInitiated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `BridgersSet(address,address)` and selector `0x14c028d3d668eb3454bce44d123ceeeb9fb4e74bee073c41f4001e63f0613094`.
```solidity
event BridgersSet(address indexed usdtBridger, address indexed usdcBridger);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BridgersSet {
        #[allow(missing_docs)]
        pub usdtBridger: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub usdcBridger: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BridgersSet {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BridgersSet(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                20u8, 192u8, 40u8, 211u8, 214u8, 104u8, 235u8, 52u8, 84u8, 188u8, 228u8,
                77u8, 18u8, 60u8, 238u8, 235u8, 159u8, 180u8, 231u8, 75u8, 238u8, 7u8,
                60u8, 65u8, 244u8, 0u8, 30u8, 99u8, 240u8, 97u8, 48u8, 148u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    usdtBridger: topics.1,
                    usdcBridger: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.usdtBridger.clone(),
                    self.usdcBridger.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.usdtBridger,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.usdcBridger,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BridgersSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BridgersSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BridgersSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `EventAppended(uint256,bytes32,bytes32,bytes32,bytes)` and selector `0x78160f0b1b2b32b52a0076d8f0f70888687ba702a4d993d55ac8d9327d57a127`.
```solidity
event EventAppended(uint256 indexed eventSeq, bytes32 indexed prevTip, bytes32 indexed newTip, bytes32 eventSignature, bytes abiEncodedEventData);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EventAppended {
        #[allow(missing_docs)]
        pub eventSeq: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub prevTip: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newTip: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub eventSignature: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub abiEncodedEventData: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EventAppended {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "EventAppended(uint256,bytes32,bytes32,bytes32,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                120u8, 22u8, 15u8, 11u8, 27u8, 43u8, 50u8, 181u8, 42u8, 0u8, 118u8,
                216u8, 240u8, 247u8, 8u8, 136u8, 104u8, 123u8, 167u8, 2u8, 164u8, 217u8,
                147u8, 213u8, 90u8, 200u8, 217u8, 50u8, 125u8, 87u8, 161u8, 39u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    eventSeq: topics.1,
                    prevTip: topics.2,
                    newTip: topics.3,
                    eventSignature: data.0,
                    abiEncodedEventData: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.eventSignature),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.abiEncodedEventData,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.eventSeq.clone(),
                    self.prevTip.clone(),
                    self.newTip.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.eventSeq);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.prevTip);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newTip);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EventAppended {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EventAppended> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EventAppended) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ForwardCompleted(bytes32,bool,uint256,uint256,uint256,uint256,bool,address,uint256,bytes32)` and selector `0x2e659081f44c4f56a18b00f3f9d136d7ee8396bc79163c4d61363ddcf4a4cb27`.
```solidity
event ForwardCompleted(bytes32 indexed forwardId, bool ephemeral, uint256 amountPulled, uint256 amountForwarded, uint256 relayerRebate, uint256 msgValueRefunded, bool settledLocally, address bridger, uint256 expectedBridgeOut, bytes32 bridgeDataHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ForwardCompleted {
        #[allow(missing_docs)]
        pub forwardId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub ephemeral: bool,
        #[allow(missing_docs)]
        pub amountPulled: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub amountForwarded: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub relayerRebate: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub msgValueRefunded: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub settledLocally: bool,
        #[allow(missing_docs)]
        pub bridger: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub expectedBridgeOut: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub bridgeDataHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ForwardCompleted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "ForwardCompleted(bytes32,bool,uint256,uint256,uint256,uint256,bool,address,uint256,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                46u8, 101u8, 144u8, 129u8, 244u8, 76u8, 79u8, 86u8, 161u8, 139u8, 0u8,
                243u8, 249u8, 209u8, 54u8, 215u8, 238u8, 131u8, 150u8, 188u8, 121u8,
                22u8, 60u8, 77u8, 97u8, 54u8, 61u8, 220u8, 244u8, 164u8, 203u8, 39u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    forwardId: topics.1,
                    ephemeral: data.0,
                    amountPulled: data.1,
                    amountForwarded: data.2,
                    relayerRebate: data.3,
                    msgValueRefunded: data.4,
                    settledLocally: data.5,
                    bridger: data.6,
                    expectedBridgeOut: data.7,
                    bridgeDataHash: data.8,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.ephemeral,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountPulled),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amountForwarded),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.relayerRebate),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.msgValueRefunded),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.settledLocally,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.bridger,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedBridgeOut),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.bridgeDataHash),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.forwardId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.forwardId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ForwardCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ForwardCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ForwardCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ForwardStarted(bytes32,bytes32,bytes32,bytes32,uint256,address,bool,uint256,address,address,address,address)` and selector `0x7391f14355eff1e559e381f5bf49886a77da7c4fdd33c6fc2e0142269c561c59`.
```solidity
event ForwardStarted(bytes32 indexed forwardId, bytes32 indexed baseReceiverSalt, bytes32 indexed forwardSalt, bytes32 intentHash, uint256 targetChain, address beneficiary, bool beneficiaryClaimOnly, uint256 balanceParam, address tokenIn, address tokenOut, address receiverUsed, address ephemeralReceiver);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ForwardStarted {
        #[allow(missing_docs)]
        pub forwardId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub baseReceiverSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub forwardSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub intentHash: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub targetChain: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub beneficiary: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub beneficiaryClaimOnly: bool,
        #[allow(missing_docs)]
        pub balanceParam: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub tokenIn: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenOut: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub receiverUsed: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub ephemeralReceiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ForwardStarted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "ForwardStarted(bytes32,bytes32,bytes32,bytes32,uint256,address,bool,uint256,address,address,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                115u8, 145u8, 241u8, 67u8, 85u8, 239u8, 241u8, 229u8, 89u8, 227u8, 129u8,
                245u8, 191u8, 73u8, 136u8, 106u8, 119u8, 218u8, 124u8, 79u8, 221u8, 51u8,
                198u8, 252u8, 46u8, 1u8, 66u8, 38u8, 156u8, 86u8, 28u8, 89u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    forwardId: topics.1,
                    baseReceiverSalt: topics.2,
                    forwardSalt: topics.3,
                    intentHash: data.0,
                    targetChain: data.1,
                    beneficiary: data.2,
                    beneficiaryClaimOnly: data.3,
                    balanceParam: data.4,
                    tokenIn: data.5,
                    tokenOut: data.6,
                    receiverUsed: data.7,
                    ephemeralReceiver: data.8,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.intentHash),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.targetChain),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiary,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.beneficiaryClaimOnly,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balanceParam),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenIn,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.tokenOut,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.receiverUsed,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.ephemeralReceiver,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.forwardId.clone(),
                    self.baseReceiverSalt.clone(),
                    self.forwardSalt.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.forwardId);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.baseReceiverSalt);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.forwardSalt);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ForwardStarted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ForwardStarted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ForwardStarted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.
```solidity
event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub oldOwner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.oldOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.oldOwner,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.newOwner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `QuoterSet(address,address)` and selector `0x2e3d7d02ba3c4bd8b1f8995cd3a23ef0193922ebc4ee23249ead4d0ca2e34c68`.
```solidity
event QuoterSet(address indexed tokenIn, address indexed quoter);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct QuoterSet {
        #[allow(missing_docs)]
        pub tokenIn: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub quoter: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for QuoterSet {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "QuoterSet(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                46u8, 61u8, 125u8, 2u8, 186u8, 60u8, 75u8, 216u8, 177u8, 248u8, 153u8,
                92u8, 211u8, 162u8, 62u8, 240u8, 25u8, 57u8, 34u8, 235u8, 196u8, 238u8,
                35u8, 36u8, 158u8, 173u8, 77u8, 12u8, 162u8, 227u8, 76u8, 104u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    tokenIn: topics.1,
                    quoter: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.tokenIn.clone(), self.quoter.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.tokenIn,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.quoter,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for QuoterSet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&QuoterSet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &QuoterSet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `ReceiverDeployed(bytes32,address,address)` and selector `0x488f06a9ca9e19e1dd90c764cc79b765e8a3a089ef27d9a0e39dee21c7643188`.
```solidity
event ReceiverDeployed(bytes32 indexed receiverSalt, address indexed receiver, address implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ReceiverDeployed {
        #[allow(missing_docs)]
        pub receiverSalt: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ReceiverDeployed {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ReceiverDeployed(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                72u8, 143u8, 6u8, 169u8, 202u8, 158u8, 25u8, 225u8, 221u8, 144u8, 199u8,
                100u8, 204u8, 121u8, 183u8, 101u8, 232u8, 163u8, 160u8, 137u8, 239u8,
                39u8, 217u8, 160u8, 227u8, 157u8, 238u8, 33u8, 199u8, 100u8, 49u8, 136u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    receiverSalt: topics.1,
                    receiver: topics.2,
                    implementation: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.receiverSalt.clone(),
                    self.receiver.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.receiverSalt);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.receiver,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ReceiverDeployed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ReceiverDeployed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ReceiverDeployed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Event with signature `SwapExecuted(bytes32,address,address,uint256,uint256)` and selector `0x2f4c76c8d18f45069b0941499205a7fceaaa3caf9e2e6328f6a544cd339120f3`.
```solidity
event SwapExecuted(bytes32 indexed forwardId, address indexed tokenIn, address indexed tokenOut, uint256 minOut, uint256 actualOut);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SwapExecuted {
        #[allow(missing_docs)]
        pub forwardId: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub tokenIn: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub tokenOut: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub minOut: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub actualOut: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SwapExecuted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SwapExecuted(bytes32,address,address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8, 76u8, 118u8, 200u8, 209u8, 143u8, 69u8, 6u8, 155u8, 9u8, 65u8,
                73u8, 146u8, 5u8, 167u8, 252u8, 234u8, 170u8, 60u8, 175u8, 158u8, 46u8,
                99u8, 40u8, 246u8, 165u8, 68u8, 205u8, 51u8, 145u8, 32u8, 243u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    forwardId: topics.1,
                    tokenIn: topics.2,
                    tokenOut: topics.3,
                    minOut: data.0,
                    actualOut: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.minOut),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualOut),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.forwardId.clone(),
                    self.tokenIn.clone(),
                    self.tokenOut.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.forwardId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.tokenIn,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.tokenOut,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SwapExecuted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SwapExecuted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SwapExecuted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Constructor`.
```solidity
constructor(address _usdt, address _usdc, address _owner);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct constructorCall {
        #[allow(missing_docs)]
        pub _usdt: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _usdc: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _owner: alloy::sol_types::private::Address,
    }
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._usdt, value._usdc, value._owner)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _usdt: tuple.0,
                        _usdc: tuple.1,
                        _owner: tuple.2,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._usdt,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._usdc,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._owner,
                    ),
                )
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `RECEIVER_BYTECODE_HASH()` and selector `0xe8e3cc1c`.
```solidity
function RECEIVER_BYTECODE_HASH() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RECEIVER_BYTECODE_HASHCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`RECEIVER_BYTECODE_HASH()`](RECEIVER_BYTECODE_HASHCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RECEIVER_BYTECODE_HASHReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RECEIVER_BYTECODE_HASHCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: RECEIVER_BYTECODE_HASHCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RECEIVER_BYTECODE_HASHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RECEIVER_BYTECODE_HASHReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: RECEIVER_BYTECODE_HASHReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RECEIVER_BYTECODE_HASHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for RECEIVER_BYTECODE_HASHCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RECEIVER_BYTECODE_HASH()";
            const SELECTOR: [u8; 4] = [232u8, 227u8, 204u8, 28u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: RECEIVER_BYTECODE_HASHReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: RECEIVER_BYTECODE_HASHReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `RECEIVER_IMPLEMENTATION()` and selector `0x0496c2f1`.
```solidity
function RECEIVER_IMPLEMENTATION() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RECEIVER_IMPLEMENTATIONCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`RECEIVER_IMPLEMENTATION()`](RECEIVER_IMPLEMENTATIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct RECEIVER_IMPLEMENTATIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RECEIVER_IMPLEMENTATIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: RECEIVER_IMPLEMENTATIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RECEIVER_IMPLEMENTATIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<RECEIVER_IMPLEMENTATIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: RECEIVER_IMPLEMENTATIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for RECEIVER_IMPLEMENTATIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for RECEIVER_IMPLEMENTATIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "RECEIVER_IMPLEMENTATION()";
            const SELECTOR: [u8; 4] = [4u8, 150u8, 194u8, 241u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: RECEIVER_IMPLEMENTATIONReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: RECEIVER_IMPLEMENTATIONReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `SWAP_EXECUTOR()` and selector `0x0b345879`.
```solidity
function SWAP_EXECUTOR() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SWAP_EXECUTORCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`SWAP_EXECUTOR()`](SWAP_EXECUTORCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SWAP_EXECUTORReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SWAP_EXECUTORCall> for UnderlyingRustTuple<'_> {
                fn from(value: SWAP_EXECUTORCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SWAP_EXECUTORCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SWAP_EXECUTORReturn> for UnderlyingRustTuple<'_> {
                fn from(value: SWAP_EXECUTORReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for SWAP_EXECUTORReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SWAP_EXECUTORCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SWAP_EXECUTOR()";
            const SELECTOR: [u8; 4] = [11u8, 52u8, 88u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: SWAP_EXECUTORReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: SWAP_EXECUTORReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `USDC()` and selector `0x89a30271`.
```solidity
function USDC() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct USDCCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`USDC()`](USDCCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct USDCReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USDCCall> for UnderlyingRustTuple<'_> {
                fn from(value: USDCCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for USDCCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USDCReturn> for UnderlyingRustTuple<'_> {
                fn from(value: USDCReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for USDCReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for USDCCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "USDC()";
            const SELECTOR: [u8; 4] = [137u8, 163u8, 2u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: USDCReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: USDCReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `USDT()` and selector `0xc54e44eb`.
```solidity
function USDT() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct USDTCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`USDT()`](USDTCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct USDTReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USDTCall> for UnderlyingRustTuple<'_> {
                fn from(value: USDTCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for USDTCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<USDTReturn> for UnderlyingRustTuple<'_> {
                fn from(value: USDTReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for USDTReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for USDTCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "USDT()";
            const SELECTOR: [u8; 4] = [197u8, 78u8, 68u8, 235u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: USDTReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: USDTReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eventChainTip()` and selector `0x4d53e931`.
```solidity
function eventChainTip() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eventChainTip()`](eventChainTipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventChainTipReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipCall> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventChainTipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eventChainTipReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventChainTipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eventChainTipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::FixedBytes<32>;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eventChainTip()";
            const SELECTOR: [u8; 4] = [77u8, 83u8, 233u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: eventChainTipReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `eventSeq()` and selector `0xe24d5c35`.
```solidity
function eventSeq() external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventSeqCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`eventSeq()`](eventSeqCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct eventSeqReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventSeqCall> for UnderlyingRustTuple<'_> {
                fn from(value: eventSeqCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventSeqCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<eventSeqReturn> for UnderlyingRustTuple<'_> {
                fn from(value: eventSeqReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for eventSeqReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for eventSeqCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "eventSeq()";
            const SELECTOR: [u8; 4] = [226u8, 77u8, 92u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: eventSeqReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: eventSeqReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `getReceiver(bytes32)` and selector `0xed61a911`.
```solidity
function getReceiver(bytes32 salt) external returns (address receiver);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getReceiverCall {
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`getReceiver(bytes32)`](getReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getReceiverReturn {
        #[allow(missing_docs)]
        pub receiver: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getReceiverCall> for UnderlyingRustTuple<'_> {
                fn from(value: getReceiverCall) -> Self {
                    (value.salt,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { salt: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getReceiverReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getReceiverReturn) -> Self {
                    (value.receiver,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { receiver: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getReceiverCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getReceiver(bytes32)";
            const SELECTOR: [u8; 4] = [237u8, 97u8, 169u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: getReceiverReturn = r.into();
                        r.receiver
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: getReceiverReturn = r.into();
                        r.receiver
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `owner()` and selector `0x8da5cb5b`.
```solidity
function owner() external view returns (address result);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`owner()`](ownerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ownerReturn {
        #[allow(missing_docs)]
        pub result: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value.result,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { result: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r.result
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: ownerReturn = r.into();
                        r.result
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `predictReceiverAddress(bytes32)` and selector `0x3fea3488`.
```solidity
function predictReceiverAddress(bytes32 salt) external view returns (address predicted);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictReceiverAddressCall {
        #[allow(missing_docs)]
        pub salt: alloy::sol_types::private::FixedBytes<32>,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`predictReceiverAddress(bytes32)`](predictReceiverAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct predictReceiverAddressReturn {
        #[allow(missing_docs)]
        pub predicted: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictReceiverAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictReceiverAddressCall) -> Self {
                    (value.salt,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictReceiverAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { salt: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<predictReceiverAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: predictReceiverAddressReturn) -> Self {
                    (value.predicted,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for predictReceiverAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { predicted: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for predictReceiverAddressCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "predictReceiverAddress(bytes32)";
            const SELECTOR: [u8; 4] = [63u8, 234u8, 52u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.salt),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: predictReceiverAddressReturn = r.into();
                        r.predicted
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: predictReceiverAddressReturn = r.into();
                        r.predicted
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `pullFromReceiver((uint256,address,bool,bytes32,bytes32,uint256,address,address,(address,uint256,bytes)[],bytes))` and selector `0x1ad1087b`.
```solidity
function pullFromReceiver(PullRequest memory req) external payable returns (uint256 amountOut);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pullFromReceiverCall {
        #[allow(missing_docs)]
        pub req: <PullRequest as alloy::sol_types::SolType>::RustType,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`pullFromReceiver((uint256,address,bool,bytes32,bytes32,uint256,address,address,(address,uint256,bytes)[],bytes))`](pullFromReceiverCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pullFromReceiverReturn {
        #[allow(missing_docs)]
        pub amountOut: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (PullRequest,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PullRequest as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pullFromReceiverCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: pullFromReceiverCall) -> Self {
                    (value.req,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pullFromReceiverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { req: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pullFromReceiverReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: pullFromReceiverReturn) -> Self {
                    (value.amountOut,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pullFromReceiverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { amountOut: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pullFromReceiverCall {
            type Parameters<'a> = (PullRequest,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::primitives::aliases::U256;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pullFromReceiver((uint256,address,bool,bytes32,bytes32,uint256,address,address,(address,uint256,bytes)[],bytes))";
            const SELECTOR: [u8; 4] = [26u8, 209u8, 8u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<PullRequest as alloy_sol_types::SolType>::tokenize(&self.req),)
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(ret),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: pullFromReceiverReturn = r.into();
                        r.amountOut
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: pullFromReceiverReturn = r.into();
                        r.amountOut
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `quoterByToken(address)` and selector `0x007f2b66`.
```solidity
function quoterByToken(address) external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct quoterByTokenCall(pub alloy::sol_types::private::Address);
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`quoterByToken(address)`](quoterByTokenCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct quoterByTokenReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<quoterByTokenCall> for UnderlyingRustTuple<'_> {
                fn from(value: quoterByTokenCall) -> Self {
                    (value.0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for quoterByTokenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self(tuple.0)
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<quoterByTokenReturn> for UnderlyingRustTuple<'_> {
                fn from(value: quoterByTokenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for quoterByTokenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for quoterByTokenCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "quoterByToken(address)";
            const SELECTOR: [u8; 4] = [0u8, 127u8, 43u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.0,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: quoterByTokenReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: quoterByTokenReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `renounceOwnership()` and selector `0x715018a6`.
```solidity
function renounceOwnership() external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall;
    ///Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl renounceOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <renounceOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                renounceOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setBridgers(address,address)` and selector `0x2b0f3ee4`.
```solidity
function setBridgers(address _usdtBridger, address _usdcBridger) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgersCall {
        #[allow(missing_docs)]
        pub _usdtBridger: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub _usdcBridger: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setBridgers(address,address)`](setBridgersCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setBridgersReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgersCall> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgersCall) -> Self {
                    (value._usdtBridger, value._usdcBridger)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgersCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _usdtBridger: tuple.0,
                        _usdcBridger: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setBridgersReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setBridgersReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setBridgersReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setBridgersReturn {
            fn _tokenize(
                &self,
            ) -> <setBridgersCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setBridgersCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setBridgersReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setBridgers(address,address)";
            const SELECTOR: [u8; 4] = [43u8, 15u8, 62u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._usdtBridger,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._usdcBridger,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setBridgersReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `setQuoter(address,address)` and selector `0x6264257a`.
```solidity
function setQuoter(address targetToken, address quoter) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setQuoterCall {
        #[allow(missing_docs)]
        pub targetToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub quoter: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setQuoter(address,address)`](setQuoterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setQuoterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setQuoterCall> for UnderlyingRustTuple<'_> {
                fn from(value: setQuoterCall) -> Self {
                    (value.targetToken, value.quoter)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setQuoterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        targetToken: tuple.0,
                        quoter: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setQuoterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setQuoterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setQuoterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl setQuoterReturn {
            fn _tokenize(
                &self,
            ) -> <setQuoterCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setQuoterCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setQuoterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setQuoter(address,address)";
            const SELECTOR: [u8; 4] = [98u8, 100u8, 37u8, 122u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.targetToken,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.quoter,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                setQuoterReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.
```solidity
function transferOwnership(address newOwner) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        impl transferOwnershipReturn {
            fn _tokenize(
                &self,
            ) -> <transferOwnershipCall as alloy_sol_types::SolCall>::ReturnToken<'_> {
                ()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                transferOwnershipReturn::_tokenize(ret)
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(Into::into)
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(Into::into)
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `usdcBridger()` and selector `0xd08bd89f`.
```solidity
function usdcBridger() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usdcBridgerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`usdcBridger()`](usdcBridgerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usdcBridgerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usdcBridgerCall> for UnderlyingRustTuple<'_> {
                fn from(value: usdcBridgerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usdcBridgerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usdcBridgerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: usdcBridgerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usdcBridgerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for usdcBridgerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "usdcBridger()";
            const SELECTOR: [u8; 4] = [208u8, 139u8, 216u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: usdcBridgerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: usdcBridgerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    /**Function with signature `usdtBridger()` and selector `0x52d62f80`.
```solidity
function usdtBridger() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usdtBridgerCall;
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Default, Debug, PartialEq, Eq, Hash)]
    ///Container type for the return parameters of the [`usdtBridger()`](usdtBridgerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct usdtBridgerReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usdtBridgerCall> for UnderlyingRustTuple<'_> {
                fn from(value: usdtBridgerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usdtBridgerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self
                }
            }
        }
        {
            #[doc(hidden)]
            #[allow(dead_code)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<usdtBridgerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: usdtBridgerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for usdtBridgerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for usdtBridgerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = alloy::sol_types::private::Address;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "usdtBridger()";
            const SELECTOR: [u8; 4] = [82u8, 214u8, 47u8, 128u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn tokenize_returns(ret: &Self::Return) -> Self::ReturnToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        ret,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(data: &[u8]) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data)
                    .map(|r| {
                        let r: usdtBridgerReturn = r.into();
                        r._0
                    })
            }
            #[inline]
            fn abi_decode_returns_validate(
                data: &[u8],
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence_validate(data)
                    .map(|r| {
                        let r: usdtBridgerReturn = r.into();
                        r._0
                    })
            }
        }
    };
    ///Container for all the [`IntentsForwarder`](self) function calls.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive()]
    pub enum IntentsForwarderCalls {
        #[allow(missing_docs)]
        RECEIVER_BYTECODE_HASH(RECEIVER_BYTECODE_HASHCall),
        #[allow(missing_docs)]
        RECEIVER_IMPLEMENTATION(RECEIVER_IMPLEMENTATIONCall),
        #[allow(missing_docs)]
        SWAP_EXECUTOR(SWAP_EXECUTORCall),
        #[allow(missing_docs)]
        USDC(USDCCall),
        #[allow(missing_docs)]
        USDT(USDTCall),
        #[allow(missing_docs)]
        eventChainTip(eventChainTipCall),
        #[allow(missing_docs)]
        eventSeq(eventSeqCall),
        #[allow(missing_docs)]
        getReceiver(getReceiverCall),
        #[allow(missing_docs)]
        owner(ownerCall),
        #[allow(missing_docs)]
        predictReceiverAddress(predictReceiverAddressCall),
        #[allow(missing_docs)]
        pullFromReceiver(pullFromReceiverCall),
        #[allow(missing_docs)]
        quoterByToken(quoterByTokenCall),
        #[allow(missing_docs)]
        renounceOwnership(renounceOwnershipCall),
        #[allow(missing_docs)]
        setBridgers(setBridgersCall),
        #[allow(missing_docs)]
        setQuoter(setQuoterCall),
        #[allow(missing_docs)]
        transferOwnership(transferOwnershipCall),
        #[allow(missing_docs)]
        usdcBridger(usdcBridgerCall),
        #[allow(missing_docs)]
        usdtBridger(usdtBridgerCall),
    }
    impl IntentsForwarderCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 127u8, 43u8, 102u8],
            [4u8, 150u8, 194u8, 241u8],
            [11u8, 52u8, 88u8, 121u8],
            [26u8, 209u8, 8u8, 123u8],
            [43u8, 15u8, 62u8, 228u8],
            [63u8, 234u8, 52u8, 136u8],
            [77u8, 83u8, 233u8, 49u8],
            [82u8, 214u8, 47u8, 128u8],
            [98u8, 100u8, 37u8, 122u8],
            [113u8, 80u8, 24u8, 166u8],
            [137u8, 163u8, 2u8, 113u8],
            [141u8, 165u8, 203u8, 91u8],
            [197u8, 78u8, 68u8, 235u8],
            [208u8, 139u8, 216u8, 159u8],
            [226u8, 77u8, 92u8, 53u8],
            [232u8, 227u8, 204u8, 28u8],
            [237u8, 97u8, 169u8, 17u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(quoterByToken),
            ::core::stringify!(RECEIVER_IMPLEMENTATION),
            ::core::stringify!(SWAP_EXECUTOR),
            ::core::stringify!(pullFromReceiver),
            ::core::stringify!(setBridgers),
            ::core::stringify!(predictReceiverAddress),
            ::core::stringify!(eventChainTip),
            ::core::stringify!(usdtBridger),
            ::core::stringify!(setQuoter),
            ::core::stringify!(renounceOwnership),
            ::core::stringify!(USDC),
            ::core::stringify!(owner),
            ::core::stringify!(USDT),
            ::core::stringify!(usdcBridger),
            ::core::stringify!(eventSeq),
            ::core::stringify!(RECEIVER_BYTECODE_HASH),
            ::core::stringify!(getReceiver),
            ::core::stringify!(transferOwnership),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <quoterByTokenCall as alloy_sol_types::SolCall>::SIGNATURE,
            <RECEIVER_IMPLEMENTATIONCall as alloy_sol_types::SolCall>::SIGNATURE,
            <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::SIGNATURE,
            <pullFromReceiverCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setBridgersCall as alloy_sol_types::SolCall>::SIGNATURE,
            <predictReceiverAddressCall as alloy_sol_types::SolCall>::SIGNATURE,
            <eventChainTipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <usdtBridgerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <setQuoterCall as alloy_sol_types::SolCall>::SIGNATURE,
            <renounceOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
            <USDCCall as alloy_sol_types::SolCall>::SIGNATURE,
            <ownerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <USDTCall as alloy_sol_types::SolCall>::SIGNATURE,
            <usdcBridgerCall as alloy_sol_types::SolCall>::SIGNATURE,
            <eventSeqCall as alloy_sol_types::SolCall>::SIGNATURE,
            <RECEIVER_BYTECODE_HASHCall as alloy_sol_types::SolCall>::SIGNATURE,
            <getReceiverCall as alloy_sol_types::SolCall>::SIGNATURE,
            <transferOwnershipCall as alloy_sol_types::SolCall>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for IntentsForwarderCalls {
        const NAME: &'static str = "IntentsForwarderCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 18usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::RECEIVER_BYTECODE_HASH(_) => {
                    <RECEIVER_BYTECODE_HASHCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::RECEIVER_IMPLEMENTATION(_) => {
                    <RECEIVER_IMPLEMENTATIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SWAP_EXECUTOR(_) => {
                    <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::USDC(_) => <USDCCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::USDT(_) => <USDTCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::eventChainTip(_) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::eventSeq(_) => <eventSeqCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getReceiver(_) => {
                    <getReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::predictReceiverAddress(_) => {
                    <predictReceiverAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pullFromReceiver(_) => {
                    <pullFromReceiverCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::quoterByToken(_) => {
                    <quoterByTokenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setBridgers(_) => {
                    <setBridgersCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setQuoter(_) => {
                    <setQuoterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::usdcBridger(_) => {
                    <usdcBridgerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::usdtBridger(_) => {
                    <usdtBridgerCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<IntentsForwarderCalls>] = &[
                {
                    fn quoterByToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <quoterByTokenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::quoterByToken)
                    }
                    quoterByToken
                },
                {
                    fn RECEIVER_IMPLEMENTATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <RECEIVER_IMPLEMENTATIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::RECEIVER_IMPLEMENTATION)
                    }
                    RECEIVER_IMPLEMENTATION
                },
                {
                    fn SWAP_EXECUTOR(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::SWAP_EXECUTOR)
                    }
                    SWAP_EXECUTOR
                },
                {
                    fn pullFromReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <pullFromReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::pullFromReceiver)
                    }
                    pullFromReceiver
                },
                {
                    fn setBridgers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <setBridgersCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::setBridgers)
                    }
                    setBridgers
                },
                {
                    fn predictReceiverAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <predictReceiverAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::predictReceiverAddress)
                    }
                    predictReceiverAddress
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn usdtBridger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <usdtBridgerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::usdtBridger)
                    }
                    usdtBridger
                },
                {
                    fn setQuoter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <setQuoterCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(IntentsForwarderCalls::setQuoter)
                    }
                    setQuoter
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn USDC(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <USDCCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(IntentsForwarderCalls::USDC)
                    }
                    USDC
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(IntentsForwarderCalls::owner)
                    }
                    owner
                },
                {
                    fn USDT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <USDTCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(IntentsForwarderCalls::USDT)
                    }
                    USDT
                },
                {
                    fn usdcBridger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <usdcBridgerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::usdcBridger)
                    }
                    usdcBridger
                },
                {
                    fn eventSeq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <eventSeqCall as alloy_sol_types::SolCall>::abi_decode_raw(data)
                            .map(IntentsForwarderCalls::eventSeq)
                    }
                    eventSeq
                },
                {
                    fn RECEIVER_BYTECODE_HASH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <RECEIVER_BYTECODE_HASHCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::RECEIVER_BYTECODE_HASH)
                    }
                    RECEIVER_BYTECODE_HASH
                },
                {
                    fn getReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <getReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::getReceiver)
                    }
                    getReceiver
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<IntentsForwarderCalls>] = &[
                {
                    fn quoterByToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <quoterByTokenCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::quoterByToken)
                    }
                    quoterByToken
                },
                {
                    fn RECEIVER_IMPLEMENTATION(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <RECEIVER_IMPLEMENTATIONCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::RECEIVER_IMPLEMENTATION)
                    }
                    RECEIVER_IMPLEMENTATION
                },
                {
                    fn SWAP_EXECUTOR(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::SWAP_EXECUTOR)
                    }
                    SWAP_EXECUTOR
                },
                {
                    fn pullFromReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <pullFromReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::pullFromReceiver)
                    }
                    pullFromReceiver
                },
                {
                    fn setBridgers(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <setBridgersCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::setBridgers)
                    }
                    setBridgers
                },
                {
                    fn predictReceiverAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <predictReceiverAddressCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::predictReceiverAddress)
                    }
                    predictReceiverAddress
                },
                {
                    fn eventChainTip(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <eventChainTipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::eventChainTip)
                    }
                    eventChainTip
                },
                {
                    fn usdtBridger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <usdtBridgerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::usdtBridger)
                    }
                    usdtBridger
                },
                {
                    fn setQuoter(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <setQuoterCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::setQuoter)
                    }
                    setQuoter
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn USDC(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <USDCCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::USDC)
                    }
                    USDC
                },
                {
                    fn owner(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::owner)
                    }
                    owner
                },
                {
                    fn USDT(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <USDTCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::USDT)
                    }
                    USDT
                },
                {
                    fn usdcBridger(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <usdcBridgerCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::usdcBridger)
                    }
                    usdcBridger
                },
                {
                    fn eventSeq(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <eventSeqCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::eventSeq)
                    }
                    eventSeq
                },
                {
                    fn RECEIVER_BYTECODE_HASH(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <RECEIVER_BYTECODE_HASHCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::RECEIVER_BYTECODE_HASH)
                    }
                    RECEIVER_BYTECODE_HASH
                },
                {
                    fn getReceiver(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <getReceiverCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::getReceiver)
                    }
                    getReceiver
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::RECEIVER_BYTECODE_HASH(inner) => {
                    <RECEIVER_BYTECODE_HASHCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::RECEIVER_IMPLEMENTATION(inner) => {
                    <RECEIVER_IMPLEMENTATIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SWAP_EXECUTOR(inner) => {
                    <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::USDC(inner) => {
                    <USDCCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::USDT(inner) => {
                    <USDTCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::eventSeq(inner) => {
                    <eventSeqCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getReceiver(inner) => {
                    <getReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::predictReceiverAddress(inner) => {
                    <predictReceiverAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pullFromReceiver(inner) => {
                    <pullFromReceiverCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::quoterByToken(inner) => {
                    <quoterByTokenCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setBridgers(inner) => {
                    <setBridgersCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setQuoter(inner) => {
                    <setQuoterCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::usdcBridger(inner) => {
                    <usdcBridgerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::usdtBridger(inner) => {
                    <usdtBridgerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::RECEIVER_BYTECODE_HASH(inner) => {
                    <RECEIVER_BYTECODE_HASHCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::RECEIVER_IMPLEMENTATION(inner) => {
                    <RECEIVER_IMPLEMENTATIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SWAP_EXECUTOR(inner) => {
                    <SWAP_EXECUTORCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::USDC(inner) => {
                    <USDCCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::USDT(inner) => {
                    <USDTCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::eventChainTip(inner) => {
                    <eventChainTipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::eventSeq(inner) => {
                    <eventSeqCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getReceiver(inner) => {
                    <getReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::predictReceiverAddress(inner) => {
                    <predictReceiverAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pullFromReceiver(inner) => {
                    <pullFromReceiverCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::quoterByToken(inner) => {
                    <quoterByTokenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setBridgers(inner) => {
                    <setBridgersCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setQuoter(inner) => {
                    <setQuoterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::usdcBridger(inner) => {
                    <usdcBridgerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::usdtBridger(inner) => {
                    <usdtBridgerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`IntentsForwarder`](self) custom errors.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum IntentsForwarderErrors {
        #[allow(missing_docs)]
        AlreadyInitialized(AlreadyInitialized),
        #[allow(missing_docs)]
        InsufficientOutputAmount(InsufficientOutputAmount),
        #[allow(missing_docs)]
        NewOwnerIsZeroAddress(NewOwnerIsZeroAddress),
        #[allow(missing_docs)]
        PullerUnauthorized(PullerUnauthorized),
        #[allow(missing_docs)]
        SwapOnEphemeralReceiversNotAllowed(SwapOnEphemeralReceiversNotAllowed),
        #[allow(missing_docs)]
        Unauthorized(Unauthorized),
        #[allow(missing_docs)]
        UnsupportedOutputToken(UnsupportedOutputToken),
    }
    impl IntentsForwarderErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [13u8, 193u8, 73u8, 240u8],
            [54u8, 181u8, 7u8, 251u8],
            [66u8, 48u8, 28u8, 35u8],
            [116u8, 72u8, 251u8, 174u8],
            [130u8, 180u8, 41u8, 0u8],
            [143u8, 180u8, 209u8, 15u8],
            [178u8, 174u8, 133u8, 85u8],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(AlreadyInitialized),
            ::core::stringify!(PullerUnauthorized),
            ::core::stringify!(InsufficientOutputAmount),
            ::core::stringify!(NewOwnerIsZeroAddress),
            ::core::stringify!(Unauthorized),
            ::core::stringify!(SwapOnEphemeralReceiversNotAllowed),
            ::core::stringify!(UnsupportedOutputToken),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <AlreadyInitialized as alloy_sol_types::SolError>::SIGNATURE,
            <PullerUnauthorized as alloy_sol_types::SolError>::SIGNATURE,
            <InsufficientOutputAmount as alloy_sol_types::SolError>::SIGNATURE,
            <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::SIGNATURE,
            <Unauthorized as alloy_sol_types::SolError>::SIGNATURE,
            <SwapOnEphemeralReceiversNotAllowed as alloy_sol_types::SolError>::SIGNATURE,
            <UnsupportedOutputToken as alloy_sol_types::SolError>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 4usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for IntentsForwarderErrors {
        const NAME: &'static str = "IntentsForwarderErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 7usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AlreadyInitialized(_) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientOutputAmount(_) => {
                    <InsufficientOutputAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NewOwnerIsZeroAddress(_) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PullerUnauthorized(_) => {
                    <PullerUnauthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SwapOnEphemeralReceiversNotAllowed(_) => {
                    <SwapOnEphemeralReceiversNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Unauthorized(_) => {
                    <Unauthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UnsupportedOutputToken(_) => {
                    <UnsupportedOutputToken as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<IntentsForwarderErrors>] = &[
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn PullerUnauthorized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <PullerUnauthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderErrors::PullerUnauthorized)
                    }
                    PullerUnauthorized
                },
                {
                    fn InsufficientOutputAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <InsufficientOutputAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderErrors::InsufficientOutputAmount)
                    }
                    InsufficientOutputAmount
                },
                {
                    fn NewOwnerIsZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderErrors::NewOwnerIsZeroAddress)
                    }
                    NewOwnerIsZeroAddress
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw(data)
                            .map(IntentsForwarderErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn SwapOnEphemeralReceiversNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <SwapOnEphemeralReceiversNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(
                                IntentsForwarderErrors::SwapOnEphemeralReceiversNotAllowed,
                            )
                    }
                    SwapOnEphemeralReceiversNotAllowed
                },
                {
                    fn UnsupportedOutputToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <UnsupportedOutputToken as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                            )
                            .map(IntentsForwarderErrors::UnsupportedOutputToken)
                    }
                    UnsupportedOutputToken
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data)
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw_validate(
            selector: [u8; 4],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_VALIDATE_SHIMS: &[fn(
                &[u8],
            ) -> alloy_sol_types::Result<IntentsForwarderErrors>] = &[
                {
                    fn AlreadyInitialized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <AlreadyInitialized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderErrors::AlreadyInitialized)
                    }
                    AlreadyInitialized
                },
                {
                    fn PullerUnauthorized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <PullerUnauthorized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderErrors::PullerUnauthorized)
                    }
                    PullerUnauthorized
                },
                {
                    fn InsufficientOutputAmount(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <InsufficientOutputAmount as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderErrors::InsufficientOutputAmount)
                    }
                    InsufficientOutputAmount
                },
                {
                    fn NewOwnerIsZeroAddress(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderErrors::NewOwnerIsZeroAddress)
                    }
                    NewOwnerIsZeroAddress
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn SwapOnEphemeralReceiversNotAllowed(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <SwapOnEphemeralReceiversNotAllowed as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(
                                IntentsForwarderErrors::SwapOnEphemeralReceiversNotAllowed,
                            )
                    }
                    SwapOnEphemeralReceiversNotAllowed
                },
                {
                    fn UnsupportedOutputToken(
                        data: &[u8],
                    ) -> alloy_sol_types::Result<IntentsForwarderErrors> {
                        <UnsupportedOutputToken as alloy_sol_types::SolError>::abi_decode_raw_validate(
                                data,
                            )
                            .map(IntentsForwarderErrors::UnsupportedOutputToken)
                    }
                    UnsupportedOutputToken
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_VALIDATE_SHIMS[idx](data)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientOutputAmount(inner) => {
                    <InsufficientOutputAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PullerUnauthorized(inner) => {
                    <PullerUnauthorized as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SwapOnEphemeralReceiversNotAllowed(inner) => {
                    <SwapOnEphemeralReceiversNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::UnsupportedOutputToken(inner) => {
                    <UnsupportedOutputToken as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AlreadyInitialized(inner) => {
                    <AlreadyInitialized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientOutputAmount(inner) => {
                    <InsufficientOutputAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NewOwnerIsZeroAddress(inner) => {
                    <NewOwnerIsZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PullerUnauthorized(inner) => {
                    <PullerUnauthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SwapOnEphemeralReceiversNotAllowed(inner) => {
                    <SwapOnEphemeralReceiversNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UnsupportedOutputToken(inner) => {
                    <UnsupportedOutputToken as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`IntentsForwarder`](self) events.
    #[derive(Clone)]
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub enum IntentsForwarderEvents {
        #[allow(missing_docs)]
        BridgeInitiated(BridgeInitiated),
        #[allow(missing_docs)]
        BridgersSet(BridgersSet),
        #[allow(missing_docs)]
        EventAppended(EventAppended),
        #[allow(missing_docs)]
        ForwardCompleted(ForwardCompleted),
        #[allow(missing_docs)]
        ForwardStarted(ForwardStarted),
        #[allow(missing_docs)]
        OwnershipTransferred(OwnershipTransferred),
        #[allow(missing_docs)]
        QuoterSet(QuoterSet),
        #[allow(missing_docs)]
        ReceiverDeployed(ReceiverDeployed),
        #[allow(missing_docs)]
        SwapExecuted(SwapExecuted),
    }
    impl IntentsForwarderEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                20u8, 192u8, 40u8, 211u8, 214u8, 104u8, 235u8, 52u8, 84u8, 188u8, 228u8,
                77u8, 18u8, 60u8, 238u8, 235u8, 159u8, 180u8, 231u8, 75u8, 238u8, 7u8,
                60u8, 65u8, 244u8, 0u8, 30u8, 99u8, 240u8, 97u8, 48u8, 148u8,
            ],
            [
                45u8, 252u8, 246u8, 70u8, 249u8, 83u8, 180u8, 29u8, 44u8, 217u8, 211u8,
                11u8, 207u8, 63u8, 108u8, 218u8, 82u8, 72u8, 239u8, 205u8, 119u8, 51u8,
                173u8, 255u8, 58u8, 37u8, 232u8, 143u8, 53u8, 184u8, 175u8, 203u8,
            ],
            [
                46u8, 61u8, 125u8, 2u8, 186u8, 60u8, 75u8, 216u8, 177u8, 248u8, 153u8,
                92u8, 211u8, 162u8, 62u8, 240u8, 25u8, 57u8, 34u8, 235u8, 196u8, 238u8,
                35u8, 36u8, 158u8, 173u8, 77u8, 12u8, 162u8, 227u8, 76u8, 104u8,
            ],
            [
                46u8, 101u8, 144u8, 129u8, 244u8, 76u8, 79u8, 86u8, 161u8, 139u8, 0u8,
                243u8, 249u8, 209u8, 54u8, 215u8, 238u8, 131u8, 150u8, 188u8, 121u8,
                22u8, 60u8, 77u8, 97u8, 54u8, 61u8, 220u8, 244u8, 164u8, 203u8, 39u8,
            ],
            [
                47u8, 76u8, 118u8, 200u8, 209u8, 143u8, 69u8, 6u8, 155u8, 9u8, 65u8,
                73u8, 146u8, 5u8, 167u8, 252u8, 234u8, 170u8, 60u8, 175u8, 158u8, 46u8,
                99u8, 40u8, 246u8, 165u8, 68u8, 205u8, 51u8, 145u8, 32u8, 243u8,
            ],
            [
                72u8, 143u8, 6u8, 169u8, 202u8, 158u8, 25u8, 225u8, 221u8, 144u8, 199u8,
                100u8, 204u8, 121u8, 183u8, 101u8, 232u8, 163u8, 160u8, 137u8, 239u8,
                39u8, 217u8, 160u8, 227u8, 157u8, 238u8, 33u8, 199u8, 100u8, 49u8, 136u8,
            ],
            [
                115u8, 145u8, 241u8, 67u8, 85u8, 239u8, 241u8, 229u8, 89u8, 227u8, 129u8,
                245u8, 191u8, 73u8, 136u8, 106u8, 119u8, 218u8, 124u8, 79u8, 221u8, 51u8,
                198u8, 252u8, 46u8, 1u8, 66u8, 38u8, 156u8, 86u8, 28u8, 89u8,
            ],
            [
                120u8, 22u8, 15u8, 11u8, 27u8, 43u8, 50u8, 181u8, 42u8, 0u8, 118u8,
                216u8, 240u8, 247u8, 8u8, 136u8, 104u8, 123u8, 167u8, 2u8, 164u8, 217u8,
                147u8, 213u8, 90u8, 200u8, 217u8, 50u8, 125u8, 87u8, 161u8, 39u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8,
                31u8, 208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8,
                218u8, 175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
        ];
        /// The names of the variants in the same order as `SELECTORS`.
        pub const VARIANT_NAMES: &'static [&'static str] = &[
            ::core::stringify!(BridgersSet),
            ::core::stringify!(BridgeInitiated),
            ::core::stringify!(QuoterSet),
            ::core::stringify!(ForwardCompleted),
            ::core::stringify!(SwapExecuted),
            ::core::stringify!(ReceiverDeployed),
            ::core::stringify!(ForwardStarted),
            ::core::stringify!(EventAppended),
            ::core::stringify!(OwnershipTransferred),
        ];
        /// The signatures in the same order as `SELECTORS`.
        pub const SIGNATURES: &'static [&'static str] = &[
            <BridgersSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <BridgeInitiated as alloy_sol_types::SolEvent>::SIGNATURE,
            <QuoterSet as alloy_sol_types::SolEvent>::SIGNATURE,
            <ForwardCompleted as alloy_sol_types::SolEvent>::SIGNATURE,
            <SwapExecuted as alloy_sol_types::SolEvent>::SIGNATURE,
            <ReceiverDeployed as alloy_sol_types::SolEvent>::SIGNATURE,
            <ForwardStarted as alloy_sol_types::SolEvent>::SIGNATURE,
            <EventAppended as alloy_sol_types::SolEvent>::SIGNATURE,
            <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE,
        ];
        /// Returns the signature for the given selector, if known.
        #[inline]
        pub fn signature_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            match Self::SELECTORS.binary_search(&selector) {
                ::core::result::Result::Ok(idx) => {
                    ::core::option::Option::Some(Self::SIGNATURES[idx])
                }
                ::core::result::Result::Err(_) => ::core::option::Option::None,
            }
        }
        /// Returns the enum variant name for the given selector, if known.
        #[inline]
        pub fn name_by_selector(
            selector: [u8; 32usize],
        ) -> ::core::option::Option<&'static str> {
            let sig = Self::signature_by_selector(selector)?;
            sig.split_once('(').map(|(name, _)| name)
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for IntentsForwarderEvents {
        const NAME: &'static str = "IntentsForwarderEvents";
        const COUNT: usize = 9usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<BridgeInitiated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgeInitiated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BridgeInitiated)
                }
                Some(<BridgersSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BridgersSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::BridgersSet)
                }
                Some(<EventAppended as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EventAppended as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::EventAppended)
                }
                Some(<ForwardCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ForwardCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ForwardCompleted)
                }
                Some(<ForwardStarted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ForwardStarted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ForwardStarted)
                }
                Some(
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::OwnershipTransferred)
                }
                Some(<QuoterSet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <QuoterSet as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::QuoterSet)
                }
                Some(<ReceiverDeployed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ReceiverDeployed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::ReceiverDeployed)
                }
                Some(<SwapExecuted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SwapExecuted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                        )
                        .map(Self::SwapExecuted)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for IntentsForwarderEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeInitiated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BridgersSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EventAppended(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ForwardCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ForwardStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::QuoterSet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ReceiverDeployed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SwapExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::BridgeInitiated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BridgersSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EventAppended(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ForwardCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ForwardStarted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::QuoterSet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ReceiverDeployed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SwapExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`IntentsForwarder`](self) contract instance.

See the [wrapper's documentation](`IntentsForwarderInstance`) for more details.*/
    #[inline]
    pub const fn new<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        __provider: P,
    ) -> IntentsForwarderInstance<P, N> {
        IntentsForwarderInstance::<P, N>::new(address, __provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _usdt: alloy::sol_types::private::Address,
        _usdc: alloy::sol_types::private::Address,
        _owner: alloy::sol_types::private::Address,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<IntentsForwarderInstance<P, N>>,
    > {
        IntentsForwarderInstance::<P, N>::deploy(__provider, _usdt, _usdc, _owner)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    >(
        __provider: P,
        _usdt: alloy::sol_types::private::Address,
        _usdc: alloy::sol_types::private::Address,
        _owner: alloy::sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<P, N> {
        IntentsForwarderInstance::<
            P,
            N,
        >::deploy_builder(__provider, _usdt, _usdc, _owner)
    }
    /**A [`IntentsForwarder`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`IntentsForwarder`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct IntentsForwarderInstance<P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network: ::core::marker::PhantomData<N>,
    }
    #[automatically_derived]
    impl<P, N> ::core::fmt::Debug for IntentsForwarderInstance<P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("IntentsForwarderInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > IntentsForwarderInstance<P, N> {
        /**Creates a new wrapper around an on-chain [`IntentsForwarder`](self) contract instance.

See the [wrapper's documentation](`IntentsForwarderInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            __provider: P,
        ) -> Self {
            Self {
                address,
                provider: __provider,
                _network: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            __provider: P,
            _usdt: alloy::sol_types::private::Address,
            _usdc: alloy::sol_types::private::Address,
            _owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::Result<IntentsForwarderInstance<P, N>> {
            let call_builder = Self::deploy_builder(__provider, _usdt, _usdc, _owner);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(
            __provider: P,
            _usdt: alloy::sol_types::private::Address,
            _usdc: alloy::sol_types::private::Address,
            _owner: alloy::sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                __provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(
                        &constructorCall {
                            _usdt,
                            _usdc,
                            _owner,
                        },
                    )[..],
                ]
                    .concat()
                    .into(),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<P: ::core::clone::Clone, N> IntentsForwarderInstance<&P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> IntentsForwarderInstance<P, N> {
            IntentsForwarderInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > IntentsForwarderInstance<P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<&P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`RECEIVER_BYTECODE_HASH`] function.
        pub fn RECEIVER_BYTECODE_HASH(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, RECEIVER_BYTECODE_HASHCall, N> {
            self.call_builder(&RECEIVER_BYTECODE_HASHCall)
        }
        ///Creates a new call builder for the [`RECEIVER_IMPLEMENTATION`] function.
        pub fn RECEIVER_IMPLEMENTATION(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, RECEIVER_IMPLEMENTATIONCall, N> {
            self.call_builder(&RECEIVER_IMPLEMENTATIONCall)
        }
        ///Creates a new call builder for the [`SWAP_EXECUTOR`] function.
        pub fn SWAP_EXECUTOR(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, SWAP_EXECUTORCall, N> {
            self.call_builder(&SWAP_EXECUTORCall)
        }
        ///Creates a new call builder for the [`USDC`] function.
        pub fn USDC(&self) -> alloy_contract::SolCallBuilder<&P, USDCCall, N> {
            self.call_builder(&USDCCall)
        }
        ///Creates a new call builder for the [`USDT`] function.
        pub fn USDT(&self) -> alloy_contract::SolCallBuilder<&P, USDTCall, N> {
            self.call_builder(&USDTCall)
        }
        ///Creates a new call builder for the [`eventChainTip`] function.
        pub fn eventChainTip(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, eventChainTipCall, N> {
            self.call_builder(&eventChainTipCall)
        }
        ///Creates a new call builder for the [`eventSeq`] function.
        pub fn eventSeq(&self) -> alloy_contract::SolCallBuilder<&P, eventSeqCall, N> {
            self.call_builder(&eventSeqCall)
        }
        ///Creates a new call builder for the [`getReceiver`] function.
        pub fn getReceiver(
            &self,
            salt: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, getReceiverCall, N> {
            self.call_builder(&getReceiverCall { salt })
        }
        ///Creates a new call builder for the [`owner`] function.
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<&P, ownerCall, N> {
            self.call_builder(&ownerCall)
        }
        ///Creates a new call builder for the [`predictReceiverAddress`] function.
        pub fn predictReceiverAddress(
            &self,
            salt: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<&P, predictReceiverAddressCall, N> {
            self.call_builder(&predictReceiverAddressCall { salt })
        }
        ///Creates a new call builder for the [`pullFromReceiver`] function.
        pub fn pullFromReceiver(
            &self,
            req: <PullRequest as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<&P, pullFromReceiverCall, N> {
            self.call_builder(&pullFromReceiverCall { req })
        }
        ///Creates a new call builder for the [`quoterByToken`] function.
        pub fn quoterByToken(
            &self,
            _0: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, quoterByTokenCall, N> {
            self.call_builder(&quoterByTokenCall(_0))
        }
        ///Creates a new call builder for the [`renounceOwnership`] function.
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall)
        }
        ///Creates a new call builder for the [`setBridgers`] function.
        pub fn setBridgers(
            &self,
            _usdtBridger: alloy::sol_types::private::Address,
            _usdcBridger: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setBridgersCall, N> {
            self.call_builder(
                &setBridgersCall {
                    _usdtBridger,
                    _usdcBridger,
                },
            )
        }
        ///Creates a new call builder for the [`setQuoter`] function.
        pub fn setQuoter(
            &self,
            targetToken: alloy::sol_types::private::Address,
            quoter: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, setQuoterCall, N> {
            self.call_builder(
                &setQuoterCall {
                    targetToken,
                    quoter,
                },
            )
        }
        ///Creates a new call builder for the [`transferOwnership`] function.
        pub fn transferOwnership(
            &self,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<&P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        ///Creates a new call builder for the [`usdcBridger`] function.
        pub fn usdcBridger(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, usdcBridgerCall, N> {
            self.call_builder(&usdcBridgerCall)
        }
        ///Creates a new call builder for the [`usdtBridger`] function.
        pub fn usdtBridger(
            &self,
        ) -> alloy_contract::SolCallBuilder<&P, usdtBridgerCall, N> {
            self.call_builder(&usdtBridgerCall)
        }
    }
    /// Event filters.
    impl<
        P: alloy_contract::private::Provider<N>,
        N: alloy_contract::private::Network,
    > IntentsForwarderInstance<P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<&P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`BridgeInitiated`] event.
        pub fn BridgeInitiated_filter(
            &self,
        ) -> alloy_contract::Event<&P, BridgeInitiated, N> {
            self.event_filter::<BridgeInitiated>()
        }
        ///Creates a new event filter for the [`BridgersSet`] event.
        pub fn BridgersSet_filter(&self) -> alloy_contract::Event<&P, BridgersSet, N> {
            self.event_filter::<BridgersSet>()
        }
        ///Creates a new event filter for the [`EventAppended`] event.
        pub fn EventAppended_filter(
            &self,
        ) -> alloy_contract::Event<&P, EventAppended, N> {
            self.event_filter::<EventAppended>()
        }
        ///Creates a new event filter for the [`ForwardCompleted`] event.
        pub fn ForwardCompleted_filter(
            &self,
        ) -> alloy_contract::Event<&P, ForwardCompleted, N> {
            self.event_filter::<ForwardCompleted>()
        }
        ///Creates a new event filter for the [`ForwardStarted`] event.
        pub fn ForwardStarted_filter(
            &self,
        ) -> alloy_contract::Event<&P, ForwardStarted, N> {
            self.event_filter::<ForwardStarted>()
        }
        ///Creates a new event filter for the [`OwnershipTransferred`] event.
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<&P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        ///Creates a new event filter for the [`QuoterSet`] event.
        pub fn QuoterSet_filter(&self) -> alloy_contract::Event<&P, QuoterSet, N> {
            self.event_filter::<QuoterSet>()
        }
        ///Creates a new event filter for the [`ReceiverDeployed`] event.
        pub fn ReceiverDeployed_filter(
            &self,
        ) -> alloy_contract::Event<&P, ReceiverDeployed, N> {
            self.event_filter::<ReceiverDeployed>()
        }
        ///Creates a new event filter for the [`SwapExecuted`] event.
        pub fn SwapExecuted_filter(&self) -> alloy_contract::Event<&P, SwapExecuted, N> {
            self.event_filter::<SwapExecuted>()
        }
    }
}
