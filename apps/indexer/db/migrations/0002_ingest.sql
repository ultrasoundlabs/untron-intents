/*
Ingestion layer written by the worker.

Core invariants:
- `chain.event_appended` stores the canonical total order for each configured instance via
  EventAppended(event_seq).
- Reorgs are represented by flipping `canonical=false` (never deleting rows).
- Projection tables are derived deterministically from canonical rows by per-stream projectors.

Untron Intents model:
- `pool`      stream: exactly one configured instance (single chain + single contract).
- `forwarder` stream: many configured instances (one per supported EVM chain).
*/

-- =========================
-- INSTANCE CONFIG
-- =========================
create table if not exists chain.instance (
    stream chain.stream not null,

    -- numeric chain_id
    chain_id bigint not null,

    -- deployed index contract address for this instance (EVM)
    contract_address evm_address not null,

    -- EventChainGenesis constant for that index contract
    genesis_tip bytes32_hex not null,

    inserted_at timestamptz not null default now(),

    primary key (stream, chain_id, contract_address),

    constraint instance_chain_id_positive
    check (chain_id > 0)
);

-- Enforce the "single pool instance" invariant.
create unique index if not exists instance_pool_singleton
on chain.instance ((1))
where stream = 'pool';

-- =========================
-- CANONICAL EVENT STREAM: EventAppended logs
-- =========================
create table if not exists chain.event_appended (
id bigint generated by default as identity primary key,

stream chain.stream not null,
chain_id bigint not null,
contract_address evm_address not null,

block_number bigint not null,
block_timestamp bigint not null,
block_hash bytes32_hex not null,

tx_hash txhash_hex not null,
log_index integer not null,

-- canonicality for reorg handling:
-- worker flips canonical=false on removed fork logs
canonical boolean not null default true,

-- hash-chain payload from EventAppended
event_seq bigint not null,
prev_tip bytes32_hex not null,
new_tip bytes32_hex not null,
event_signature bytes32_hex not null,

-- EXACT ABI bytes blob used in the onchain hash chain (hex string)
abi_encoded_event_data bytes_hex not null,

-- worker-decoded "semantic event"
event_type text not null, -- e.g. 'IntentCreated'
-- snake_case keys; values as strings/hex
args jsonb not null default '{}'::jsonb,

inserted_at timestamptz not null default now(),

constraint event_appended_instance_fk
foreign key (stream, chain_id, contract_address)
references chain.instance (stream, chain_id, contract_address),

constraint event_appended_timestamp_seconds_range
check (block_timestamp >= 946684800 and block_timestamp < 20000000000),

constraint event_appended_nonnegative
check (
block_number >= 0
and block_timestamp >= 0
and log_index >= 0
and event_seq > 0
)
);

-- Idempotency: chain log identity (unique within a tx receipt on a chain).
create unique index if not exists event_appended_uid
on chain.event_appended (chain_id, tx_hash, log_index);

-- At most one canonical event at a given seq per instance.
create unique index if not exists event_appended_canonical_seq
on chain.event_appended (stream, chain_id, contract_address, event_seq)
where canonical;

-- Projector scan index.
create index if not exists event_appended_scan
on chain.event_appended (stream,
chain_id,
contract_address,
canonical,
event_seq);

-- Reorg check / recent hash scan patterns.
create index if not exists event_appended_canonical_block
on chain.event_appended (stream,
chain_id,
contract_address,
block_number desc,
log_index desc)
where canonical;

create index if not exists event_appended_canonical_time
on chain.event_appended (stream,
chain_id,
contract_address,
block_timestamp desc,
event_seq desc)
where canonical;

-- =========================
-- STREAM CURSORS (projection state machine)
-- =========================
/*
applied_through_seq:
- highest canonical event_seq already applied to projections

tip:
- expected prev_tip for the next event (event_seq = applied_through_seq + 1)
*/
create table if not exists chain.stream_cursor (
stream chain.stream not null,
chain_id bigint not null,
contract_address evm_address not null,

applied_through_seq bigint not null default 0,
tip bytes32_hex not null,

updated_at timestamptz not null default now(),

primary key (stream, chain_id, contract_address),

constraint stream_cursor_instance_fk
foreign key (stream, chain_id, contract_address)
references chain.instance (stream, chain_id, contract_address),

constraint stream_cursor_nonnegative
check (applied_through_seq >= 0)
);

-- Seed + configure must happen explicitly so ingestion fails loudly until set.
create or replace function chain.configure_instance(
p_stream chain.stream,
p_chain_id bigint,
p_contract_address evm_address,
p_genesis_tip bytes32_hex
) returns void language plpgsql as $$
declare
  cur_applied bigint;
begin
  if p_chain_id <= 0 then
    raise exception 'chain_id must be > 0 (got %)', p_chain_id;
  end if;

  select applied_through_seq
    into cur_applied
    from chain.stream_cursor
   where stream = p_stream
     and chain_id = p_chain_id
     and contract_address = p_contract_address
   for update;

  if found and cur_applied <> 0 then
    raise exception 'cannot reconfigure instance (stream=%, chain_id=%, contract=%), already applied through seq %',
      p_stream, p_chain_id, p_contract_address, cur_applied;
  end if;

  insert into chain.instance(stream, chain_id, contract_address, genesis_tip)
  values (p_stream, p_chain_id, p_contract_address, p_genesis_tip)
  on conflict (stream, chain_id, contract_address) do update
    set genesis_tip = excluded.genesis_tip;

  insert into chain.stream_cursor(stream, chain_id, contract_address, applied_through_seq, tip)
  values (p_stream, p_chain_id, p_contract_address, 0, p_genesis_tip)
  on conflict (stream, chain_id, contract_address) do update
    set applied_through_seq = 0,
        tip = excluded.tip,
        updated_at = now();
end $$;
